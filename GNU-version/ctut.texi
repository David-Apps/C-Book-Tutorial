\input texinfo       @c -*-texinfo-*-
@c @novalidate
@setfilename ctutorial.info
@settitle The GNU C Programming Tutorial
@setchapternewpage odd
@set edition-major-minor-number 4.1
@c @smallbook
@c finalout
@c %** end of header

@syncodeindex pg fn
@syncodeindex tp fn
@syncodeindex vr fn

@ignore
@ifinfo
@format
START-INFO-DIR-ENTRY
* C Programming Tutorial: (ctutorial.info).  How to program in C.
END-INFO-DIR-ENTRY
@end format
@end ifinfo
@end ignore

Edition @value{edition-major-minor-number}

@titlepage
@title The GNU C Programming Tutorial

@author Mark Burgess
@author Faculty of Engineering, Oslo College
@author
@author Ron Hale-Evans

@page
@vskip 0pt plus 1fill

Copyright @copyright{} 2002 Free Software Foundation, Inc.

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.1 or
any later version published by the Free Software Foundation; there
being no Invariant Section, with the Front-Cover Texts being ``A GNU
Manual'', and with the Back-Cover Texts as in (a) below.  A copy of
the license is included in the section entitled ``GNU Free
Documentation License''.

(a) The FSF's Back-Cover Text is: ``You have freedom to copy and
modify this GNU Manual, like GNU software.  Copies published by the
Free Software Foundation raise funds for GNU development.''
@end quotation
@end titlepage


@node Top, Preface, (dir), (dir)

@ifinfo
This master menu first lists each chapter and index; then it lists
every node in every chapter.
@end ifinfo

@menu
* Preface::                     
* Introduction::                
* Using a compiler::            
* The form of a C program::     
* Functions::                   
* Variables and declarations::  
* Scope::                       
* Expressions and operators::   
* Parameters::                  
* Pointers::                    
* Decisions::                   
* Loops::                       
* Preprocessor directives::     
* Libraries::                   
* Arrays::                      
* Strings::                     
* Input and output::            
* Putting a program together::  
* Advanced operators::          
* More data types::             
* Data structures::             
* Recursion::                   
* Style::                       
* Debugging::                   
* Example programs::            
* A note from the original author::  
* Reserved words in C::         
* Precedence of operators::     
* Special characters::          
* Character conversion table::  
* A word about goto::           
* Answers to questions::        
* Bibliography::                
* Glossary::                    
* Code index::                  
* Concept index::               
* Bits and pieces::             
@end menu




@iftex
@pageno = -11
@end iftex

@node Preface, Introduction, Top, Top
@unnumbered Preface


@cindex C language, why it is useful
@cindex C language as standard

This book is a tutorial for the computer programming language C.  Unlike
BASIC or Pascal, C was not written as a teaching aid, but as a
professional tool.  Programmers love C!  Moreover, C is a standard,
widely-used language, and a single C program can often be made to run on
many different kinds of computer.  As Richard M. Stallman remarks in
@cite{GNU Coding Standards}, ``Using another language is like using a
non-standard feature: it will cause trouble for users.''  (See
@uref{http://www.gnu.org/prep/standards_toc.html}.)

@cindex C language, unforgiving nature
@cindex Unforgiving nature of C language
@cindex C language, power of
@cindex Power of C language

Skeptics have said that everything that can go wrong in C, does.  True,
it can be unforgiving, and holds some difficulties that are not obvious at
first, but that is because it does not withhold its powerful
capabilities from the beginner.  If you have come to C seeking a powerful
language for writing everyday computer programs, you will not be
disappointed.

@cindex GNU Project
@cindex GNU/Linux
@cindex Software, free
@cindex Free software

To get the most from this book, you should have some basic computer
literacy --- you should be able to run a program, edit a text file, and
so on.  You should also have access to a computer running a GNU system
such as GNU/Linux.  (For more information on GNU and the philosophy of
free software, see @uref{http://www.gnu.org/philosophy/}.)

The tutorial introduces basic ideas in a logical order and progresses
steadily.  You do not need to follow the order of the chapters
rigorously, but if you are a beginner to C, it is recommended that you
do.  Later, you can return to this book and copy C code from it;
the many examples range from tiny programs that illustrate the use of
one simple feature, to complete applications that fill several pages.
Along the way, there are also brief discussions of the philosophy behind
C.

@cindex Jargon

Computer languages have been around so long that some jargon has
developed.  You should not ignore this jargon entirely, because it is
the language that programmers speak.  Jargon is explained wherever
necessary, but kept to a minimum.  There is also a glossary at the back
of the book.

@cindex GNU Free Documentation License
@cindex GNU FDL
@cindex Free Documentation License
@cindex FDL

The authors of this book hope you will learn everything you need to
write simple C programs from this book.  Further, it is released under
the GNU Free Documentation License, so as the computers and robots in
the fantasies of Douglas Adams say, ``Share and Enjoy!''

@sp 3

@emph{The first edition of this book was written in 1987, then updated
and rewritten in 1999.  It was originally published by Dabs Press.
After it went out of print, David Atherton of Dabs and the original
author, Mark Burgess, agreed to release the manuscript.  At the request
of the Free Software Foundation, the book was further revised by Ron
Hale-Evans in 2001 and 2002.}

@cindex Texinfo
@cindex Emacs Info reader
@cindex Info reader

@emph{The current edition is written in Texinfo, which is a
documentation system using a single source file to produce both online
information and printed output.  You can read this tutorial online with
either the Emacs Info reader, the stand-alone Info reader, or a World
Wide Web browser, or you can read it as a printed book.}



@c Start main text on right-hand (verso) page

@tex
\par\vfill\supereject
\headings off
\ifodd\pageno
    \par\vfill\supereject
\else
    \par\vfill\supereject
    \page\hbox{}\page
    \par\vfill\supereject
\fi
@end tex

@c Start main text with page number 1
@iftex
@headings off
@evenheading @thispage @| @| @thischapter
@oddheading @thissection @| @| @thispage
@pageno = 1
@end iftex






@c CHAPTER 1
@node Introduction, Using a compiler, Preface, Top
@chapter Introduction

@emph{What is a high-level language?  Why is C unusual?}

@cindex Levels of detail
@cindex Detail, levels of

Any sufficiently complex object has levels of detail; the amount of
detail we see depends on how closely we scrutinize the object.  A
computer has many levels of detail.

@cindex Low level, the
@cindex High level, the

The terms @dfn{low level} and @dfn{high level} are often used to
describe these layers of complexity in computers.  The low level is
buried in the computer's microchips and microcircuits.  The low level is
the level at which the computer seems most primitive and mechanical,
whereas the high level describes the computer in less detail, and makes it
easier to use.

@cindex Car as metaphor for computer
@cindex Automobile as metaphor for computer
@cindex Black boxes
@cindex Boxes, black

You can see high levels and low levels in the workings of a car.  In a
car, the nuts, bolts, and pistons of the low level can be grouped
together conceptually to form the higher-level engine.  Without knowing
anything about the nuts and bolts, you can treat the engine as a
@dfn{black box}: a simple unit that behaves in predictable ways.  At an
even higher level (the one most people use when driving), you can see a
car as a group of these black boxes, including the engine, the steering,
the brakes, and so on.  At a high level, a computer also becomes a group
of black boxes.

@cindex C language as high-level language
@cindex High-level language, C language as

C is a high-level language.  The aim of any high-level computer language
is to provide an easy, natural way to give a list of instructions (a
computer program) to a computer.  The native language of the computer is
a stream of numbers called @dfn{machine language}.  As you might expect,
the action resulting from a single machine language instruction is very
primitive, and many thousands of them can be required to do something
substantial.  A high-level language provides a set of instructions you
can recombine creatively and give to the imaginary black boxes of the
computer.  The high-level language software will then translate these
high-level instructions into low-level machine language instructions.

@menu
* Advantages of C::             
* Questions for Chapter 1::     
@end menu



@node Advantages of C, Questions for Chapter 1, Introduction, Introduction
@section The advantages of C

@cindex C language, advantages of
@cindex Advantages of the C language

@cindex general-purpose programming
@cindex programming, general-purpose

C is one of a large number of high-level languages designed for
@dfn{general-purpose programming}, in other words, for writing anything
from small programs for personal amusement to complex industrial
applications.

C has many advantages:

@itemize @bullet

@cindex Black boxes, disadvantages of
@cindex Disadvantages of black boxes

@item
Before C, machine-language programmers criticized high-level languages
because, with their black box approach, they shielded the user from the
working details of the computer and all its facilities.  C, however, was
designed to give access to any level of the computer down to raw machine
language, and because of this, it is perhaps the most flexible
high-level language.

@cindex C language, flexibility of
@cindex Style, freedom of in C language
@cindex Freedom of style in C language

@item
C has features that allow the programmer to organize programs in a
clear, easy, logical way.  For example, C allows meaningful names for
variables without any loss of efficiency, yet it gives a complete
freedom of programming style, including flexible ways of making
decisions, and a set of flexible commands for performing tasks
repetitively (@code{for}, @code{while}, @code{do}).

@cindex C language, succinctness of
@cindex Suucinctness of C language

@item
C is succinct.  It permits the creation of tidy, compact programs.  This
feature can be a mixed blessing, however, and the C programmer must
balance simplicity and readability.

@cindex C language, concealed difficulties
@cindex C language, power of
@cindex Concealed difficulties of C language
@cindex Power of C language

@item
C allows commands that are invalid in other languages.  This is no
defect, but a powerful freedom which, when used with caution, makes many
things possible.  It does mean that there are concealed difficulties in
C, but if you write carefully and thoughtfully, you can create fast,
efficient programs.

@cindex C language and peripherals
@cindex Peripherals and C language

@item
With C, you can use every resource your computer offers.  C tries to link
closely with the local environment, providing facilities for gaining
access to common peripherals like disk drives and printers.  When new
peripherals are invented, the GNU community quickly provides the ability
to program them in C as well.  In fact, most of the GNU project is
written in C (as are many other operating systems).

@end itemize

For the reasons outlined above, C is the preeminent high-level language.
Clearly, no language can guarantee good programs, but C can provide a
framework in which it is easy to program well.

@node Questions for Chapter 1,  , Advantages of C, Introduction
@section Questions for Chapter 1

@enumerate

@item
Explain the distinction between high levels and low levels.

@item
What is a ``black box''?

@item
Name a few advantages to programming in the C language.

@end enumerate





@c CHAPTER 2
@node Using a compiler, The form of a C program, Introduction, Top
@chapter Using a compiler

@emph{How to use a compiler.  What can go wrong.}

@cindex Operating system
@cindex Shell, command
@cindex Command shell
@cindex GNU shell
@cindex Shell, GNU

@cindex Compiler

The @dfn{operating system} is the layer of software that drives the
hardware of a computer and provides the user with a comfortable work
environment.  Operating systems vary, but most have a @dfn{shell}, or
text interface.  You use the GNU shell every time you type in a command
that launches an email program or text editor under GNU.

In the following sections of this chapter, we will explore how to create
a C program from the GNU shell, and what might go wrong when you do.

@menu
* Basic ideas::                 
* The compiler::                
* File names::                  
* Errors::                      
* Questions for Chapter 2::     
@end menu

@node Basic ideas, The compiler, Using a compiler, Using a compiler
@section Basic ideas about C

@cindex Shell, command
@cindex Command shell
@cindex GNU shell
@cindex Shell, GNU

First a note about a programming language that is different from the C
programming language, the GNU shell.  When you enter commands in the GNU
shell, they are executed immediately.  Moreover, the shell is a
programming language, in that the commands you type are a program,
because you can also create a text file containing many shell commands.
When you run this file, the commands will be executed in sequence.

On the other hand, consider C.  While a shell command file can be
executed directly, a C program must be created in two stages:

@enumerate

@item
First, the program is written in the form of text files with a text
editor such as GNU Emacs.  This form of the program is called the
@dfn{source code}.  A computer cannot execute source code directly.

@cindex Compiler

@item
Second, the completed source code is processed with a @dfn{compiler} --- a
program that generates a new file containing a machine-language
translation of the source code.  This file is called an @dfn{executable
file}, or @dfn{executable}.  The executable file is said to have been
@dfn{compiled} from the source code.

@end enumerate

@cindex Executable file, running
@cindex Running an executable file

To run the compiled program, you must usually type the name of the
executable file preceded by a period and a slash, as in this example:

@smallexample
./myprogram
@end smallexample

@cindex @samp{./} (dot-slash) prefix in shell
@cindex Dot-slash (@samp{./}) prefix in shell

@noindent
The ``dot-slash'' prefix tells the GNU shell to look in the current
directory for the executable.  You usually do not need to type @samp{./}
in front of commands for programs that came with your GNU system, such
as @command{emacs}, because the computer already knows where to
look for the executables of those programs, which were placed in special
directories when your GNU system was installed.

@cindex Variable
@cindex Function

A C program is made up of, among other components, variables and functions.
A @dfn{variable} is a way to hold some data which may vary, hence the name.
For example, a variable might hold the number 17, and later the number 41.
Another variable might hold the word ``Sue''.

A @dfn{function} is a segment of text in the source code of a program
that tells the computer what to do.  Programming consists, in large
part, of writing functions.

@node The compiler, File names, Basic ideas, Using a compiler
@section The compiler

@cindex Compiler 
@cindex Compiler passes
@cindex Passes, compiler

When you compile a program, the compiler usually operates in an orderly
sequence of phases called @dfn{passes}.  The sequence happens
approximately like this:

@enumerate

@cindex Source code
@cindex Code, source
@cindex Pseudo-code

@item
First, the compiler reads the source code, perhaps generating an
intermediate code (such as @dfn{pseudo-code}) that simplifies the source
code for subsequent processing.

@cindex Object code file
@cindex Object file
@cindex File, object code
@cindex File, object
@cindex Object code
@cindex Code, object

@item
Next, the compiler converts the intermediate code (if there is any) or
the original source code into an @dfn{object code} file, which contains
machine language but is not yet executable.  The compiler builds a
separate object file for each source file.  These are only temporary and
are deleted by the compiler after compilation.

@cindex Linker

@item
Finally, the compiler runs a @dfn{linker}.  The linker merges the
newly-created object code with some standard, built-in
object code to produce an executable file that can stand alone.

@end enumerate

@cindex GCC
@pindex gcc
@cindex GNU C Compiler
@cindex GNU Compiler Collection
@cindex Compiler

@noindent
GNU environments use a simple command to invoke the C compiler:
@command{gcc}, which stands for ``GNU Compiler Collection''.  (It used to
stand for ``GNU C Compiler'', but now GCC can compile many more
languages than just C.) Thus, to compile a small program, you will
usually type something like the following command:

@smallexample
gcc @var{file_name}
@end smallexample

@pindex a.out

@noindent
On GNU systems, this results in the creation of an executable
program with the default name @file{a.out}.  To tell the compiler
you would like the executable program to be called something else,
use the @option{-o} option for setting the name of the object code:

@smallexample
gcc -o @var{program_name} @var{file_name}
@end smallexample

@noindent
For example, to create a program called @file{myprog} from a file
called @file{myprog.c}, write

@smallexample
gcc -o myprog myprog.c
@end smallexample

@noindent
To launch the resulting program @file{myprog} from the same directory,
type

@smallexample
./myprog
@end smallexample


@node File names, Errors, The compiler, Using a compiler
@section File names

@cindex File name conventions
@cindex Conventions, file name

GCC uses the following file name conventions:

@c !!!  Bob notes that you can make the left hand column considerably smaller.
@multitable @columnfractions .5 .5

@pindex .c @r{file suffix}
@pindex .o @r{file suffix}
@pindex .h @r{file suffix}
@pindex .a @r{file suffix}
@pindex .so @r{file suffix}

@cindex File, source code
@cindex Source code file
@cindex File, object
@cindex Object file
@cindex File, executable
@cindex Executable file
@cindex File, header
@cindex Header file
@cindex File, library
@cindex Library file

@item Source code file
@tab @var{program_name}@t{.c}

@item Object file
@tab @var{program_name}@t{.o}

@item Executable file
@tab @var{program_name} (no ending)

@item Header file
@tab @var{name}@t{.h}

@item Library file
@tab @t{lib}@var{name}@t{.a} or @t{lib}@var{name}@t{.so}

@end multitable

@noindent
The file name endings, or @dfn{file extensions}, identify the contents of
files to the compiler.  For example, the @samp{.c} suffix
tells the compiler that the file contains C source code, and the other
letters indicate other kinds of files in a similar way.




@node Errors, Questions for Chapter 2, File names, Using a compiler
@section Errors

@cindex Errors
@cindex Bugs

Errors are mistakes that programmers make in their code.  There are two
main kinds of errors.

@itemize @bullet

@cindex Compile-time errors
@cindex Errors, compile-time
@cindex Compile-time bugs
@cindex Bugs, compile-time
@cindex Syntax errors
@cindex Errors, syntax
@cindex Type errors
@cindex Errors, type

@item
@dfn{Compile-time errors} are errors caught by the compiler.
They can be @dfn{syntax errors}, such as typing @kbd{fro}
instead of @kbd{for}, or they can be errors caused by the incorrect
construction of your program.  For example, you might tell the compiler
that a certain variable is an integer, then attempt to give it a
non-integer value such as 5.23.  (@xref{Type errors}.)

The compiler lists all compile-time errors at once, with the line number
at which each error occurred in the source code, and a message that
explains what went wrong.

For example, suppose that, in your file @file{eg.c} you write

@smallexample
y = sin (x];
@end smallexample

@noindent
instead of

@smallexample
y = sin (x);
@end smallexample

@cindex Assignment
@cindex Assignment, example of
@findex = (@r{equals sign})
@cindex Equals sign (@code{=})

@noindent
(By the way, this is an example of @dfn{assignment}.  With the equals
sign (@samp{=}), you are @dfn{assigning} the variable @code{y} (causing
the variable @code{y} to contain) the sine of the variable
@code{x}.  This is somewhat different from the way equals signs work in
mathematics.  In math, an equals sign indicates that the numbers and
variables on either side of it are @emph{already} equal; in C, an equals
sign @emph{makes} things equal.  Sometimes it is useful to think of
the equals sign as an abbreviation for the phrase ``becomes the value of''.)

Ignore the syntactic details of the statements above for now, except to
note that closing the @code{(x)} with a square bracket instead of a
parenthesis is an error in C.  Upon compilation, you will see something
like this error message:

@error{}

@smallexample
eg.c: In function `main':
eg.c:8: parse error before `]'
@end smallexample

@noindent
(If you compile the program within Emacs, you can jump directly to the
error.  We will discuss this feature later.  @xref{Debugging}, for more
information.)

@cindex Compile-time errors
@cindex Errors, compile-time
@cindex Error cascade

A program with compile-time errors will cause the compiler to halt, and
will not produce an executable.  However, the compiler will check the
syntax up to the last line of your source code before stopping, and it
is common for a single real error, even something as simple as a missing
parenthesis, to result in a huge and confusing list of nonexistent
``errors'' from the compiler.  This can be shocking and disheartening to
novices, but you'll get used to it with experience.  (We will provide an
example later in the book.  @xref{Debugging}.)

As a rule, the best way to approach this kind of problem is to look for
the @emph{first} error, fix that, and then recompile.  You will soon
come to recognize when subsequent error messages are due to independent
problems and when they are due to a cascade.

@cindex Run-time errors
@cindex Errors, run-time 

@item
@dfn{Run-time errors} are errors that occur in a compiled and running
program, sometimes long after it has been compiled.

One kind of run-time error happens when you write a running program that
does not do what you intend.  For example, you intend to send a letter
to all drivers whose licenses will expire in June, but instead, you send a
letter to all drivers whose licenses will @emph{ever} expire.

@cindex Crash, computer
@cindex Computer crash
@cindex Stability of GNU system
@cindex GNU system, stability of

Another kind of run-time error can cause your program to @dfn{crash}, or
quit abruptly.  For example, you may tell the computer to examine a part
of its memory that doesn't exist, or to divide some variable by
zero.  Fortunately, the GNU environment is extremely stable, and very
little will occur other than an error message in your terminal window
when you crash a program you are writing under GNU.

@end itemize

@cindex Executable file
@cindex File, executable

If the compilation of a program is successful, then a new executable
file is created.

When a programmer wishes to make alterations and corrections to a C
program, these must be made in the source code, using a text editor;
after making the changes, the programmer must recompile the program, or
its salient parts.


@menu
* Typographical errors::        
* Type errors::                 
@end menu

@node Typographical errors, Type errors, Errors, Errors
@subsection Typographical errors

@cindex Typographical errors
@cindex Errors, typographical
@cindex Case-sensitivity of C language
@cindex C language, case-sensitivity of

The compiler can sometimes fail for very simple reasons, such as
typographical errors, including the misuse of upper- and lower-case
characters.  The C language is @dfn{case-sensitive}.  Unlike languages
such as Pascal and some versions of BASIC, C distinguishes between
upper- and lower-case letters, such as @samp{A} and @samp{a}.  If a
letter is typed in the wrong case in a critical place in the source
code, compilation will fail.  This is a potential source of errors that
are difficult to find.

@node Type errors,  , Typographical errors, Errors
@subsection Type errors

@cindex Variable types
@cindex Types, variable
@cindex Type errors
@cindex Errors, type
@cindex Defining your own types
@cindex Types, defining your own

C supports a variety of @dfn{variable types} (different kinds of
variables for different kinds of data), such as @code{integer} for
integer numbers, and @code{float} for numbers with fractional parts.
You can even define your own types, such as @code{total} for a sum, or
@code{surname} for someone's last name.  You can also convert a variable
of one type into other types.  (This is called @dfn{type coercion}.)
Consequently, the type of a variable is of great importance to the
compiler.

@cindex Variable declaration
@cindex Declaration, variable

C requires us to list the names and types of all variables that will be
used in a program, and provide information about where they are going to
be used.  This is called @dfn{declaring} variables.  If you fail to
declare a variable, or use it as if it were a different type from the
type it is declared to be, for example, by assigning a non-integer value
to an integer variable, you will receive a compile-time error.

@xref{Variables and declarations}, for more information on variable
declarations.  @xref{The form of a C program}, for some simple examples of
variable declarations.




@node Questions for Chapter 2,  , Errors, Using a compiler
@section Questions for Chapter 2

@enumerate
@item
What is a compiler?

@item
How does one run a C program?

@item
How does one usually compile a C program?

@item
Are upper and lower case equivalent in C?

@item
What the two main kinds of error that can occur in a program?

@item
If you had some C source code that you wished to call
``accounts'', under what name would you save it?

@item
What would be the name of the executable file for
the program in the last question?

@item
How would you run this program?

@end enumerate



@c CHAPTER 3
@node The form of a C program, Functions, Using a compiler, Top
@chapter The form of a C program

@emph{What goes into a C program?  What does one look like?}

@cindex Function, as building block
@cindex Building block, function as
The basic building block of a C program is the @dfn{function}.  Every C
program is a collection of one or more functions.  Functions are made of
variable declarations and @dfn{statements}, or complex commands, and are
surrounded by curly brackets (@samp{@{} and @samp{@}}).

@cindex main @r{function}
@cindex Function, @code{main}
@cindex C program, simplest
@cindex Simplest C program
One and only one of the functions in a program must have the name
@code{main}.  This function is always the starting point of a C program,
so the simplest C program is a single function definition:

@smallexample
main ()
@{
@}
@end smallexample

@noindent
The parentheses @samp{()} that follow the name of the function must be
included.  This is how C distinguishes functions from ordinary variables.

The function @code{main} does not need to be at the top of a program, so
a C program does not necessarily start at line 1, but wherever the
function called @code{main} is located.  The function @code{main} cannot
be @dfn{called}, or started, by any other function in the program.  Only
the operating system can call @code{main}; this is how a C program is
started.

The next most simple C program is perhaps a program that starts, calls a
function that does nothing, and then ends.

@smallexample
/******************************************************/
/*                                                    */
/* Program : do nothing                               */
/*                                                    */
/******************************************************/

main()                          /* Main program */
@{
  do_nothing();
@}

/******************************************************/

do_nothing()                 /* Function called */
@{
@}
@end smallexample

@cindex Comments
@cindex Comment characters
@noindent
(Any text sandwiched between @samp{/*} and @samp{*/} in C code is a
comment for other humans to read.  See the section on comments below for
more information.)

@noindent
There are several things to notice about this program.

First, this program consists of two functions, one of which calls the
other.

Second, the function @code{do_nothing} is called by simply typing the
main part of its name followed by @samp{()} parentheses and a
semicolon.

Third, the semicolon is vital; every simple statement in C ends with
one.  This is a signal to the compiler that the end of a statement has
been reached and that anything that follows is part of another
statement.  This signal helps the compiler diagnose errors.

Fourth, the curly bracket characters @samp{@{} and @samp{@}} outline a
@dfn{block} of statements.  When this program meets the closing @samp{@}}
of the second function's block, it transfers control back to
@samp{main}, where it meets another @samp{@}}, and the program ends.

@menu
* A word about style::          
* Comments::                    
* Example comment::             
* Questions for Chapter 3::     
@end menu

@node A word about style, Comments, The form of a C program, The form of a C program
@section A word about style

@cindex Style
@cindex C, ANSI Standard
@cindex ANSI Standard C

The code examples above are simple, but they illustrate the @dfn{control
flow} of a C program, or the order in which its statements are executed.
You should note that these programs are written in ``old-fashioned'' C,
as the language existed before ANSI Standard C --- the version in which
most C programs are now written.  The above programs are also missing
several key elements that most C programs have, such as header files and
function prototypes.  Finally, they do not show good style; if you wish
to submit programs you write to the Free Software Foundation, you should
consult its advice on how best to use the C language.

You may wonder why we chose old-style C for these first few examples,
even though people proverbially learn best what they learn first.  We
did so because pre-ANSI C is considerably simpler than the present form,
and also because as you develop as a C programmer, you will probably run
across some old C code that you will want to read.

You may also wonder why a savvy programmer would want to follow the ANSI
Standard, which was drafted by committee, or even the GNU guidelines.
Isn't programming free software all about freedom?  Yes, but following
the ANSI Standard ensures that your code can be easily compiled on many
other computer platforms, and the GNU guidelines ensure that your code
can be read by other programmers.  (We will introduce good C style in
our examples soon.  Meanwhile, you can examine the GNU guidelines later
in the book.  @xref{Style}.)


@menu
* Comments::
* Example comment::
* Questions for Chapter 3::
@end menu

@node Comments, Example comment, A word about style, The form of a C program
@section Comments

@sp 1
@emph{Annotating programs.}
@sp 1

@cindex Comments
@cindex Annotating programs
@cindex Programs, annotating

Comments are a way of inserting remarks and reminders into code without
affecting its behavior.  Since comments are only read by other humans,
you can put anything you wish to in a comment, but it is better to be
informative than humorous.

The compiler ignores comments, treating them as though they were
@dfn{whitespace} (blank characters, such as spaces, tabs, or carriage
returns), and they are consequently ignored.  During compilation,
comments are simply stripped out of the code, so programs can contain
any number of comments without losing speed.

Because a comment is treated as whitespace, it can be placed anywhere
whitespace is valid, even in the middle of a statement.  (Such a practice
can make your code difficult to read, however.)

@cindex Comment characters

Any text sandwiched between @samp{/*} and @samp{*/} in C code is a
comment.  Here is an example of a C comment:

@smallexample
/* ...... comment ......*/
@end smallexample

Comments do not necessarily terminate at the end of a line, only with
the characters @samp{*/}.  If you forget to close a comment with the
characters @samp{*/}, the compiler will display an @samp{unterminated
comment} error when you try to compile your code.

@cindex Comments, example

@node Example comment, Questions for Chapter 3, Comments, The form of a C program
@section Example 1

@smallexample
#include <stdio.h>      /* header file */

main ()   /* Trivial program */

@{

/* This little line has no effect */
/* This little line has none */
/* This little line went all the way down
   to the next line,
   And so on...
   And so on...
   And so on... */

  do_little();

  printf ("Function 'main' completing.\n");
@}

/**********************************************/

/* A bar like the one above can be used to */
/* separate functions visibly in a program */


do_little ()
@{

/* This function does little. */

  printf ("Function 'do_little' completing.\n");
@}
@end smallexample

@cindex C, ANSI Standard
@cindex ANSI Standard C
@cindex GNU style guidelines
@cindex Style
Again, this example is old-fashioned C, and in mediocre style.  To make
it more compliant with the ANSI Standard and GNU guidelines, we would
declare the variable type each function returns (@code{int} for
@code{main}, which also requires an @code{exit} or @code{return}
statement), and we would create function prototypes at the beginning of
the file.  (@xref{Functions}.)



@menu
* Questions for Chapter 3::
@end menu



@node Questions for Chapter 3,  , Example comment, The form of a C program
@section Questions for Chapter 3

@enumerate

@item
What is a block?

@item
Does a C program start at the beginning?  Where is the beginning?

@item
What happens when a program comes to a @samp{@}} character?  What does this
character signify?

@item
What vital piece of punctuation goes at the end of every simple C statement?

@item
What happens if a comment is not ended?  That is if the programmer
types @samp{/*} .. to start but forgets the ..@samp{*/} to close?

@end enumerate







@c CHAPTER 4
@node Functions, Variables and declarations, The form of a C program, Top
@chapter Functions

@emph{Solving problems and getting results.}

@cindex Functions

A function is a section of program code that performs a particular
task.  Making functions is a way of isolating one section of code from
other independent sections.  Functions allow a programmer to separate
code by its purpose, and make a section of code @dfn{reusable} --- that
is, make it so the section can be called in many different contexts.

Functions should be written in the following form:

@smallexample
@var{type} @var{function_name} (@var{type} @var{parameter1_name}, @var{type} @var{parameter2_name}, @dots{})

@{
  @var{variable declarations}

  @var{statements}
  ...
  ...
  ...
@}
@end smallexample


@cindex C, ANSI Standard
@cindex ANSI Standard C

You may notice when reading the examples in this chapter that this
format is somewhat different from the one we have used so far.  This
format conforms to the ANSI Standard and is better C.  The other way is
old-fashioned C, although GCC will still compile it.  Nevertheless, GCC is not
guaranteed to do so in the future, and we will use ANSI Standard C in
this text from now on.

@cindex Parameters
@cindex Declarations, variable
@cindex Variable declarations
@cindex Statements

As shown above, a function can have a number of @dfn{parameters}, or
pieces of information from outside, and the function's @dfn{body}
consists of a number of declarations and statements, enclosed by curly
brackets: @samp{@{@dots{}@}}.



@menu
* Function names::              
* Function examples::           
* Functions with values::       
* Function prototyping::        
* The exit function::           
* Questions for Chapter 4::     
@end menu

@node Function names, Function examples, Functions, Functions
@section Function names

@cindex Functions, names of
@cindex Function names

Every function has a name by which it is known to the rest of the
program.  The name of a function in C can be anything from a single letter to a
long word.  The ANSI Standard, however, only guarantees that C will be able to
distinguish the first 31 letters of @dfn{identifiers}, or function and
variable names.  (Identifiers are therefore said to have 31
@dfn{significant characters}.) In some cases, identifiers may have as
few as six significant characters, to stay compatible with older
linkers, but this part of the ANSI Standard is becoming obsolete.

@cindex Function names, characters available for
A function name must begin with an alphabetic letter or the underscore
@samp{_} character, but the other characters in the name can be chosen
from the following groups:

@itemize @bullet
@item
Any lower-case letter from @samp{a} to @samp{z}
@item
Any upper-case letter from @samp{A} to @samp{Z}
@item
Any digit from @samp{0} to @samp{9}
@item
The underscore character @samp{_}
@end itemize

Note that with GCC, you can also use dollar signs (@samp{$}) in
identifiers.  This is one of GCC's extensions to the C language, and is
not part of the ANSI standard.  It also may not be supported under GCC on
certain hardware platforms.



@node Function examples, Functions with values, Function names, Functions
@section Function examples

@cindex Function, example
@cindex Example function
@findex printf
Here is an example of a function that adds two integers and prints the
sum with C's ``print formatted'' function named @code{printf}, using the
characters @samp{%d} to specify integer output.

@smallexample
void add_two_numbers (int a, int b)               /* Add a and b */
@{
  int c;

  c = a + b;
  printf ("%d\n", c);
@}
@end smallexample

@noindent
The variables @code{a} and @code{b} are parameters passed in from
outside the function.  The code defines @code{a}, @code{b}, and @code{c}
to be of type @code{int}, or integer.

The function above is not much use standing alone.  Here is a
@code{main} function that calls the @code{add_two_numbers} function:

@smallexample
int main()
@{
  int var1, var2;

  var1 = 1;
  var2 = 53;

  add_two_numbers (var1, var2);
  add_two_numbers (1, 2);

  exit(0);
@}
@end smallexample

@noindent
When these functions are incorporated into a C program, together they
print the number 54, then they print the number 3, and then they stop.




@node Functions with values, Function prototyping, Function examples, Functions
@section Functions with values

@cindex Functions, with values
@cindex Function values
@cindex Returning values from functions
@cindex Functions, return values
@cindex Functions, returning values from
In mathematics, a function takes one or more values and calculates, or
@dfn{returns}, another value.  In C, some functions return values and
others do not; whether a function you write does or does not will depend
on what you want the function to do.  For example, a function that
calculates a value should probably return that value, while a function
that merely prints something out may not need to.

The @code{add_two_numbers} function above did not return a value.  We
will now examine a function that does.

Here is an example of calling a function that returns a value:

@smallexample
bill = calculate_bill (data1, data2, data3);
@end smallexample

@noindent
When this statement is executed, control is passed to the function
@code{calculate_bill}, that function executes, and then it returns control
and some value to the original statement.  The value returned is assigned
to @code{bill}, and the program continues.

In C, returning a value from a function is a simple matter.  Consider the
function @code{calculate_bill} as it might be written in a program that
contains the statement above:

@smallexample
int calculate_bill (int a, int b, int c)
@{
  int total;

  total = a + b + c;
  return total;
@}
@end smallexample

@noindent
As soon as the @code{return} statement is met, @code{calculate_bill}
stops executing and returns the value @code{total}.

A function that returns a value must have a @code{return} statement.
Forgetting it can ruin a program.  For instance if @code{calculate_bill}
had read as follows, then the variable @code{bill} would have had
no meaningful value assigned to it, and you might have received a
warning from the compiler as well.  (The word @code{void} below
indicates that the function does not return a value.  In ANSI C, you must
place it before the name of any such function.)

@smallexample
void calculate_bill (int a, int b, int c)
@{
  int total;

  total = a + b + c;
@}
@end smallexample

On the other hand, you do not need to actually use a value when a
function returns one.  For example, the C input/output functions
@code{printf} and @code{scanf} return values, but the values are rarely
used.  @xref{Input, output, files, and devices}, for more information on
these functions.

If we use the first version of the @code{calculate_bill} function (the
one that contains the line @code{return total;}), the value of the
function can simply be discarded.  (Of course, the resulting program is
not very useful, since it never displays a value to the user!)

@smallexample
int main()
@{
  calculate_bill (1, 2, 3);
  exit (0);
@}
@end smallexample



@node  Function prototyping, The exit function, Functions with values, Functions
@section Function prototyping

@cindex Functions, prototyping
@cindex Prototyping function
@cindex Function prototypes

Functions do not have to return integer values, as in the above
examples, but can return almost any type of value, including floating
point and character values.  (@xref{Variables and declarations}, for
more information on variable types.)

@cindex Function declarations
@cindex Functions, declaring
@cindex Declaring functions

A function must be declared to return a certain variable type (such as
an integer), just as variables must be.  (@xref{Variables and
declarations}, for more information about variable types.)  To write
code in good C style, you should declare what type of value a function
returns (and what type of parameters it accepts) in two places:

@enumerate

@item
At the beginning of the program, in global scope.  (@xref{Scope}.)

@item
In the definition of the function itself.

@end enumerate

Function declarations at the beginning of a program are called @dfn{prototypes}.
Here is an example of a program in which prototypes are used:

@smallexample
#include <stdio.h>

void print_stuff (int foo, int bar);
int calc_value (int bas, int quux);


void print_stuff (int foo, int bar)
@{
  int var_to_print;

  var_to_print = calc_value (foo, bar);
  printf ("var_to_print = %d\n", var_to_print);
@}


int calc_value (int bas, int quux)
@{
  return bas * quux;
@}


int main()
@{
  print_stuff (23, 5);
  exit (0);
@}
@end smallexample

@noindent
The above program will print the text @samp{var_to_print = 115} and then
quit.

@cindex Function prototypes, reasons for using
Prototypes may seem to be a nuisance, but they overcome a problem
intrinsic to compilers, which is that they compile functions as they
come upon them.  Without function prototypes, you usually cannot write
code that calls a function before the function itself is defined in the
program.  If you place prototypes for your functions in a header file,
however, you can call the functions from any source code file that
includes the header.  This is one reason C is considered to be such a
flexible programming language.

Some compilers avoid the use of prototypes by making a first pass just
to see what functions are there, and a second pass to do the work, but
this takes about twice as long.  Programmers already hate the time
compilers take, and do not want to use compilers that make unnecessary
passes on their source code, making prototypes a necessity.  Also,
prototypes enable the C compiler to do more rigorous error checking, and
that saves an enormous amount of time and grief.



@node The exit function, Questions for Chapter 4, Function prototyping, Functions
@section The @code{exit} function

@findex exit @r{command}
@findex return @r{command}

GNU coding standards specify that you should always use @code{exit} (or
@code{return}) within your @code{main} function.  (@xref{Style}.)

You can use the @code{exit} function to terminate a program at any
point, no matter how many function calls have been made.  Before it
terminates the program, it calls a number of other functions that
perform tidy-up duties such as closing open files.

@findex exit @r{command}
@cindex Return codes
@code{exit} is called with a @dfn{return code}, like this:

@smallexample
exit(0);
@end smallexample

@noindent
In the example above, the return code is @code{0}.  Any program that
calls your program can read the return code from your program.  The
return code is like a return value from another function that is not
@code{main}; in fact, most of the time you can use the @code{return}
command within your @code{main}, instead of @code{exit}.

Conventionally, a return code of @code{0} specifies that your program
has ended normally and all is well.  (You can remember this as ``zero
errors'', although for technical reasons, you cannot use the number of
errors your program found as the return code.  @xref{Style}.)  A return
code other than @code{0} indicates that some sort of error has occurred.
If your code terminates when it encounters an error, use @code{exit},
and specify a non-zero return code.



@node Questions for Chapter 4,  , The exit function, Functions
@section Questions for Chapter 4

@enumerate
@item
Write a function that takes two values @var{a} and @var{b}, then returns
the value of @var{a} * @var{b} (that is, @code{a} times @code{b}.)

@item
Is there anything wrong with a function that returns no value?

@item
What happens if a function returns a value but you do not assign that
value to anything?

@item
What happens if a variable is assigned the result of a function, but the
function does not return a value?

@item
How can you make a program terminate, anywhere in the program?

@end enumerate







@c CHAPTER 5
@node Variables and declarations, Scope, Functions, Top
@chapter Variables and declarations

@emph{Storing data.  Discriminating types.  Declaring data.}

@cindex Variables
@cindex Variable names, characters available for

Variable names in C follow the same rules as function names, as far as
what characters they can contain.  (@xref{Function names}.)  Variables
work differently from functions, however.  Every variable in C has a
@dfn{data type}, or @dfn{type}, that conveys to the the compiler what
sort of data will be stored in it.  Functions in C are sometimes said to
have types, but a function's type is actually the data type of the
variable it returns.

@cindex Declaring variables
@cindex Variables, declaring
In some older computer languages like BASIC, and even some newer ones
like Perl, you can tell what type a variable is because its name begins
or ends with a special character.  For example, in many versions of
BASIC, all integer variable names end with a percent sign (@samp{%}) ---
for example, @samp{YEAR%}.  No such convention exists in C.  Instead, we
declare variables, or tell the compiler that they are of a certain type,
before they are used.  This feature of C has the following advantages
(among others):

@itemize @bullet

@item It gives a compiler precise information about the
amount of memory that will have to be allotted to a variable when a
program is run, and what sort of arithmetic will have to be used with it
(e.g. integer, floating point, or none at all).

@item It provides the compiler with a list of the variables
so that it can catch errors in the code, such as assigning a string to
an integer variable.

@end itemize

There are a lot of variable types in C.  In fact, you can define your
own, but there are some basic types ready for use.  We will discuss them
in the following sections.


@menu
* Integer variables::           
* Declarations::                
* Initialization::              
* The cast operator::           
* Storage classes::             
* Questions for Chapter 5::     
@end menu

@node Integer variables, Declarations, Variables and declarations, Variables and declarations
@section Integer variables

@cindex Variables, integer
@cindex Integer variables

C has five kinds of @dfn{integer}.  An integer is a whole number (a
number without a fractional part).  In C, there are a limited number of
integers possible; how many depends on the type of integer.  In
arithmetic, you can have as large a number as you like, but C integer
types always have a largest (and smallest) possible number.

@tindex char @r{type}
@tindex short @r{type}
@tindex int @r{type}
@tindex long @r{type}
@tindex long long @r{type}
@itemize @bullet

@item @code{char}:
A single byte, usually one ASCII character.  (See the section on the
@code{char} type below.)

@item @code{short}:
A short integer (16 bits long on most GNU systems).  Also called
@code{short int}.  Rarely used.

@item @code{int}:
A standard integer (32 bits long on most GNU systems).

@item @code{long}:
A long integer (32 bits long on most GNU systems, the same as
@code{int}).  Also called @code{long int}.

@item @code{long long}:
A long long integer (64 bits long on most GNU systems).  Also called
@code{long long int}.

@end itemize

@cindex Operating systems, 64-bit
@noindent
64-bit operating systems are now appearing in which long integers are 64
bits long.  With GCC, long integers are normally 32 bits long and long
long integers are 64 bits long, but it varies with the computer hardware
and implementation of GCC, so check your system's documentation.

@cindex Integer variables, sizes of
@cindex Variables, integer, sizes of

These integer types differ in the size of the integer they can hold and
the amount of storage required for them.  The sizes of these variables
depend on the hardware and operating system of the computer.  On a
typical 32-bit GNU system, the sizes of the integer types are as
follows.



@tindex char @r{type}
@tindex unsigned char @r{type}
@tindex short @r{type}
@tindex unsigned short @r{type}
@tindex int @r{type}
@tindex unsigned int @r{type}
@tindex long @r{type}
@tindex unsigned long @r{type}
@tindex long long @r{type}
@tindex unsigned long long @r{type}
@multitable @columnfractions .25 .25 .50
@item @strong{Type} @tab @strong{Bits} @tab @strong{Possible Values}

@item @code{char} @tab 8 @tab -127 to 127
@item @code{unsigned char} @tab 8 @tab 0 to 255

@item @tab @tab
@item @code{short} @tab 16 @tab -32,767 to 32,767
@item @code{unsigned short} @tab 16 @tab 0 to 65,535

@item @tab @tab
@item @code{int} @tab 32 @tab -2,147,483,647 to 2,147,483,647
@item @code{unsigned int} @tab 32 @tab 0 to 4,294,967,295

@item @tab @tab
@item @code{long} @tab 32 @tab -2,147,483,647 to 2,147,483,647
@item @code{unsigned long} @tab 32 @tab 0 to 4,294,967,295

@item @tab @tab
@item @code{long long} @tab 64 @tab -9,223,372,036,854,775,807
to 9,223,372,036,854,775,807
@item @code{unsigned long long} @tab 64 @tab 0 to 18,446,744,073,709,551,615

@end multitable

On some computers, the lowest possible value may be 1 less than shown
here; for example, the smallest possible @code{short} may be -32,768
rather than -32,767.

The word @code{unsigned}, when placed in front of integer types, means
that only positive or zero values can be used in that variable (i.e. it
cannot have a minus sign).  The advantage is that larger numbers can then
be stored in the same variable.  The ANSI standard also allows the word
@code{signed} to be placed before an integer, to indicate the opposite
of @code{unsigned}.



@menu
* The char type::               
* Floating point variables::    
@end menu

@node The char type, Floating point variables, Integer variables, Integer variables
@subsection The @code{char} type

@tindex char @r{type}
@tindex unsigned char @r{type}

@code{char} is a special integer type designed for storing single
characters.  The integer value of a @code{char} corresponds to an ASCII
character.  For example, a value of 65 corresponds to the letter
@samp{A}, 66 corresponds to @samp{B}, 67 to @samp{C}, and so on.

As in the table above, @code{unsigned char} permits values from 0 to
255, and @code{signed char} permits values from -127 (or -128) to 127.
The @code{char} type is signed by default on some computers, but
unsigned on others.  (@xref{Character conversion table}.  @xref{Special
characters}.)

@code{char} is used only within arrays; variables meant to hold one
character should be declared @code{int}.  (@xref{Strings}, for more
information on character arrays.  @xref{Cast operator demo}, for an
example of how to use an integer variable to hold a character value.)



@node Floating point variables,  , The char type, Integer variables
@subsection Floating point variables

@cindex Floating point variables
@cindex Variables, floating point
@cindex Floating point numbers
@cindex Numbers, floating point

@tindex float @r{type}
@tindex double @r{type}

@dfn{Floating point numbers} are numbers with a decimal point.  There
are different sizes of floating point numbers in C.  The @code{float}
type can contain large floating point numbers with a small degree of
precision, but the double-precision @code{double} type can hold even
larger numbers with a higher degree of precision.  (@dfn{Precision} is
simply the number of decimal places to which a number can be computed
with accuracy.  If a number can be computed to five decimal places, it is
said to have five @dfn{significant digits}.)

@tindex double @r{type}
@tindex long float @r{type}
All floating point mathematical functions built into C require
@code{double} or @code{long float} arguments (@code{long float}
variables are generally the same as @code{double} variables on GNU
systems), so it is common to use @code{float} only for storage of small
floating point numbers, and to use @code{double} everywhere else.

Here are the floating point variable types available in C:

@tindex float @r{type}
@tindex long float @r{type}
@tindex double @r{type}
@tindex long double @r{type}
@itemize @bullet

@item @code{float}:
A single-precision floating point number, with at least 6 significant
decimal digits.

@item @code{double}:
A double-precision floating point number.  Usually the same as @code{long
float} on GNU systems.  Has at least 10 significant decimal digits.

@item @code{long double}:
Usually the same as @code{double} on GNU systems, but may be a 128-bit
number in some cases.

@end itemize

On a typical 32-bit GNU system, the sizes of the different floating
point types are as follows.

@tindex float @r{type}
@tindex long float @r{type}
@tindex double @r{type}
@tindex long double @r{type}
@multitable @columnfractions .25 .25 .50
@item @strong{Type} @tab @strong{Bits} @tab @strong{Possible values (approx.)}

@item @code{float} @tab 32 @tab 1e-38 to 1e+38

@item @code{double} @tab 64 @tab 2e-308 to 1e+308

@item @code{long double} @tab 64 @tab 2e-308 to 1e+308

@end multitable

@sp 2

You may find the figures in the right-hand column confusing.  They use a
form of shorthand for large numbers.  For example, the number 5e2 means
@math{5 * 10^2}, or 500. 5e-2 means @math{5 * 10^-2} (@math{5/100}, or
@math{1/20}).  You can see, therefore, that the @code{float},
@code{double}, and @code{long double} types can contain some very large
and very small numbers indeed.  (When you work with large and small
numbers in C, you will use this notation in your code.)



@node Declarations, Initialization, Integer variables, Variables and declarations
@section Declarations

@cindex Declaring variables
@cindex Variables, declaring

To declare a variable, write the type followed by a list of variables of
that type:

@smallexample
@var{type_name} @var{variable_name_1}, @dots{}, @var{variable_name_n};
@end smallexample

@noindent
For example:

@smallexample
int last_year, cur_year;
long double earth_mass, mars_mass, venus_mass;
unsigned int num_pets;

long city_pop, state_pop;
state_pop = city_pop = 5000000;

short moon_landing = 1969;

float temp1, temp2, temp3;
temp1 = 98.6;
temp2 = 98.7;
temp3 = 98.5;

double bignum, smallnum;
bignum = 2.36e208;
smallnum = 3.2e-300;
@end smallexample

Always declare your variables.  A compiler will catch a missing
declaration every time and terminate compilation, complaining
bitterly.  (You will often see a host of error messages, one for each use
of the undeclared variable.  @xref{Debugging}.)


@node Initialization, The cast operator, Declarations, Variables and declarations
@section Initialization

@cindex Variables, initializing
@cindex Initializing variables

Assigning a variable its first value is called @dfn{initializing} the
variable.  When you declare a variable in C, you can also initialize it
at the same time.  This is no more efficient in terms of a running
program than doing it in two stages, but sometimes creates tidier and
more compact code.  Consider the following:

@smallexample
int initial_year;
float percent_complete;

initial_year = 1969;
percent_complete = 89.5;
@end smallexample

@noindent
The code above is equivalent to the code below, but the code
below is more compact.

@smallexample
int initial_year = 1969;
float percent_complete = 89.5;
@end smallexample

@noindent
You can always write declarations and initializers this way, but you may
not always want to.  (@xref{Style}.)



@node The cast operator, Storage classes, Initialization, Variables and declarations
@section The cast operator

@findex cast @r{operator}
@cindex Casting types
@cindex Types, casting

An @dfn{operator} is a symbol or string of C characters used as a
function.  One very valuable operator in C is the @dfn{cast operator},
which converts one type into another.  Its general form is as follows:

@smallexample
(@var{type}) @var{variable}
@end smallexample

For example, floating point and integer types can be interconverted:

@smallexample
float exact_length;
int rough_length;

exact_length = 3.37;
rough_length = (int) exact_length;
@end smallexample

@noindent
In the example above, the cast operator rounds the number down when
converting it from a float to an integer, because an integer number
cannot represent the fractional part after the decimal point.  Note that
C always @dfn{truncates}, or rounds down, a number when converting it to
an integer.  For example, both 3.1 and 3.9 are truncated to 3 when C is
converting them to integer values.

The cast operator works the other way around, too:

@smallexample
float exact_length;
int rough_length;

rough_length = 12;
exact_length = (float) rough_length;
@end smallexample

@noindent
In converting large integers to floating point numbers, you
may lose some precision, since the @code{float} type guarantees only 6
significant digits, and the @code{double} type guarantees only 10.

It does not always make sense to convert types.  (@xref{Data
structures}, for examples of types that do not convert to other types
well.)


@menu
* Cast operator demo::          
@end menu


@node Cast operator demo,  , The cast operator, The cast operator
@subsection Cast operator demo

@findex cast @r{operator}
@cindex Casting types, example
@cindex Types, casting, example

The following is an example of how to use the cast operator in C
code.  It also shows how to use an integer variable to store a character
value.



@smallexample
/***************************************************/
/*                                                 */
/* Demo of Cast operator                           */
/*                                                 */
/***************************************************/

#include <stdio.h>

int main()               /* Use int float and int */
@{
  float my_float;
  int my_int;
  int my_ch;

  my_float = 75.345;
  my_int = (int) my_float;
  my_ch = (int) my_float;
  printf ("Convert from float my_float=%f to my_int=%d and my_ch=%c\n",
    my_float, my_int, my_ch);

  my_int = 69;
  my_float = (float) my_int;
  my_ch = my_int;
  printf ("Convert from int my_int=%d to my_float=%f and my_ch=%c\n",
    my_int, my_float, my_ch);

  my_ch = '*';
  my_int = my_ch;
  my_float = (float) my_ch;
  printf ("Convert from int my_ch=%c to my_int=%d and my_float=%f\n",
    my_ch, my_int, my_float);

  exit(0);
@}
@end smallexample

@noindent
Here is the sort of output you should expect (floating point values may
differ slightly):

@smallexample
Convert from float my_float=75.345001 to my_int=75 and my_ch=K
Convert from int my_int=69 to my_float=69.000000 and my_ch=E
Convert from int my_ch=* to my_int=42 and my_float=42.000000
@end smallexample






@node Storage classes, Questions for Chapter 5, The cast operator, Variables and declarations
@section Storage classes

@cindex Storage classes
@cindex Classes, storage

There are a few variable declaration keywords commonly used in C that do
not specify variable types, but a related concept called @dfn{storage
classes}.  Two common examples of storage class specifiers are the
keywords @code{extern} and @code{static}.

@menu
* External variables::          
* Static variables::            
* Other storage classes::       
@end menu

@node External variables, Static variables, Storage classes, Storage classes
@subsection External variables

@cindex Variables, external
@cindex External variables
@findex extern @r{storage class specifier}

Sometimes the source code for a C program is contained in more than one
text file.  If this is the case, then it may be necessary to use
variables that are defined in another file.  You can use a global
variable in files other than the one in which it is defined by
redeclaring it, prefixed by the @code{extern} specifier, in the other files.


@smallexample
@emph{File main.c}                  @emph{File secondary.c}

                          #include <stdio.h>
                          int my_var;
int main()
@{
  extern int my_var;      void print_value()
                          @{
  my_var = 500;             printf("my_var = %d\n", my_var);
  print_value();          @}
  exit (0);
@}
@end smallexample

@noindent
In this example, the variable @code{my_var} is created in the file
@file{secondary.c}, assigned a value in the file @file{main.c}, and
printed out in the function @code{print_value}, which is defined in the
file @file{secondary.c}, but called from the file
@file{main.c}.

@xref{Compiling multiple files}, for information on how to compile a
program whose source code is split among multiple files.  For this
example, you can simply type the command @code{gcc -o testprog main.c
secondary.c}, and run the program with @code{./testprog}.




@node Static variables, Other storage classes, External variables, Storage classes
@subsection Static variables

@cindex Static variables
@cindex Variables, static
@findex static @r{storage class specifier}

A second important storage class specifier is @code{static}.  Normally,
when you call a function, all its local variables are reinitialized each
time the function is called.  This means that their values change between
function calls.  Static variables, however, maintain their value between
function calls.

Every global variable is defined as @code{static}
automatically.  (Roughly speaking, functions anywhere in a program can
refer to a global variable; in contrast, a function can only refer to a
local variable that is ``nearby'', where ``nearby'' is defined in a
specific manner.  @xref{Scope}, for more information on global
variables.  @xref{Expressions and operators}, for an example of a static
local variable.)




@node Other storage classes,  , Static variables, Storage classes
@subsection Other storage classes

@cindex Storage classes
@cindex Classes, storage
@findex auto @r{storage class specifier}
@findex register @r{storage class specifier}

There are three more storage class identifiers in C: @code{auto},
@code{register}, and @code{typedef}.

@itemize @bullet

@item
@code{auto} is the opposite of @code{static}.  It is redundant, but is
included in contemporary versions of C for backwards compatibility.  All
local variables are @code{auto} by default.

@item
@code{register} is another outdated C storage class.  Defining a variable
as @code{register} used to store it in one of the computer's registers, a
specific location on its processor chip, thereby making code using that
variable run faster.  These days, most C compilers (including GCC) are
smart enough to @dfn{optimize} the code (make it faster and more
compact) without the @code{register} keyword.

@item
@code{typedef} allows you to define your own variable types.  @xref{More
data types}, for more information.

@end itemize





@node Questions for Chapter 5,  , Storage classes, Variables and declarations
@section Questions for Chapter 5

@enumerate
@item
What is an identifier?

@item
Which of the following are valid C variable names?

@enumerate
@item
@code{Ralph23}
@item
@code{80shillings}
@item
@code{mission_control}
@item
@code{A%}
@item
@code{A$}
@item
@code{_off}
@end enumerate

@item
Write a statement to declare two integers called @code{start_temperature} and
@code{end_temperature}.

@item
What is the difference between the types @code{float} and @code{double}?

@item
What is the difference between the types @code{int} and @code{unsigned int}?

@item
Write a statement that assigns the value 1066 to the integer variable
@code{norman}.

@item
What data type do C functions return by default?

@item
You must declare the data type a function returns at two places in a
program.  Where?

@item
Write a statement, using the cast operator, to print out the integer part of the number 23.1256.

@item
Is it possible to have an automatic global variable?

@end enumerate



@c CHAPTER 6
@node Scope, Expressions and operators, Variables and declarations, Top
@chapter Scope

@emph{Where a program's fingers can and can't reach.}

@cindex Functions, as buildings
@cindex Buildings as metaphor for functions
@cindex Visibility of variables
@cindex Scope of variables
@cindex Variables, visibility of
@cindex Variables, scope of
@cindex Curly brackets as walls
@cindex Walls, as metaphors for curly brackets

Imagine that a function is a building with a person (Fred) standing in
the doorway.  This person can see certain things: other people and other
buildings, out in the open.  But Fred cannot see certain other things,
such as the people inside the other buildings.  Just so, some variables
in a C program, like the people standing outside, are @dfn{visible} to
nearly every other part of the program (these are called @dfn{global
variables}), while other variables, like the people indoors, are hidden
behind the ``brick walls'' of curly brackets (these are called
@dfn{local variables}).

Where a variable is visible to other C code is called the @dfn{scope} of
that variable.  There are two main kinds of scope, global and local,
which stem from the two kinds of places in which you can declare a
variable:

@enumerate

@cindex Global scope
@cindex Scope, global
@item
@dfn{Global scope} is outside all of the functions, that is, in the
space between function definitions --- after the @code{#include} lines,
for example.  Variables declared in global scope are called @dfn{global
variables}.  Global variables can be used in any function, as well as in
any block within that function.

@smallexample
#include <stdio.h>

int global_integer;
float global_floating_point;

int main ()
@{
  exit (0);
@}
@end smallexample

@cindex Local scope
@cindex Scope, local
@item
You can also declare variables immediately following the opening bracket
(@samp{@{}) of any block of code.  This area is called @dfn{local
scope}, and variables declared here are called @dfn{local variables}.
A local variable is visible within its own block and the ones that block
contains, but invisible outside its own block.


@smallexample
#include <stdio.h>

int main()
@{
  int foo;
  float bar, bas, quux;

  exit (0);
@}
@end smallexample

@end enumerate

@menu
* Global variables::            
* Local variables::             
* Communication via parameters::  
* Scope example::               
* Questions for Chapter 6::     
@end menu

@node Global variables, Local variables, Scope, Scope
@section Global Variables

@cindex Global variables
@cindex Variables, global

Global variables can be used in any function, as well as any block
within that function.  (Technically, global variables can only be seen
by functions that are defined after the declaration of those global
variables, but global variables are usually declared in a header file that is
included everywhere they are needed.)  Global variables are created when
a program is started and are not destroyed until a program is stopped.


@node Local variables, Communication via parameters, Global variables, Scope
@section Local Variables

@cindex Local variables
@cindex Variables, local

Local variables, on the other hand, are only visible within local scope.
They are ``trapped'' inside their code blocks.

@cindex Code blocks
@cindex Blocks, code

Just as global scope contains many functions, however, each function can
contain many code blocks (defined with curly brackets:
@samp{@{@dots{}@}}).  C allows blocks within blocks, even functions
within functions, @emph{ad infinitum}.  A local variable is visible
within its own block and the ones that block contains, but invisible
outside its own block.

@smallexample
int a;

/* Global scope.  Global variable 'a' is visible here,
   but not local variables 'b' or 'c'. */

int main()
@{
  int b;

  /* Local scope of 'main'.
     Variables 'a' and 'b' are visible here,
     but not 'c'. */

  @{
    int c;

    /* Local scope of @samp{@{@dots{}@}} block within 'main'.
       Variables 'a', 'b', and 'c' are all visible here. */
  @}

  exit (0);
@}
@end smallexample

@cindex Local variables, visibility of
@cindex Local variables, scope of
@cindex Variables, local, visibility of
@cindex Variables, local, scope of
@cindex Scope of local variables
@cindex Visibility of local variables

@noindent
Local variables are not visible outside their curly brackets.  To use an
``existence'' rather than a ``visibility'' metaphor, local variables are
created when the opening brace is met, and they are destroyed when the
closing brace is met.  (Do not take this too literally; they are not
created and destroyed in your C source code, but internally to the
computer, when you run the program.)


@node Communication via parameters, Scope example, Local variables, Scope
@section Communication via parameters

@cindex Parameters
@cindex Communication via parameters
@cindex Parameters, communication via

If no code inside a function could ever communicate with other parts of
the program, then functions would not be very useful.  Functions would
be isolated, comatose, unable to do much of anything.  Fortunately,
although local variables are invisible outside their code blocks, they
can still communicate with other functions via
parameters.  @xref{Expressions and operators}, the next chapter, for
information on parameters.


@node Scope example, Questions for Chapter 6, Communication via parameters, Scope
@section Scope example

@cindex Scope, example of
@cindex Stack, variable
@cindex Variable stack

Notice that there are two variables named @code{my_var} in the example
below, both visible in the same place.  When two or more variables
visible in one area of code have the same name, the last variable to be
defined takes priority.  (Technically adept readers will realize that
this is because it was the last one onto the variable stack.)

@smallexample
/***************************************************************/
/*                                                             */
/* SCOPE                                                       */
/*                                                             */
/***************************************************************/

#include <stdio.h>

int main ()
@{
  int my_var = 3;

  @{
    int my_var = 5;
    printf ("my_var=%d\n", my_var);
  @}

  printf ("my_var=%d\n", my_var);

  exit(0);
@}
@end smallexample

When you run this example, it will print out the following text:

@smallexample
my_var=5
my_var=3
@end smallexample



@node Questions for Chapter 6,  , Scope example, Scope
@section Questions for Chapter 6
@enumerate
@item
What is a global variable?

@item
What is a local variable?

@item
Do parameters spoil functions by leaking the variables into other
functions?

@item
Write a program @code{gnoahs_park} that declares 4 variables.  Two
@emph{global} integer variables called @code{num_gnus} and
@code{num_gnats}, and two @emph{local} floating point variables within
the function @code{main}, called @code{avg_gnu_mass}, and
@code{avg_gnat_mass}.  Then add another function called
@code{calculate_park_biomass}, and pass @code{avg_gnu_mass} and
@code{avg_gnat_mass} to it.  How many different storage spaces are used
when this program runs?  (Hint: are @code{avg_gnu_mass} and
@code{avg_gnat_mass} and their copies the same?)

@end enumerate




@c CHAPTER 7
@node Expressions and operators, Parameters, Scope, Top
@chapter Expressions and operators

@emph{Thinking in C.  Short strings of code.}

@cindex Operators

An @dfn{operator} is a character or string of characters used as a
built-in function.  We have already experimented with one operator in C:
the cast operator.

@cindex Addition operator
@cindex Operator, addition
@findex + @r{operator}

An operator is so called because it takes one or more values and
@dfn{operates} on them to produce a result.  For example, the addition
operator @code{+} can operate on the values 4 and 5 to produce the
result 9.  Such a procedure is called an @dfn{operation}, and any value
operated on (such as 4 and 5 in this example) is called an
@dfn{operand}.

@cindex Subtraction operator
@cindex Operator, subtraction
@findex - @r{operator}

There are many operators in C.  Some of them are familiar, such as the
addition operator @code{+} and subtraction operator @code{-}.  Most
operators can be thought of as belonging to one of three groups,
according to what they do with their operands:

@itemize @bullet

@cindex Multiplication operator
@cindex Operator, multiplication
@findex * @r{operator}
@cindex Operators, mathematical
@cindex Mathematical operators
@item
Mathematical operators, such as the addition operator @code{+} in
@code{100 + 500}, or the multiplication operator @code{*} in @code{12 *
2}.

@cindex Comparison operators
@cindex Operators, comparison
@findex < @r{less-than operator}
@findex > @r{greater-than operator}
@item
Comparison operators (a subset of mathematical operators), such as the
less-than operator @code{<} and the greater-than operator @code{>}.

@cindex Cast operator
@cindex Operator, cast
@item
Operators that produce new variable types, such as the cast operator.

@end itemize


@cindex Boolean values
@cindex Values, Boolean
The majority of operators fall into the first group.  The second group
is a subset of the first set; in this second set, the result of an
operation is a @dfn{Boolean value} (a value of either true or false).

C has about forty different operators.  The chief object of this chapter
is to explain the basic operators in C.  We will examine more complex
operators in another chapter.  (@xref{Advanced operators}.)

@menu
* The assignment operator::     
* Expressions and values::      
* Expressions::                 
* Parentheses and Priority::    
* Unary Operator Precedence::   
* Special Assignment Operators ++ --::  
* More Special Assignments::    
* Comparisons and logic::       
* Logical operators::           
* Questions for Chapter 7::     
@end menu


@node The assignment operator, Expressions and values, Expressions and operators, Expressions and operators
@section The assignment operator

@cindex Assignment operator
@cindex Operator, assignment
@findex = @r{assignment operator}
No operator such as addition (@code{+}) or multiplication (@code{*})
would be useful without another operator that attaches the values they
produce to variables.  Thus, the assignment operator @code{=} is perhaps
the most important mathematical operator.

We have seen the assignment operator already in our code examples.  Here
is an example to refresh your memory:

@smallexample
int gnu_count, gnat_count, critter_count;

gnu_count = 45;
gnat_count = 5678;

critter_count = gnu_count + gnat_count;
@end smallexample

@noindent
The assignment operator takes the value of whatever is on the right-hand
side of the @code{=} symbol and puts it into the variable on the
left-hand side.  For example, the code sample above assigns the value 45
to the variable @code{gnu_count}.

@cindex Lvalues
Something that can be assigned @emph{to} is called an @dfn{lvalue},
(``l'' for ``left'', because it can appear on the @emph{left} side of an
assignment).  You will sometimes see the word @samp{lvalue} in error
messages from the compiler.  For example, try to compile a program
containing the following code:

@smallexample
5 = 2 + 3;
@end smallexample

You will receive an error such as the following:

@error{}
@smallexample
bad_example.c:3: invalid lvalue in assignment
@end smallexample

@noindent
You can't assign a value to 5; it has its own value already!  In
other words, 5 is not an lvalue.

@menu
* Important note about assignment::  
@end menu

@node Important note about assignment,  , The assignment operator, The assignment operator
@subsection Important note about assignment

@cindex Assignment operator, confused with equality operator
@cindex Equality operator, confused with assignment operator
@findex = @r{confused with} ==
@findex == confused with =
Many people confuse the assignment operator (@code{=}) with the equality
operator (@code{==}), and this is a major source of bugs in C programs.
Because of early arithmetic training, people tend to think of @code{=}
as indicating equality, but in C it means ``takes on the value produced
by'', and it should always be read that way.  By way of contrast,
@code{==} is an equality test operator and should always be read ``is
tested for equality with''.  (@xref{Comparisons and logic}, for more
information on the @code{==} operator.)



@node  Expressions and values, Expressions, The assignment operator, Expressions and operators
@section Expressions and values

The most common operators in any language are basic arithmetic
operators.  In C, these include the following:

@cindex Arithmetic operators
@cindex Operators, arithmetic
@table @code

@findex + @r{unary plus operator}
@item +
unary plus, example: @code{+5}

@findex - @r{unary minus operator}
@item -
unary minus, example: @code{-5}

@findex + @r{addition operator}
@item +
addition, example: @code{2 + 2}

@findex - @r{subtraction operator}
@item -
subtraction, example: @code{14 - 7}

@findex * @r{multiplication operator}
@item *
multiplication, example: @code{3 * 3}

@findex / @r{division operator}
@item /
floating point division, example: @code{10.195 / 2.4}

@findex / @r{integer division operator}
@findex / @r{div operator}
@item /
integer division @emph{div}, example: @code{5 / 2}

@findex % @r{integer remainder operator}
@findex % @r{mod operator}
@findex % @r{modulo operator}
@item %
integer remainder @emph{mod}, example: @code{24 % 7}

@end table

@noindent



@node Expressions, Parentheses and Priority, Expressions and values, Expressions and operators
@section Expressions

@cindex Expressions

An @dfn{expression} is simply a string of operators, variables, numbers,
or some combination, that can be parsed by the compiler.  All of the
following are expressions:

@smallexample
19

1 + 2 + 3

my_var

my_var + some_function()

(my_var + 4 * (some_function() + 2))

32 * circumference / 3.14

day_of_month % 7
@end smallexample

Here is an example of some arithmetic expressions in C:

@smallexample
#include <stdio.h>

int main ()
@{
  int my_int;

  printf ("Arithmetic Operators:\n\n");

  my_int = 6;
  printf ("my_int = %d, -my_int = %d\n", my_int, -my_int);

  printf ("int 1 + 2 = %d\n", 1 + 2);
  printf ("int 5 - 1 = %d\n", 5 - 1);
  printf ("int 5 * 2 = %d\n", 5 * 2);

  printf ("\n9 div 4 = 2 remainder 1:\n");
  printf ("int 9 / 4 = %d\n", 9 / 4);
  printf ("int 9 % 4 = %d\n", 9 % 4);

  printf ("double 9 / 4 = %f\n", 9.0 / 4.0);

  return 0;
@}
@end smallexample

@noindent
The program above produces the output below:

@smallexample
Arithmetic Operators:

my_int = 6, -my_int = -6
int 1 + 2 = 3
int 5 - 1 = 4
int 5 * 2 = 10

9 div 4 = 2 remainder 1:
int 9 / 4 = 2
int 9 % 4 = 1
double 9 / 4 = 2.250000
@end smallexample



@node Parentheses and Priority, Unary Operator Precedence, Expressions, Expressions and operators
@section Parentheses and Priority

@cindex Parentheses
@cindex Order of operations
@cindex Operations, order of
@cindex Operator precedence
@cindex Precedence, operator

Just as in algebra, the C compiler considers operators to have certain
priorities, and @dfn{evaluates}, or parses, some operators before
others.  The order in which operators are evaluated is called
@dfn{operator precedence} or the @dfn{order of operations}.  You can
think of some operators as ``stronger'' than others.  The ``stronger''
ones will always be evaluated first; otherwise, expressions are
evaluated from left to right.

For example, since the multiplication operator @code{*} has a higher
priority than the addition operator @code{+} and is therefore evaluated
first, the following expression will always evaluate to 10 rather
than 18:

@smallexample
4 + 2 * 3
@end smallexample

However, as in algebra, you can use parentheses to force the program
to evaluate the expression to 18:

@smallexample
(4 + 2) * 3
@end smallexample

The parentheses force the expression @code{(4 + 2)} to be evaluated
first.  Placing parentheses around @code{2 * 3}, however, would have no
effect.

Parentheses are classed as operators by the compiler; they have a value,
in the sense that they assume the value of whatever is inside them.  For
example, the value of @code{(5 + 5)} is 10.



@node Unary Operator Precedence, Special Assignment Operators ++ --, Parentheses and Priority, Expressions and operators
@section Unary Operator Precedence

@cindex Unary operators
@cindex Unary operators, order of operation
@cindex Order of operation, unary operators

Unary operators are operators that have only a single operand --- that
is, they operate on only one object.  The following are (or can be) all
unary operators:

@smallexample
++  --  +  -
@end smallexample

@noindent
The order of evaluation of unary operators is from right to left, so an
expression like:

@smallexample
*ptr++;
@end smallexample

@noindent
would perform the @code{++} before the @code{*}.  (The @code{++}
operator will be introduced in the next section, and the @code{*}
operator will be introduced in the next chapter.  @xref{Pointers}.)


@node Special Assignment Operators ++ --, More Special Assignments, Unary Operator Precedence, Expressions and operators
@section Special Assignment Operators @code{++} and @code{--}

@findex ++ @r{increment operator}
@findex -- @r{decrement operator}
@cindex Special assignment operators
@cindex Operators, special assignment

C has some special operators that can simplify code.  The simplest of
these are the increment and decrement operators:

@table @code

@item ++
increment: add one to
@item --
decrement: subtract one from
@end table

@noindent
You can use these with any integer or floating point variable (or a
character in some cases, carefully).  They simply add or subtract 1
from a variable.  The following three statements are equivalent:

@smallexample
variable = variable + 1;
variable++;
++variable;
@end smallexample

@noindent
So are these three:

@smallexample
variable = variable - 1;
variable--;
--variable;
@end smallexample

@noindent

@noindent
Notice that the @code{++} and @code{--} operators can be placed before
or after the variable.  In the cases above, the two forms work
identically, but there is actually a subtle difference.  (@xref{Postfix
and prefix ++ and --}, for more information.)



@node More Special Assignments, Comparisons and logic, Special Assignment Operators ++ --, Expressions and operators
@section More Special Assignments

@cindex Special assignment operators
@cindex Operators, special assignment

Like @code{++} and @code{--}, the following operators are short ways of
writing longer expressions.  Consider the following statement:

@smallexample
variable = variable + 23;
@end smallexample

@findex += @r{operator}
@noindent
In C, this would be a long-winded way of adding 23 to @code{variable}.  It
could be done more simply with the general increment operator @code{+=}, as in
this example:

@smallexample
variable += 23;
@end smallexample

@noindent
This performs exactly the same operation.  Similarly, the following two
statements are equivalent:

@smallexample
variable1 = variable1 + variable2;
variable1 += variable2;
@end smallexample

@noindent
There are a handful of these operators.  For example, one for
subtraction:

@findex -= @r{operator}
@smallexample
variable = variable - 42;
variable -= 42;
@end smallexample

@noindent
More surprisingly, perhaps, there is one for multiplication:

@findex *= @r{operator}
@smallexample
variable = variable * 2;
variable *= 2;
@end smallexample

@noindent

The main arithmetic operators all follow this pattern:

@cindex Arithmetic operators
@cindex Operators, arithmetic
@table @code
@item +=
addition assignment operator
@item -=
subtraction assignment operator
@item *=
multiplication assignment operator
@item /=
division assignment operator (floating point and integers)
@item %=
remainder assignment operator (integers only)
@end table

There are more exotic kinds too, used for machine-level operations,
which we will ignore for the moment.  (@xref{Advanced operators}, if you
want to know more.)

Here is a short program that demonstrates these special assignment operators:

@cindex Special assignment operators, example
@smallexample
#include <stdio.h>

int main()
@{
  int my_int;

  printf ("Assignment Operators:\n\n");

  my_int = 10;                           /* Assignment */
  printf ("my_int = 10 : %d\n",my_int);

  my_int++;                              /* my_int = my_int + 1 */
  printf ("my_int++    : %d\n",my_int);

  my_int += 5;                           /* my_int = my_int + 5 */
  printf ("my_int += 5 : %d\n",my_int);

  my_int--;                              /* my_int = my_int = 1 */
  printf ("my_int--    : %d\n",my_int);

  my_int -= 2;                           /* my_int = my_int - 2 */
  printf ("my_int -= 2 : %d\n",my_int);

  my_int *= 5;                           /* my_int = my_int * 5 */
  printf ("my_int *= 5 : %d\n",my_int);

  my_int /= 2;                           /* my_int = my_int / 2 */
  printf ("my_int /= 2 : %d\n",my_int);

  my_int %= 3;                           /* my_int = my_int % 3 */
  printf ("my_int %%= 3 : %d\n",my_int);

  return 0;
@}
@end smallexample

@noindent
The program above produces the output below:

@smallexample
Assignment Operators:

my_int = 10 : 10
my_int++    : 11
my_int += 5 : 16
my_int--    : 15
my_int -= 2 : 13
my_int *= 5 : 65
my_int /= 2 : 32
my_int %= 3 : 2
@end smallexample

The second to last line of output is

@example
my_int /= 2 : 32
@end example

@noindent
In this example, 65 divided by 2 using the @code{/=} operator results in
32, not 32.5.  This is because both operands, 65 and 2, are integers,
type @code{int}, and when @code{/=} operates on two integers, it
produces an integer result.  This example only uses integer values,
since that is how the numbers are declared.  To get the fractional
answer, you would have had to declare the three numbers involved as
floats.

The last line of output is

@example
my_int %= 3 : 2
@end example

@noindent
This is because 32 divided by 3 is 10 with a remainder of 2.




@node Comparisons and logic, Logical operators, More Special Assignments, Expressions and operators
@section Comparisons and logic

@cindex Comparison operators
@cindex Operators, comparison
Comparison operators tell you how numerical values relate to one
another, such as whether they are equal to one another, or whether one
is greater than the other. Comparison operators are used in logical
tests, such as @code{if} statements. (@xref{Decisions}.)

@cindex True Boolean value
@cindex False Boolean value
The results of a logical comparison are always either true (1) or false
(0). In computer programming jargon, true and false are the two
@dfn{Boolean values}.  Note that, unlike real life, there are no ``gray
areas'' in C; just as in Aristotelian logic, a comparison operator will
never produce a value other than true or false.

Six operators in C are used to make logical comparisons:

@table @code
@item ==
is equal to
@item !=
is not equal to
@item >
is greater than
@item <
is less than
@item >=
is greater than or equal to
@item <=
is less than or equal to
@end table

@cindex Assignment operator, confused with equality operator
@cindex Equality operator, confused with assignment operator
@findex = @r{confused with} ==
@findex == confused with =
@noindent
@strong{Important:} Remember that many people confuse the equality operator
(@code{==}) with the assignment operator (@code{=}), and this is a major
source of bugs in C programs.  (@xref{Expressions and values}, for more
information on the distinction between the @code{==} and @code{=}
operators.)

@cindex Boolean values
@cindex Values, Boolean
@findex TRUE @r{macro}
@findex FALSE @r{macro}
The operators above result in values, much as the addition operator
@code{+} does.  They produce Boolean values: true and false only.
Actually, C uses 1 for ``true'' and 0 for ``false'' when evaluating
expressions containing comparison operators, but it is easy to define
the strings @samp{TRUE} and @samp{FALSE} as macros, and they may well
already be defined in a library file you are using.  (@xref{Preprocessor
directives}, for information on defining macros.)

@smallexample
#define TRUE  1
#define FALSE 0
@end smallexample

Note that although any non-zero value in C is treated as true,
you do not need to worry about a comparison evaluating to anything other
than 1 or 0.  Try the following short program:

@smallexample
#include <stdio.h>

int main ()
@{
  int truth, falsehood;

  truth = (2 + 2 == 4);
  falsehood = (2 + 2 == 5);

  printf("truth is %d\n", truth);
  printf("falsehood is %d\n", falsehood);

  exit (0);
@}
@end smallexample

@noindent
You should receive the following result:

@smallexample
truth is 1
falsehood is 0
@end smallexample



@node Logical operators, Questions for Chapter 7, Comparisons and logic, Expressions and operators
@section Logical operators

@cindex Logical operators
@cindex Operators, logical
@cindex Comparison operators
@cindex Operators, comparison

Comparisons are often made in pairs or groups.  For example, you might
want to ask a question such as, ``Is variable @code{a} greater than
variable @code{b} @emph{and} is variable @code{b} greater than variable
@code{c}?''  The word ``and'' in the question above is represented in
C by the @dfn{logical operator} (an ``operator on Boolean values'')
@code{&&}, and the whole comparison above might be represented by the
following expression:

@smallexample
(a > b) && (b > c)
@end smallexample

@need 1200
@noindent
The main logical operators in C are as follows:

@table @code
@item &&
logical AND
@item ||
logical Inclusive OR (@xref{Inclusive OR}.)
@item !
logical NOT
@end table

Here is another example.  The question, ``Is the variable @code{a}
greater than the variable @code{b}, @emph{or} is the variable @code{a}
@emph{not} greater than the variable @code{c}?'' might be written:

@smallexample
(a > b) || !(a > c)
@end smallexample

@menu
* Inclusive OR::                
@end menu



@node Inclusive OR,  , Logical operators, Logical operators
@subsection Inclusive OR

@cindex Inclusive OR
@cindex OR, inclusive
@cindex To be or not to be
@cindex Shakespeare

@strong{Note well!} Shakespeare might have been disappointed that,
@emph{whatever} the value of a variable @code{to_be}, the result of

@smallexample
to_be || !to_be
@end smallexample

@noindent
(i.e.  ``To be, or not to be?'') is always 1, or true.
This is because one or the other of @code{to_be} or @code{!to_be} must
always be true, and as long as one side of an OR @code{||} expression is
true, the whole expression is true.


@node Questions for Chapter 7,  , Logical operators, Expressions and operators
@section Questions for Chapter 7

@enumerate

@item
What is an operand?

@item
Write a short statement that assigns the remainder of 5 divided by 2 to
a variable called @code{remainder} and prints it out.

@item
Write a statement that subtracts -5 from 10.

@end enumerate






@c CHAPTER 8
@node Parameters, Pointers, Expressions and operators, Top
@chapter Parameters

@emph{Ways in and out of functions.}

@cindex Parameters
@cindex Passing information with parameters
@cindex Passing parameters

@dfn{Parameters} are the main way in C to transfer, or @dfn{pass},
information from function to function.  Consider a call to our old friend
@code{calculate_bill}:

@smallexample
total = calculate_bill (20, 35, 28);
@end smallexample

We are passing 20, 35, and 28 as parameters to @code{calculate_bill} so
that it can add them together and return the sum.

When you pass information to a function with parameters, in some cases
the information can go only one way, and the function returns only a
single value (such as @code{total} in the above snippet of code).  In
other cases, the information in the parameters can go both ways; that
is, the function called can alter the information in the parameters it
is passed.

@cindex Passing parameters by value
@cindex Passing parameters by reference
@cindex Value, passing parameters by
@cindex Reference, passing parameters by

The former technique (passing information only one way) is called
@dfn{passing parameters by value} in computer programming jargon, and
the latter technique (passing information both ways) is referred to as
@dfn{passing parameters by reference}.

For our purposes, at the moment, there are two (mutually exclusive)
kinds of parameters:

@itemize @bullet

@cindex Value parameters
@cindex Parameters, value
@item
@dfn{Value parameters} are the kind that pass information one-way.  They
are so-called because the function to which they are passed receives
only a copy of their values, and they cannot be altered as variable
parameters can.  The phrase ``passing by value'' mentioned above is
another way to talk about passing ``value parameters''.

@cindex Variable parameters
@cindex Parameters, variable
@item
@dfn{Variable parameters} are the kind that pass information back to the
calling function.  They are so called because the function to which they
are passed can alter them, just as it can alter an ordinary variable.
The phrase ``passing by reference'' mentioned above is another way to
talk about passing ``variable parameters''.

@end itemize

Consider a slightly-expanded version of @code{calculate_bill}:


@cindex Value parameters, example of
@cindex Parameters, value, example of
@smallexample
#include <stdio.h>

int main (void);
int calculate_bill (int, int, int);

int main()
@{
  int bill;
  int fred = 25;
  int frank = 32;
  int franny = 27;

  bill = calculate_bill (fred, frank, franny);
  printf("The total bill comes to $%d.00.\n", bill);

  exit (0);
@}

int calculate_bill (int diner1, int diner2, int diner3)
@{
  int total;

  total = diner1 + diner2 + diner3;
  return total;
@}
@end smallexample

Note that all of the parameters in this example are value parameters:
the information flows only one way.  The values are passed to the
function @code{calculate_bill}. The original values are not changed. In
slightly different jargon, we are ``passing the parameters by value
only''. We are @emph{not} passing them ``by reference''; they are
@emph{not} ``variable parameters''.

@cindex Parameters, declaring
@cindex Declaring parameters
All parameters must have their types declared. This is true whether they
are value parameters or variable parameters.  In the function
@code{calculate_bill} above, the value parameters @code{diner1},
@code{diner2}, and @code{diner3} are all declared to be of type
@code{int}.


@menu
* Parameters in function prototypes::  
* Value parameters::            
* Actual parameters and formal parameters::  
* Variadic functions::          
* Questions for Chapter 8::     
@end menu

@node Parameters in function prototypes, Value parameters, Parameters, Parameters
@section Parameters in function prototypes

@cindex Parameters in function prototypes
@cindex Function prototypes, parameters in
@cindex Prototypes, function, parameters in
Note that in the function prototype for @code{calculate_bill}, the
parameter names were completely omitted.  This is perfectly acceptable
in ANSI C, although it might be confusing to someone trying to
understand your code by reading the function prototypes, which can be in
a separate file from the functions themselves.  For instance, in the
code example above, the function prototype for @code{calculate_bill}
looks like this:

@smallexample
int calculate_bill (int, int, int);
@end smallexample

You may include parameter names in function prototypes if you wish; this
is usually a good idea when the function prototype is significantly
separated from the function definition, such as when the prototype is in
a header file or at the top of a long file of function definitions.  For
example, we could have written the prototype for @code{calculate_bill} thus:

@smallexample
int calculate_bill (int diner1, int diner2, int diner3);
@end smallexample

Parameter names in a function prototype do not need to match the names
in the function's definition; only their types need to match.  For
example, we can also write the function prototype above in this way:

@smallexample
int calculate_bill (int guest1, int guest2, int guest3);
@end smallexample

@cindex International Obfuscated C Code Contest
@cindex Obfuscated C Code Contest, International
As usual, it is a good idea to use mnemonic names for the parameters in
a function prototype, as in the last two examples.  @footnote{That is,
unless you are competing in @uref{http://www.ioccc.org/, The
International Obfuscated C Code Contest}.}  Thus, the function prototype
below is not as helpful to the person reading your code as the last two
examples are; it might just as well have been written without variable
names at all:

@smallexample
int calculate_bill (int variable1, int variable2, int variable3);
@end smallexample


@menu
* Value parameters::
* Actual parameters and formal parameters::
* Variadic functions::
* Questions for Chapter 8::
@end menu


@node Value parameters, Actual parameters and formal parameters, Parameters in function prototypes, Parameters
@section Value Parameters

@cindex Value parameters
@cindex Parameters, value
@cindex Passing parameters by value
When you are passing data to a function by value, the parameters in the
function you are passing the data @emph{to} contain copies of the data
in the parameters you are passing the data @emph{with}.  Let us modify
the function @code{main} from the last example slightly:

@smallexample
int main()
@{
  int bill;
  int fred = 25;
  int frank = 32;
  int franny = 27;

  bill = calculate_bill (fred, frank, franny);

  fred = 20000;
  frank = 50000;
  franny = 20000;

  printf("The total bill comes to $%d.00.\n", bill);

  exit (0);
@}
@end smallexample

As far as the function @code{calculate_bill} is concerned, @code{fred},
@code{frank}, and @code{franny} are still 25, 32, and 27 respectively.
Changing their values to extortionate sums after passing them to
@code{calculate_bill} does nothing; @code{calculate_bill} has already
created local copies of the parameters, called @code{diner1},
@code{diner2}, and @code{diner3} containing the earlier values.

@strong{Important:} Even if we named the parameters in the definition of
@code{calculate_bill} to match the parameters of the function
call in @code{main} (see example below), the result would be the same:
@code{main} would print out @samp{$84.00}, not @samp{$90000.00}.  When
passing data by value, the parameters in the function call and the
parameters in the function definition (which are only copies of the
parameters in the function call) are completely separate.

Just to remind you, this is the @code{calculate_bill} function:

@smallexample
int calculate_bill (int fred, int frank, int franny)
@{
  int total;

  total = fred + frank + franny;
  return total;
@}
@end smallexample




@node Actual parameters and formal parameters, Variadic functions, Value parameters, Parameters
@section Actual parameters and formal parameters

@cindex Actual parameters
@cindex Formal parameters
@cindex Parameters, actual
@cindex Parameters, formal
There are two other categories that you should know about that are also
referred to as ``parameters''. They are called ``parameters'' because
they define information that is passed to a function.

@itemize @bullet

@item
@dfn{Actual parameters} are parameters as they appear in function calls.

@item
@dfn{Formal parameters} are parameters as they appear in function
declarations.

@end itemize

A parameter cannot be both a formal and an actual parameter, but both
formal parameters and actual parameters can be either value parameters
or variable parameters.

Let's look at @code{calculate_bill} again:

@smallexample
#include <stdio.h>

int main (void);
int calculate_bill (int, int, int);

int main()
@{
  int bill;
  int fred = 25;
  int frank = 32;
  int franny = 27;

  bill = calculate_bill (fred, frank, franny);
  printf("The total bill comes to $%d.00.\n", bill);

  exit (0);
@}

int calculate_bill (int diner1, int diner2, int diner3)
@{
  int total;

  total = diner1 + diner2 + diner3;
  return total;
@}
@end smallexample

In the function @code{main} in the example above, @code{fred},
@code{frank}, and @code{franny} are all actual parameters when used to
call @code{calculate_bill}.  On the other hand, the corresponding
variables in @code{calculate_bill} (namely @code{diner1}, @code{diner2}
and @code{diner3}, respectively) are all formal parameters because they
appear in a function definition.

Although formal parameters are always variables (which does not mean
that they are always variable parameters), actual parameters do not have
to be variables.  You can use numbers, expressions, or even function
calls as actual parameters.  Here are some examples of valid actual
parameters in the function call to @code{calculate_bill}:

@smallexample
bill = calculate_bill (25, 32, 27);

bill = calculate_bill (50+60, 25*2, 100-75);

bill = calculate_bill (fred, franny, (int) sqrt(25));
@end smallexample

@pindex math.h @r{system header file}
@findex sqrt @r{function}
@noindent
(The last example requires the inclusion of the math routines in
@file{math.h}, and compilation with the @option{-lm} option.
@code{sqrt} is the square-root function and returns a @code{double}, so
it must be cast into an @code{int} to be passed to
@code{calculate_bill}.)



@node Variadic functions, Questions for Chapter 8, Actual parameters and formal parameters, Parameters
@section Variadic functions

@cindex Variadic functions
@cindex Functions, variadic
Suppose you are writing a program that repeatedly generates lists of
numbers that can run anywhere from one to fifty items.  You never know
how many numbers a particular list will contain, but you always want to
add all the numbers together.  Passing them to an ordinary C function
will not work, because an ordinary function has a fixed number of formal
parameters, and cannot accept an arbitrarily long list of actual
parameters.  What should you do?

@pindex stdarg.h @r{system header file}
One way of solving this problem is to use a @dfn{variadic function}, or
function that can accept arbitrarily long lists of actual parameters.
You can do this by including the @file{stdarg.h} header in your program.
For example, with @file{stdarg.h}, you can write a function called
@code{add_all} that will add all integers passed to it, returning
correct results for all of the following calls:

@smallexample
sum = add_all (2, 3, 4);

sum = add_all (10, 150, 9, 81, 14, 2, 2, 31);

sum = add_all (4);
@end smallexample

Unfortunately, the use of @file{stdarg.h} is beyond the scope of this
tutorial.  For more information on variadic functions, see
@uref{http://www.gnu.org/manual/glibc-2.0.6/libc.html, the GNU C Library
manual}.


@node Questions for Chapter 8,  , Variadic functions, Parameters
@section Questions for Chapter 8

@enumerate

@item
What is the difference between a value parameter and a variable
parameter?

@item
What is the difference between a formal parameter and an actual
parameter?

@item
What does passing by reference let you do that passing by value doesn't?

@item
Can a function call be used as an actual parameter?

@item
Do actual and formal parameters need to have the same names?

@end enumerate




@c CHAPTER 9
@node Pointers, Decisions, Parameters, Top
@chapter Pointers

@emph{Making maps of data.}

@cindex Pointers
@cindex Addresses, memory
@cindex Memory addresses

In one sense, any variable in C is just a convenient label for a chunk
of the computer's memory that contains the variable's data.  A
@dfn{pointer}, then, is a special kind of variable that contains the
location or @dfn{address} of that chunk of memory.  (Pointers are so
called because they @emph{point} to a chunk of memory.) The address
contained by a pointer is a lengthy number that enables you to pinpoint
exactly where in the computer's memory the variable resides.

@cindex Passing by reference, origin of term
@cindex Reference, passing by, origin of term
Pointers are one of the more versatile features of C. There are many
good reasons to use them.  Knowing a variable's address in memory
enables you to pass the variable to a function by reference
(@xref{Variable parameters}.)  @footnote{This, by the way, is how the
phrase ``pass by reference'' entered the jargon.  Like other pointers, a
variable parameter ``makes a reference'' to the address of a variable.}
Also, since functions are just chunks of code in the computer's memory,
and each of them has its own address, you can create pointers to
functions too, and knowing a function's address in memory enables you to
pass functions as parameters too, giving your functions the ability to
switch among calling numerous functions.  (@xref{Function pointers}.)

Pointers are important when using text strings.  In C, a text string is
always accessed with a pointer to a character --- the first character of
the text string.  For example, the following code will print the text
string @samp{Boy howdy!}:

@smallexample
char *greeting = "Boy howdy!";
printf ("%s\n\n", greeting);
@end smallexample

@noindent
@xref{Strings}.

Pointers are important for more advanced types of data as well.  For
example, there is a data structure called a ``linked list'' that uses
pointers to ``glue'' the items in the list together.  (@xref{Data
structures}, for information on linked lists.)

@findex scanf @r{function}
Another use for pointers stems from functions like the C input routine
@code{scanf}.  This function accepts information from the keyboard, just
as @code{printf} sends output to the console.  However, @code{scanf}
uses pointers to variables, not variables themselves.  For example, the
following code reads an integer from the keyboard:

@smallexample
int my_integer;
scanf ("%d", &my_integer);
@end smallexample

@noindent
(@xref{scanf}, for more information.)


@menu
* Pointer operators::           
* Pointer types::               
* Pointers and initialization::  
* Variable parameters::         
* Questions for Chapter 9::     
@end menu


@node Pointer operators, Pointer types, Pointers, Pointers
@section Pointer operators

@findex * @r{pointer operator}
@findex & @r{pointer operator}

To create a pointer to a variable, we use the @code{*} and @code{&}
operators.  (In context, these have nothing to do with multiplication or
logical AND. For example, the following code declares a variable called
@code{total_cost} and a pointer to it called @code{total_cost_ptr}.

@smallexample
float total_cost;
float *total_cost_ptr;

total_cost_ptr = &total_cost;
@end smallexample

The @samp{*} symbol in the declaration of @code{total_cost_ptr} is the
way to declare that variable to be a pointer in C.  (The @samp{_ptr} at the
end of the variable name, on the other hand, is just a way of reminding
humans that the variable is a pointer.)

When you read C code to yourself, it is often useful to be able to
pronounce C's operators aloud; you will find it can help you make sense
of a difficult piece of code.  For example, you can pronounce the above
statement @code{float *total_cost_ptr} as ``Declare a float pointer
called @code{total_cost_ptr}'', and you can pronounce the statement
@code{total_cost_ptr = &total_cost;} as ``Let @code{total_cost_ptr} take
as its value the address of the variable @code{total_cost}''.

Here are some suggestions for pronouncing the @code{*} and @code{&}
operators, which are always written in front of a variable:

@table @code

@item *
``The contents of the address held in @var{variable}'' or
``the contents of the location pointed to by @var{variable}''.

@item &
``The address of @var{variable}'' or
``the address at which the variable @var{variable} is stored''.

@end table

@noindent
For instance:

@table @code

@item &fred
``The address of @code{fred}'' or
``the address at which the variable @code{fred} is stored''.

@item *fred_ptr
``The contents of the address held in @code{fred_ptr}'' or
``the contents of the location pointed to by @code{fred_ptr}''.

@end table


@need 1200
The following examples show some common ways in which you might use the
@code{*} and @code{&} operators:

@smallexample
@group
int some_var;                           /* 1 */
@r{``Declare an integer variable called @code{some_var}.''}

int *ptr_to_some_var;                   /* 2 */
@r{``Declare an integer pointer called @code{ptr_to_some_var}.''  (The
@code{*} in front of @code{ptr_to_some_var} is the way C declares
@code{ptr_to_some_var} as a pointer to an integer, rather than just an
integer.)}

some_var = 42;                          /* 3 */
@r{``Let @code{some_var} take the value 42.''}
@end group

@group
ptr_to_some_var = &some_var;            /* 4 */
@r{``Let @code{ptr_to_some_var} take the address of the variable
@code{some_var} as its value.''  (Notice that only now does
@code{ptr_to_some_var} become a pointer to the particular variable
@code{some_var} --- before this, it was merely a pointer that could
point to @emph{any} integer variable.)}

printf ("%d\n\n", *ptr_to_some_var);    /* 5 */
@r{``Print out the contents of the location pointed to by
@code{ptr_to_some_var}.''  (In other words, print out @code{some_var}
itself.  This will print just 42.  Accessing what a pointer points to in
this way is called @dfn{dereferencing} the pointer, because the pointer
is considered to be @dfn{referencing} the variable.)}

*ptr_to_some_var = 56; /* 6 */ @r{``Let the contents of the location
pointed to by @code{ptr_to_some_var} equal 56.''  (In the context of the
other statements, this is the same as the more direct statement
@code{some_var = 56;}.)}
@end group
@end smallexample

@strong{A subtle point:} don't confuse the usage of asterisks in code
like examples 2 and 6 above.  Using an asterisk in a declaration, as in
example 2, declares the variable to be a pointer, while using it on the
left-hand side of an assignment, as in example 6, dereferences a
variable that is already a pointer, enabling you to access the variable
to which the pointer is pointing.




@node Pointer types, Pointers and initialization, Pointer operators, Pointers
@section Pointer types

@cindex Pointer types
@cindex Pointers, types of
@cindex Types, pointer

Pointers can point to any type of variable, but they must be declared to
do so.  A pointer to an integer is not the same type of variable as a
pointer to a float or other variable type.  At the ``business end'' of
a pointer is usually a variable, and all variables have a type.

Here are some examples of different types of pointer:

@smallexample
int *my_integer_ptr;

char *my_character_ptr;

float *my_float_ptr;

double *my_double_ptr;
@end smallexample

However, GCC is fairly lenient about casting different types of pointer
to one another @dfn{implicitly}, or automatically, without your
intervention.  For example, the following code will simply truncate the
value of @code{*float_ptr} and print out 23. (As a bonus, pronunciation
is given for every significant line of the code in this example.)

@cindex Pointer expressions, pronunciation of
@cindex Pronunciation of pointer expressions
@smallexample
#include <stdio.h>
/* Include the standard input/output header in this program */

int main()
/* Declare a function called main that returns an integer
   and takes no parameters */
@{
  int *integer_ptr;
  /* Declare an integer pointer called integer_ptr */

  float *float_ptr;
  /* Declare a floating-point pointer called float_ptr */

  int my_int = 17;
  /* Declare an integer variable called my_int
     and assign it the value 17 */

  float my_float = 23.5;
  /* Declare a floating-point variable called my_float
     and assign it the value 23.5 */

  integer_ptr = &my_int;
  /* Assign the address of the integer variable my_int
     to the integer pointer variable integer_ptr */

  float_ptr = &my_float;
  /* Assign the address of the floating-point variable my_float
     to the floating-point pointer variable float_ptr */

  *integer_ptr = *float_ptr;
  /* Assign the contents of the location pointed to by
     the floating-point pointer variable float_ptr
     to the location pointed to by the integer pointer variable
     integer_ptr (the value assigned will be truncated) */

  printf ("%d\n\n", *integer_ptr);
  /* Print the contents of the location pointed to by the
     integer pointer variable integer_ptr */

  return 0;
  /* Return a value of 0, indicating successful execution,
     to the operating system */

@}
@end smallexample

There will still be times when you will want to convert one type of
pointer into another.  For example, GCC will give a warning if you try to
pass float pointers to a function that accepts integer pointers.  Not
treating pointer types interchangeably will also help you understand
your own code better.

@cindex Pointer types, casting
@cindex Casting pointer types
@cindex Cast operator
@cindex Operator, cast
To convert pointer types, use the cast operator.  (@xref{The cast
operator}.)  As you know, the general form of the cast operator is as
follows:

@smallexample
(@var{type}) @var{variable}
@end smallexample

@noindent
Here is the general form of the cast operator for pointers:

@smallexample
(@var{type} *) @var{pointer_variable}
@end smallexample

@noindent
Here is an actual example:

@smallexample
int *my_integer_ptr;
long *my_long_ptr;

my_long_ptr = (long *) my_integer_ptr;
@end smallexample

@noindent
This copies the value of the pointer @code{my_integer} to the pointer
@code{my_long_ptr}.  The cast operator ensures that the data types match.
(@xref{Data structures}, for more details on pointer casting.)




@node Pointers and initialization, Variable parameters, Pointer types, Pointers
@section Pointers and initialization

@cindex Pointers and initialization
@cindex Initialization and pointers
You should not initialize pointers with a value when you declare them,
although the compiler will not prevent this.  Doing so simply makes no
sense.  For example, think about what happens in the following
statement:

@smallexample
int *my_int_ptr = 2;
@end smallexample

@noindent
First, the program allocates space for a pointer to an integer.
Initially, the space will contain @dfn{garbage} (random data).
It will not contain actual data until the pointer is ``pointed at''
such data.  To cause the pointer to refer to a real variable, you
need another statement, such as the following:

@smallexample
my_int_ptr = &my_int;
@end smallexample

@noindent
On the other hand, if you use just the single initial assignment,
@code{int *my_int_ptr = 2;}, the program will try to fill the contents
of the memory location pointed to by @code{my_int_ptr} with the value 2.
Since @code{my_int_ptr} is filled with garbage, it can be @emph{any}
address.  This means that the value 2 might be stored anywhere.
anywhere, and if it overwrites something important,
it may cause the program to crash.

The compiler will warn you against this.  Heed the warning!




@node Variable parameters, Questions for Chapter 9, Pointers and initialization, Pointers
@section Variable parameters

@cindex Variable parameters
@cindex Passing by reference
@cindex Parameters, variable
@cindex Reference, passing by

Now that you know something about pointers, we can discuss variable
parameters and passing by reference in more detail.  (@xref{Parameters},
to refresh your memory on this topic.)

There are two main ways to return information from a function.  The most
common way uses the @code{return} command.  However, @code{return} can
only pass one value at a time back to the calling function.  The second
way to return information to a function uses variable parameters.
Variable parameters (``passing by reference'') enable you to pass back
an arbitrary number of values, as in the following example:

@smallexample
#include <stdio.h>

int main();
void get_values (int *, int *);

int main()
@{
  int num1, num2;
  get_values (&num1, &num2);

  printf ("num1 = %d and num2 = %d\n\n", num1, num2);

  return 0;
@}


void get_values (int *num_ptr1, int *num_ptr2)
@{
  *num_ptr1 = 10;
  *num_ptr2 = 20;
@}
@end smallexample

@noindent
The output from this program reads:

@smallexample
num1 = 10 and num2 = 20
@end smallexample

@noindent
Note that we do use a @code{return} command in this example --- in the
@code{main} function.  Remember, @code{main} must always be declared of
type @code{int} and should always return an integer
value. (@xref{Style}.)

When you use value parameters, the formal parameters (the parameters in
the function being called) are mere copies of the actual parameters (the
parameters in the function call).  When you use variable parameters, on
the other hand, you are passing the addresses of the variables
themselves.  Therefore, in the program above, it is not copies of the
variables @code{num1} and @code{num2} that are passed to
@code{get_values}, but the addresses of their actual memory locations.
This information can be used to alter the variables directly, and to
return the new values.



@menu
* Passing pointers correctly::  
* Another variable parameter example::  
@end menu

@node Passing pointers correctly, Another variable parameter example, Variable parameters, Variable parameters
@subsection Passing pointers correctly

You might be wondering why @code{main} calls the function
@code{get_values} above with ampersands before the parameters ---

@smallexample
get_values (&num1, &num2);
@end smallexample

@noindent
--- while the function itself is defined with asterisks before its
parameters:

@smallexample
void get_values (int *num_ptr1, int *num_ptr2)
@{
  *num_ptr1 = 10;
  *num_ptr2 = 20;
@}
@end smallexample

@noindent
Think carefully for a moment about what is happening in these fragments
of code. The variables @code{num1} and @code{num2} in @code{main} are
ordinary integers, so when @code{main} prefixes them with ampersands
(@code{&}) while passing them to @code{get_values}, it is really passing
integer pointers.  Remember, @code{&num1} should be read as ``the
address of the variable @code{num1}''.

The code reads like this:

@smallexample
@group
get_values (&num1, &num2);

@r{``Evaluate the function @code{get_values}, passing to it the
addresses at which the variables @code{num1} and @code{num2} are stored.''.}
@end group
@end smallexample

The function @code{get_values} is defined like this:

@smallexample
@group
void get_values (int *num_ptr1, int *num_ptr2)

@r{``Define the function @code{get_values}.  It returns a @code{void}
value (so it operates only via ``side effects'' on the variable
parameters it is passed).  It takes two parameters, both of type
@code{int *}.  The first parameter is called @code{num_ptr1} and is a
pointer to an integer value, and the second parameter is called
@code{num_ptr2} and is also a pointer to an integer value.  When this
function is called, it must be passed the addresses of variables, not the
variables themselves.''}
@end group
@end smallexample

Remember that declaring a variable with an asterisk (@code{*}) before it
means ``declare this variable to be a pointer'', so the formal
parameters of @code{get_values} are integer pointers.  The parameters
@emph{must} be declared this way, because the @code{main} function sends
the addresses of @code{num1} and @code{num2} --- that is, by the time
the @code{get_values} function receives the parameters, they are
@emph{already} pointers --- hence their names in @code{get_values}:
@code{num_ptr1} and @code{num_ptr2}, rather than @code{num1} and
@code{num2}.

In effect, we are ``matching up'' the data types of @code{num1} and
@code{num2} with those of @code{num_ptr1} and @code{num_ptr2},
respectively, when we prefix @code{num1} and @code{num2} with ampersands
while passing them, and prefix @code{num_ptr1} and @code{num_ptr2} with
asterisks in the parameter list of the function @code{get_values}. We do
not have to write @code{num_ptr1 = &num1;} and @code{num_ptr2 = &num2;}
--- the calling convention does that for us.

@cindex Actual parameters, passing as pointers
@cindex Passing actual parameters as pointers
@strong{Important!} This is a general rule in C: when you pass actual
parameters as pointers using ampersands (e.g. @code{&num1}, ``the
address of the variable @code{num1}''), you must use asterisks to
declare as pointers the corresponding formal parameters in the function
to which you pass them, (e.g. @code{int *num_ptr1}, ``the contents of
the location pointed to by @code{num_ptr1}'').





@node Another variable parameter example,  , Passing pointers correctly, Variable parameters
@subsection Another variable parameter example

@cindex Variable parameters
@cindex Parameters, variable
There is nothing mysterious about pointers, but they can be tricky.
Here is another example.

Notice that the pointers in both this example and the example above are
dereferenced with asterisks before they are used (for instance, when the
contents of the location pointed to by @code{height_ptr} are multiplied
by the integer @code{hscale} with the line @code{*height_ptr =
*height_ptr * hscale;} in the function @code{scale_dimensions} below).

@smallexample
#include <stdio.h>

int main();
void scale_dimensions (int *, int *);

/* Scale some measurements */

int main()
@{
  int height,width;

  height = 4;
  width = 5;

  scale_dimensions (&height, &width);

  printf ("Scaled height = %d\n", height);
  printf ("Scaled width = %d\n", width);

  return 0;
@}


void scale_dimensions (int *height_ptr, int *width_ptr)
@{
  int hscale = 3;        /* scale factors */
  int wscale = 5;

  *height_ptr = *height_ptr * hscale;
  *width_ptr = *width_ptr * wscale;
@}
@end smallexample



@node Questions for Chapter 9,  , Variable parameters, Pointers
@section Questions for Chapter 9

@enumerate
@item
What is a pointer?

@item
How is a variable declared to be a pointer?

@item
What data types can pointers point to?

@item
Write a statement which converts a pointer to an integer into a pointer
to a @code{double} type.

@item
Why is it incorrect to write @code{float *number = 2.65;} ?

@end enumerate




@menu
* if::
* if... else...::
* Nested if statements::
* The ?...:... operator::
* The switch statement::
* Example 15::
* Questions for Chapter 10::
@end menu


@c CHAPTER 10
@node Decisions, Loops, Pointers, Top
@chapter Decisions

@emph{Testing and Branching.  Making conditions.}

@cindex Decisions
Until now, our code examples have been linear: control has flowed in one
direction from start to finish.  In this chapter, we will examine ways to
enable code to make decisions and to choose among options.  You will
learn how to program code that will function in situations similar to
the following:

@itemize @bullet
@item If the user hits the jackpot, print a message to
     say so: @samp{You've won!}

@item  If a bank balance is positive, then print @samp{C} for ``credit'';
     otherwise, print @samp{D} for ``debit''.

@item If the user has typed in one of five choices, then do
     something that corresponds to the choice, otherwise display an
     error message.
@end itemize

In the first case there is a simple ``do or don't'' choice.  In the
second case, there are two choices.  The final case contains several
possibilities.

C offers four main ways of coding decisions like the ones above.  They
are listed below.

@findex if @r{command}
@findex else @r{command}
@findex ? @r{operator}
@findex switch @r{command}
@table @code

@item if@dots{}
@smallexample
if (@var{condition})
@{
  @var{do something}
@}
@end smallexample


@item if@dots{}else@dots{}
@smallexample
if (@var{condition})
@{
  @var{do something}
@}
else
@{
  @var{do something else}
@}
@end smallexample


@item @dots{}?@dots{}:@dots{}
@smallexample
(@var{condition}) ? @var{do something} : @var{do something else};
@end smallexample


@item switch
@smallexample
switch (@var{condition})
@{
  case @var{first case} : @var{do first thing}
  case @var{second case} : @var{do second thing}
  case @var{third case} : @var{do third thing}
@}
@end smallexample
@end table


@menu
* if::                          
* if... else...::               
* Nested if statements::        
* The question mark operator::  
* The switch statement::        
* Example 15::                  
* Questions for Chapter 10::    
@end menu




@node if, if... else..., Decisions, Decisions
@section @code{if}

@findex if @r{command}

The first form of the @code{if} statement is an all-or-nothing
choice: if some condition is satisfied, do something; otherwise,
do nothing.  For example:

@smallexample
if (@var{condition}) @var{statement};
@end smallexample


@noindent
or

@smallexample
if (@var{condition})
@{
  @var{compound statement}
@}
@end smallexample

In the second example, instead of a single statement, a whole block of
statements is executed.  In fact, wherever you can place a single
statement in C, you can place a @dfn{compound statement} instead: a
block of statements enclosed by curly brackets.

A @dfn{condition} is usually an expression that makes some sort of
comparison.  It must be either true or false, and it must be enclosed in
parentheses: @samp{(@dots{})}.  If the condition is true, then the
statement or compound statement following the condition will be
executed; otherwise, it will be ignored.  For example:

@smallexample
if (my_num == 0)
@{
  printf ("The number is zero.\n");
@}

if (my_num > 0)
@{
  printf ("The number is positive.\n");
@}

if (my_num < 0)
@{
  printf ("The number is negative.\n");
@}
@end smallexample

@noindent
The same code could be written more compactly
in the following way:

@smallexample
if (my_num == 0) printf ("The number is zero.\n");
if (my_num > 0) printf ("The number is positive.\n");
if (my_num < 0) printf ("The number is negative.\n");
@end smallexample

It is often a good idea stylistically to use curly brackets in an
@code{if} statement.  It is no less efficient from the compiler's
viewpoint, and sometimes you will want to include more statements
later.  It also makes @code{if} statements stand out clearly in the
code.  However, curly brackets make no sense for short statements such as
the following:

@smallexample
if (my_num == 0) my_num++;
@end smallexample

The @code{if} command by itself permits only limited decisions.  With the
addition of @code{else} in the next section, however, @code{if} becomes
much more flexible.


@node if... else..., Nested if statements, if, Decisions
@section @code{if@dots{} else@dots{}}

Let's review the basic form of the @code{if@dots{} else@dots{}}
statement:

@smallexample
if (@var{condition})
@{
  @var{compound statement}
@}
else
@{
  @var{compound statement}
@}
@end smallexample

As with the bare @code{if} statement, there is a simplified version of
the @code{if@dots{} else@dots{}} statement without code blocks:

@smallexample
if (@var{condition}) @var{statement} else @var{statement};
@end smallexample

When the @code{if@dots{} else@dots{}} is executed, the condition in
parentheses is evaluated.  If it is true, then the first statement or
code block is executed; otherwise, the second statement or code block is
executed.  This can save unnecessary tests and make a program more
efficient:

@smallexample
if (my_num > 0)
@{
  printf ("The number is positive.");
@}
else
@{
  printf ("The number is zero or negative.");
@}
@end smallexample

@noindent
It is not necessary to test @code{my_num} in the second block because
that block is not executed unless @code{my_num} is @emph{not} greater
than zero.




@node Nested if statements, The question mark operator, if... else..., Decisions
@section Nested @code{if} statements

@findex if @r{command}
@cindex @code{if} statements, nested
@cindex Nested @code{if} statements
Consider the following two code examples.  Their purposes are exactly
the same.

@smallexample
int my_num = 3;

if ((my_num > 2) && (my_num < 4))
@{
  printf ("my_num is three");
@}
@end smallexample

@noindent
or:

@smallexample
int my_num =3;

if (my_num > 2)
@{
  if (my_num < 4)
  @{
    printf ("my_num is three");
  @}
@}
@end smallexample


@noindent
Both of these code examples have the same result, but they arrive at it
in different ways.  The first example, when translated into English,
might read, ``If @code{my_num} is greater than two and @code{my_num} is
less than four (and @code{my_num} is an integer), then @code{my_num} has
to be three.''  The second method is more complicated.  In English, it
can be read, ``If @code{my_num} is greater than two, do what is in the
first code block.  Inside it, @code{my_num} is always greater than two;
otherwise the program would never have arrived there.  Now, if
@code{my_num} is also less than four, then do what is inside the second
code block.  Inside that block, @code{my_num} is always less than
four.  We also know it is more than two, since the whole of the second
test happens inside the block where that's true.  So, assuming
@code{my_num} is an integer, it must be three.''

@cindex Compound decisions
@cindex Decisions, compound
In short, there are two ways of making compound decisions in C.  You make
nested tests, or you can use the comparison operators @code{&&},
@code{||}, and so on.  In situations where sequences of comparison
operators become too complex, nested tests are often a more attractive
option.

Consider the following example:

@smallexample
if (i > 2)
@{
  /* i is greater than 2 here! */
@}
else
@{
  /* i is less than or equal to 2 here! */
@}
@end smallexample
@noindent

The code blocks in this example provide ``safe zones'' wherein you can
rest assured that certain conditions hold.  This enables you to think and
code in a structured way.

You can nest @code{if} statements in multiple levels, as in the
following example:


@smallexample
#include <stdio.h>

int main ()
@{
  int grade;

  printf("Type in your grade: ");
  scanf ("%d", &grade);

  if (grade < 10)
  @{
    printf ("Man, you're lame!  Just go away.\n");
  @}
  else
  @{
    if (grade < 65)
    @{
      printf ("You failed.\n");
    @}
    else
    @{
      printf ("You passed!\n");
      if (grade >= 90)
      @{
        printf ("And you got an A!\n");
      @}
      else
      @{
        printf ("But you didn't get an A.  Sorry.\n");
      @}
    @}
  @}
  return 0;
@}
@end smallexample


@node The question mark operator, The switch statement, Nested if statements, Decisions
@section The @code{?}@dots{}@code{:}@dots{} operator

@findex ? @r{operator}

The @code{?}@dots{}@code{:}@dots{} operator is a sort of shorthand
@code{if}@dots{}@code{else}@dots{} statement.  Because it is a little
cryptic, it is not often used, but the basic form is as follows:

@smallexample
(@var{condition}) ?  @var{expression1} : @var{expression2};
@end smallexample

The program evaluates @var{condition}.  If it is true (not zero), then
@var{expression1} is returned; otherwise, @var{expression2} is returned.

For example, in the short program below, the line
@code{bas = (foo > bar) ? foo : bar;} assigns @code{foo} to @code{bas}
if @code{foo} is greater than @code{bar}; otherwise, it assigns
@code{bar} to @code{bas}.

@smallexample
#include <stdio.h>

int main()
@{
  int foo = 10;
  int bar = 50;
  int bas;

  bas = (foo > bar) ? foo : bar;

  printf("bas = %d\n\n", bas);

  return 0;
@}
@end smallexample

@noindent
The program will print @samp{bas = 50} as a result.




@node The switch statement, Example 15, The question mark operator, Decisions
@section The @code{switch} statement

@findex switch @r{command}

The @code{switch} construction is another way of making decisions in C
code.  It is very flexible, but only tests for integer and character
values.  It has the following general form:


@smallexample
switch (@var{integer or character expression})
@{
  case @var{constant1} : @var{statement1};
  break;          /* optional */

  case @var{constant2} : @var{statement2};
  break;          /* optional */

  case @var{constant3} : @var{statement3};
  break;          /* optional */
  @dots{}
@}
@end smallexample

@cindex Breaking out of @code{switch} statement
@cindex @code{switch} statement, breaking out of
@findex break @r{command}
@noindent
The integer or character expression in the parentheses is evaluated, and
the program checks whether it matches one of the constants in the
various @dfn{cases} listed.  If there is a match, the statement following
that case will be executed, and execution will continue until either a
@code{break} statement or the closing curly bracket of the entire
@code{switch} statement is encountered.

One of the cases is called @code{default}.  Statements after the
@code{default} case are executed when none of the other cases are
satisfied.  You only need a default case if you are not sure you are
covering every case with the ones you list.

Here is an example program that uses the @code{switch} statement to
translate decimal digits into Morse code:

@node Example 15, Questions for Chapter 10, The switch statement, Decisions
@section Example Listing

@smallexample
#include <stdio.h>

int main ();
void morse (int);


int main ()
@{
  int digit;

  printf ("Enter any digit in the range 0 to 9: ");
  scanf ("%d", &digit);

  if ((digit < 0) || (digit > 9))
  @{
    printf ("Your number was not in the range 0 to 9.\n");
  @}
  else
  @{
    printf ("The Morse code of that digit is ");
    morse (digit);
  @}
  return 0;
@}


void morse (int digit)        /* print out Morse code */
@{
  switch (digit)
  @{
    case 0 : printf ("-----");
      break;
    case 1 : printf (".----");
      break;
    case 2 : printf ("..---");
      break;
    case 3 : printf ("...--");
      break;
    case 4 : printf ("....-");
      break;
    case 5 : printf (".....");
      break;
    case 6 : printf ("-....");
      break;
    case 7 : printf ("--...");
      break;
    case 8 : printf ("---..");
      break;
    case 9 : printf ("----.");
  @}
  printf ("\n\n");
@}
@end smallexample

@noindent
The @code{morse} function selects one of the @code{printf} statements
with @code{switch}, based on the integer expression @code{digit}.  After
every @code{case} in the switch, a @code{break} statement is used to
jump @code{switch} statement's closing bracket @samp{@}}.  Without
@code{break}, execution would @dfn{fall through} to the next case and
execute its @code{printf} statement.

Here is an example of using @dfn{fallthrough} in a constructive way.
The function @code{yes} accepts input from the user and tests whether it
was 'y' or 'Y'.  (The @code{getchar} function is from the standard
library and reads a character of input from the terminal.  @xref{getchar}.)

@smallexample
#include <stdio.h>

int main ()
@{
  printf ("Will you join the Free Software movement? ");
  if (yes())
  @{
    printf("Great!  The price of freedom is eternal vigilance!\n\n");
  @}
  else
  @{
    printf("Too bad.  Maybe next life...\n\n");
  @}

  return 0;
@}


int yes()
@{
  switch (getchar())
  @{
    case 'y' :
    case 'Y' : return 1;
    default  : return 0;
  @}
@}
@end smallexample

@noindent
If the character is @samp{y}, then the program falls through and meets
the statement @code{return 1}.  If there were a @code{break} statement
after @code{case 'y'}, then the program would not be able to reach
@code{case 'Y'} unless an actual @samp{Y} were typed.

@findex return @r{command}
@cindex Breaking out of @code{switch} statement
@cindex @code{switch} statement, breaking out of
@strong{Note:} The @code{return} statements substitute for @code{break} in
the above code, but they do more than break out of @code{switch} ---
they break out of the whole function.  This can be a useful trick.



@node Questions for Chapter 10,  , Example 15, Decisions
@section Questions for Chapter 10

@enumerate

@item
Translate the following into good C: ``If 1 does not equal 42, print
out `Thank heavens for mathematics!' ''

@item
Write a program to get a lot of numbers from the user and print out the
maximum and minimum of those.

@item
Write an automatic teller machine program that simulates telling you
your bank balance when you enter your account number and PIN number, but
otherwise displays an error.

@item
Write a mock program for a car computer that tells you how many
kilometers to the liter you're getting when you enter how many liters of
gas you've used and how far you travelled.

@end enumerate





@c CHAPTER 11
@node Loops, Preprocessor directives, Decisions, Top
@chapter Loops

@cindex Loops

@emph{Controlling repetitive processes.  Nesting loops}

@dfn{Loops} are a kind of C construct that enable the programmer to
execute a sequence of instructions over and over, with some condition
specifying when they will stop.  There are three kinds of loop in C:

@findex while @r{command}
@findex do @dots{} while @r{command}
@findex for @r{command}
@itemize @bullet

@item
@code{while}

@item
@code{do} @dots{} @code{while}

@item
@code{for}

@end itemize

@menu
* while::                       
* do...while::                  
* for::                         
* The flexibility of for::      
* Terminating and speeding loops::  
* Nested loops::                
* Questions for Chapter 11::    
@end menu

@node while, do...while, Loops, Loops
@section @code{while}

The simplest of the three is the @code{while} loop.  It looks like this:

@smallexample
while (@var{condition})
@{
  @var{do something}
@}
@end smallexample

The condition (for example, @code{(a > b)}) is evaluated every time the
loop is executed.  If the condition is true, then statements in the
curly brackets are executed.  If the condition is false, then those
statements are ignored, and the @code{while} loop ends.  The program then
executes the next statement in the program.

The condition comes at the start of the loop, so it is tested at the
start of every @dfn{pass}, or time through the loop.  If the condition is
false before the loop has been executed even once, then the statements
inside the curly brackets will never be executed.  (@xref{do...while},
for an example of a loop construction where this is not true.)

The following example prompts the user to type in a line of text, and
then counts all the spaces in the line.  The loop terminates when the
user hits the @key{RET} key and then prints out the number of
spaces.  (@xref{getchar}, for more information on the
standard library @code{getchar} function.)

@smallexample
#include <stdio.h>

int main()
@{
  char ch;
  int count = 0;

  printf ("Type in a line of text.\n");

  while ((ch = getchar()) != '\n')
  @{
    if (ch == ' ')
    @{
      count++;
    @}
  @}

  printf ("Number of spaces = %d.\n\n", count);
  return 0;
@}
@end smallexample

@node do...while, for, while, Loops
@section @code{do}@dots{}@code{while}

The @code{do}..@code{while} loop has the form:

@smallexample
do
@{
  @var{do something}
@}
while (@var{condition});
@end smallexample

@cindex Difference between @code{while} and @code{do}
@cindex @code{while} and @code{do}, difference between
@cindex @code{do} and @code{while}, difference between
Notice that the condition is at the @emph{end} of this loop.  This means
that a @code{do..while} loop will always be executed at least once,
before the test is made to determine whether it should continue.  This is
the chief difference between @code{while} and @code{do}@dots{}@code{while}.

The following program accepts a line of input from the user.  If the line
contains a string of characters delimited with double quotation marks,
such as @samp{"Hello!"}, the program prints the string, with quotation
marks.  For example, if the user types in the following string:

@smallexample
I walked into a red sandstone building. "Oof!" [Careful, Nick!]
@end smallexample

@noindent
@dots{}then the program will print the following string:

@smallexample
"Oof!"
@end smallexample

@noindent
If the line contains only one double quotation mark, then the program
will display an error, and if it contains no double quotation marks,
the program will print nothing.

Notice that the @code{do}@dots{}@code{while} loop in @code{main} waits
to detect a linefeed character (@code{\n}), while the one in
@code{get_substring} looks for a double quotation mark (@samp{"}), but
checks for a linefeed in the @dfn{loop body}, or main code block of the
loop, so that it can exit the loop if the user entered a linefeed
prematurely (before the second @samp{"}).

This is one of the more complex examples we have examined so far, and
you might find it useful to @dfn{trace} the code, or follow through
it step by step.

@smallexample
#include <stdio.h>

int main();
void get_substring();


int main()
@{
  char ch;

  printf ("Enter a string with a quoted substring:\n\n");

  do
  @{
    ch = getchar();
    if (ch == '"')
    @{
      putchar(ch);
      get_substring();
    @}
  @}
  while (ch != '\n');

  return 0;
@}


void get_substring()
@{
  char ch;

  do
  @{
    ch = getchar();
    putchar(ch);

    if (ch == '\n')
    @{
      printf ("\nString was not closed ");
      printf ("before end of line.\n");
      break;
    @}
  @}
  while (ch != '"');

  printf ("\n\n");
@}
@end smallexample





@node for, The flexibility of for, do...while, Loops
@section @code{for}

@findex for @r{command}

The most complex loop in C is the @code{for} loop.  The @code{for}
construct, as it was developed in earlier computer languages such as
BASIC and Pascal, was intended to behave in the following way:

@quotation

For all values of @var{variable} from @var{value1} to @var{value2}, in
steps of @code{value3}, repeat the following sequence of commands@dots{}

@end quotation

The @code{for} loop in C is much more versatile than its counterpart in
those earlier languages.  The @code{for} loop looks like this in C:

@smallexample
for (@var{initialization}; @var{condition}; @var{increment})
@{
  @var{do something};
@}
@end smallexample

@noindent
In normal usage, these expressions have the following significance.

@itemize @bullet

@item @var{initialization}

This is an expression that initializes the @dfn{control variable}, or
the variable tested in the @var{condition} part of the @code{for}
statement.  (Sometimes this variable is called the loop's
@dfn{index}.) The @var{initialization} part is only carried out once
before the start of the loop.  Example: @code{index = 1}.

@item @var{condition}

This is a conditional expression that is tested every time through the
loop, just as in a @code{while} loop.  It is evaluated at the
@emph{beginning} of every loop, and the loop is only executed if the
expression is true.  Example: @code{index <= 20}.

@item @var{increment}

This is an expression that is used to alter the value of the control
variable.  In earlier languages, this usually meant adding or subtracting
1 from the variable.  In C, it can be almost anything.  Examples:
@code{index++}, @code{index *= 20}, or @code{index /= 2.3}.

@end itemize

@noindent
For example, the following @code{for} loop prints out the integers from
1 to 10:

@smallexample
int my_int;

for (my_int = 1; my_int <= 10; my_int++)
@{
  printf ("%d ", my_int);
  printf("\n");
@}
@end smallexample

The following example prints out all prime numbers between 1 and the
macro value @code{MAX_INT}.  (A prime numbers is a number that cannot be
divided by any number except 1 and itself without leaving a remainder.)
This program checks whether a number is a prime by dividing it by all
smaller integers up to half its size.  (@xref{Preprocessor directives},
for more information on macros.)

@smallexample
#include <stdio.h>

#define MAX_INT  500
#define TRUE      1
#define FALSE     0

int main ()
@{
  int poss_prime;

  for (poss_prime = 2; poss_prime <= MAX_INT; poss_prime++)
  @{
    if (prime(poss_prime))
    @{
      printf ("%d ", poss_prime);
    @}
  @}
  printf("\n\n");
  return 0;
@}


prime (int poss_prime)       /* check whether poss_prime is prime */
@{
  int poss_factor;

  for (poss_factor = 2; poss_factor <= poss_prime/2; poss_factor++)
  @{
    if (poss_prime % poss_factor == 0)
    @{
      return (FALSE);
    @}
  @}

  return (TRUE);
@}
@end smallexample

@noindent
The program should print the following sequence of integers:

@smallexample
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191
193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283
293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401
409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499
@end smallexample




@node The flexibility of for, Terminating and speeding loops, for, Loops
@section The flexibility of @code{for}

@findex for @r{command}
@cindex Flexibility of @code{for} command
@cindex @code{for} command, flexibility of 

As mentioned above, C's @code{for} construct is quite versatile.  You can
use almost any statement you like for its @var{initialization},
@var{condition}, and @var{increment} parts, including an empty
statement.  For example, omitting the @var{initialization} and
@var{increment} parts creates what is essentially a @code{while} loop:

@smallexample
int my_int = 1;

for ( ; my_int <= 20; )
@{
  printf ("%d ", my_int);
  my_int++;
@}
@end smallexample

Omitting the @var{condition} part as well produces an @dfn{infinite
loop}, or loop that never ends:

@smallexample
for ( ; ; )
@{
  printf("Aleph Null bottles of beer on the wall...\n");
@}
@end smallexample

@noindent
You can break out of an ``infinite loop'' with the @code{break} or
@code{return} commands.  (@xref{Terminating and speeding loops}.)

Consider the following loop:

@smallexample
for (my_int = 2; my_int <= 1000; my_int = my_int * my_int)
@{
  printf ("%d ", my_int);
@}
@end smallexample

@noindent
This loop begins with 2, and each time through the loop, @code{my_int}
is squared.

Here's another odd @code{for} loop:

@smallexample
char ch;

for (ch = '*'; ch != '\n'; ch = getchar())
@{
  /* do something */
@}
@end smallexample

@noindent
This loop starts off by initializing @code{ch} with an asterisk.  It
checks that @code{ch} is not a linefeed character (which it isn't, the
first time through), then reads a new value of @code{ch} with the
library function @code{getchar} and executes the code inside the curly
brackets.  When it detects a line feed, the loop ends.

It is also possible to combine several @var{increment} parts in a
@code{for} loop using the comma operator @code{,}.  (@xref{The comma
operator}, for more information.)

@smallexample
#include <stdio.h>

int main()
@{
  int up, down;

  for (up = 0, down=10; up < down; up++, down--)
  @{
    printf("up = %d, down= %d\n",up,down);
  @}

  return 0;
@}
@end smallexample

@noindent
The example above will produce the following output:

@smallexample
up = 0, down= 10
up = 1, down= 9
up = 2, down= 8
up = 3, down= 7
up = 4, down= 6
@end smallexample

One feature of the @code{for} loop that unnerves some programmers is
that even the value of the loop's conditional expression can be altered
from within the loop itself:

@smallexample
int index, number = 20;

for (index = 0; index <= number; index++)
@{
  if (index == 9)
  @{
    number = 30;
  @}
@}
@end smallexample

@noindent
In many languages, this technique is syntactically forbidden.  Not so in the
flexible language C.  It is rarely a good idea, however, because it can make your
code confusing and hard to maintain.



@node Terminating and speeding loops, Nested loops, The flexibility of for, Loops
@section Terminating and speeding loops

@cindex Terminating loops
@cindex Speeding loops
@cindex Loops, terminating
@cindex Loops, speeding

C provides simple ways of terminating or speeding up any of the three
loops we have discussed, whether or not it has run its course.  The
three main commands to do so are @code{break}, @code{return}, and
@code{continue}.

@menu
* Terminating loops with break::  
* Terminating loops with return::  
* Speeding loops with continue::  
@end menu

@node Terminating loops with break, Terminating loops with return, Terminating and speeding loops, Terminating and speeding loops
@subsection Terminating loops with @code{break}

@cindex Terminating loops with @code{break}
@cindex Loops, terminating with @code{break}
@findex break @r{command}
@cindex @code{break}, terminating loops with

The usual statement to terminate a loop is the same statement that is
used to jump out of @code{switch} statements:

@smallexample
break;
@end smallexample

@noindent
If this statement is encountered within a loop, the loop will end
immediately.  For instance, here is an inefficient way of assigning
12 to @code{my_int}:

@smallexample
for (my_int = 1; my_int <= 100; my_int++)
@{
  if (my_int == 12)
  @{
    break;
  @}
@}

printf("my_int = %d\n\n", my_int);
@end smallexample


@node Terminating loops with return, Speeding loops with continue, Terminating loops with break, Terminating and speeding loops
@subsection Terminating loops with @code{return}

@cindex Terminating loops with @code{return}
@cindex Loops, terminating with @code{return}
@findex return @r{command}
@cindex @code{return}, terminating loops with

Suppose that a program is in the middle of a loop (or some nested loops)
in a complex function, and suddenly the function finds its answer.  This
is where the @code{return} statement comes in handy.  The @code{return}
command will jump out of any number of loops and pass the value back to
the calling function without having to finish the loops or the rest of
the function.  (@xref{Nested loops}, for clarification of the idea of
placing one loop inside another.)

Example:

@smallexample
#include <stdio.h>

int main()
@{
  printf ("%d\n\n", returner(5, 10));
  printf ("%d\n\n", returner(5, 5000));
  return 0;
@}


int returner (int foo, int bar)
@{
  while (foo <= 1000)
  @{
    if (foo > bar)
    @{
      return (foo);
    @}

    foo++;
  @}

  return foo;
@}
@end smallexample

@noindent
The function @code{returner} contains a @code{while} loop that
increments the variable @code{foo} and tests it against a value of
1000.  However, if at any point the value of @code{foo} exceeds
the value of the variable @code{bar}, the function will exit the loop,
immediately returning the value of @code{foo} to the calling function.
Otherwise, when @code{foo} reaches 1000, the function will
increment @code{foo} one more time and return it to @code{main}.

Because of the values it passes to @code{returner}, the @code{main}
function will first print a value of 11, then 1001.  Can you see why?



@node Speeding loops with continue,  , Terminating loops with return, Terminating and speeding loops
@subsection Speeding loops with @code{continue}

@cindex Speeding loops
@cindex Optimizing loops
@cindex @code{continue}, speeding loops with
@cindex @code{continue}, optimizing loops with

Instead of terminating a loop, you might want to speed it to its next
pass, perhaps to avoid executing irrelevant statements.  To do so, you
should use the @code{continue} statement.  When a @code{continue}
statement is encountered, the program will skip the rest of the
loop's code block and jump straight to the start of the next pass
through the loop.

Here is an example that uses the @code{continue} statement to avoid
division by zero (which causes a run-time error):

@smallexample
for (my_int = -10; my_int <= 10; my_int++)
@{
  if (my_int == 0)
  @{
    continue;
  @}

  printf ("%d", 20/i);
@}
@end smallexample



@node Nested loops, Questions for Chapter 11, Terminating and speeding loops, Loops
@section Nested loops

@cindex Nested loops
@cindex Loops, nested
@cindex Multidimensional arrays
@cindex Arrays, multidimensional

Just as decisions can be nested, so can loops; that is, you can place
loops inside other loops.  This can be useful, for example, when you are
coding multidimensional arrays.  (@xref{Arrays}.)

The example below prints a square of asterisks by nesting a
@code{printf} command inside an @dfn{inner loop}, which is itself nested
inside an @dfn{outer loop}.

Any kind of loop can be nested.  For example, the code below could have
been written with @code{while} loops instead of @code{for} loops:

@smallexample
#include <stdio.h>

#define SIZE 5

int main()
@{
  int square_y, square_x;

  printf ("\n");

  for (square_y = 1; square_y <= SIZE; square_y++)
  @{
    for (square_x = 1; square_x <= SIZE; square_x++)
    @{
      printf("*");
    @}
    printf ("\n");
  @}

  printf ("\n");
  return 0;
@}
@end smallexample

@noindent
The output of the above code looks like this:

@smallexample
*****
*****
*****
*****
*****
@end smallexample






@node Questions for Chapter 11,  , Nested loops, Loops
@section Questions for Chapter 11

@enumerate

@item
How many kinds of loop does C offer, and what are they?

@item
When is the condition tested in each of the loops?

@item
Which of the loops is always executed at least once?

@item
Write a program that copies all input to output line by line.

@item
Write a program to get 10 numbers from the user and add them together.

@item
Rewrite the nested loops example to print a square with @code{while}
loops instead of @code{for} loops.

@end enumerate



@c CHAPTER 12
@node Preprocessor directives, Libraries, Loops, Top
@chapter Preprocessor directives

@emph{Making programming versatile.}

@cindex Preprocessor
@cindex Preprocessor directives
@cindex Directives, preprocessor

GCC, the GNU Compiler Collection, contains a C @dfn{preprocessor}.  A
preprocessor is a program that examines C code before it is compiled and
manipulates it in various ways.  There are two main uses of a
preprocessor.  One is to include external files, such as header files.
The other is to define @dfn{macros}, which are names (possibly with
arguments) that are expanded by the preprocessor into pieces of text or
C code.  Macros that are expanded into text are usually displayed to the
user, but macros that are expanded into C code are executed with the
rest of the C code that surrounds them.

@menu
* A few directives::            
* Macros::                      
* Extended macro example::      
* Questions 12::                
@end menu

@node A few directives, Macros, Preprocessor directives, Preprocessor directives
@section A few directives

@cindex Preprocessor directives
@cindex Directives, preprocessor

All preprocessor @code{directives}, or commands, are preceded by a hash
mark (@samp{#}).  One example you have already seen in previous chapters
is the @code{#include} directive:

@findex #include @r{preprocessor directive}
@smallexample
@group
#include <stdio.h>
@end group
@end smallexample

@noindent
This directive tells the preprocessor to @dfn{include} the file
@file{stdio.h}; in other words, to treat it as though it were part of
the program text.

A file to be included may itself contain @code{#include} directives,
thus encompassing other files.  When this happens, the included
files are said to be @dfn{nested}.

Here are a few other directives:

@table @code

@findex #if @r{preprocessor directive}
@item #if @var{@dots{}} #endif
The @code{#if} directive is followed by an expression on the same line.
The lines of code between @code{#if} and @code{#endif} will be compiled
only if the expression is true.  This is called @dfn{conditional
compilation}.

@findex #else @r{preprocessor directive}
@item #else
This is part of an @code{#if}
preprocessor statement and works in the same way with @code{#if}
that the regular C @code{else} does with the regular @code{if}.

@findex #line @r{preprocessor directive}
@item #line @var{constant} @var{filename}
This causes the compiler to act as though the next line is line number
@var{constant} and is part of the file @var{filename}.
Mainly used for debugging.

@findex #error @r{preprocessor directive}
@item #error
This forces the compiler to abort.  Also intended for debugging.

@end table

Below is an example of conditional compilation.
The following code displays @samp{23} to the screen.

@smallexample
@group
#include <stdio.h>

#define CHOICE 500

int my_int = 0;

#if (CHOICE == 500)
void set_my_int()
@{
  my_int = 23;
@}
#else
void set_my_int()
@{
  my_int = 17;
@}
#endif

int main ()
@{
  set_my_int();
  printf("%d\n", my_int);

  return 0;
@}
@end group
@end smallexample



@node Macros, Extended macro example, A few directives, Preprocessor directives
@section Macros

@cindex Macros
@findex #define @r{preprocessor directive}

Macros can make long, ungainly pieces of code into short words.  The
simplest use of macros is to give constant values meaningful names. For
example:

@smallexample
@group
#define MY_PHONE 5551234
@end group
@end smallexample

This allows the programmer to use the word @code{MY_PHONE} to mean the
number 5551234.  In this case, the word is longer than the number, but
it is more meaningful and makes a program read more naturally.  It can
also be centralised in a header file, where it is easily changed; this
eliminates tedious search-and-replace procedures on code if the value
appears frequently in the code.  It has been said, with some humorous
exaggeration, that the only values that should appear ``naked'' in C
code instead of as macros or variables are 1 and 0.

The difference between defining a macro for 5551234 called
@code{MY_PHONE} and declaring a long integer variable called
@code{my_phone} with the same value is that the variable @code{my_phone}
has the value 5551234 only provisionally; it can be incremented with the
statement @code{my_phone++;}, for example.  In some sense, however, the
macro @code{MY_PHONE} @emph{is} that value, and @emph{only} that value
--- the C preprocessor simply searches through the C code before it is
compiled and replaces every instance of @code{MY_PHONE} with
@code{5551234}.  Issuing the command @code{MY_PHONE++;} is no more or
less sensible than issuing the command @code{5551234++;}.

Any piece of C code can be made into a macro, Macros are not merely
constants referred to at compile time, but are strings that are
physically replaced with their values by the preprocessor before
compilation.  For example:

@smallexample
@group
#define SUM 1 + 2 + 3 + 4
@end group
@end smallexample

@noindent
would allow @code{SUM} to be used instead of @code{1 + 2 + 3 + 4}.
Usually, this would equal 10, so that in the statement
@code{example1 = SUM + 10;}, the variable @code{example1} equals 20.
Sometimes, though, this macro will be evaluated differently; for instance,
in the statement @code{example2 = SUM * 10;}, the variable @code{example2}
equals 46, instead of 100, as you might think.  Can you figure out why?
Hint: it has to do with the order of operations.

The quotation marks in the following macro allow the string to be called
by the identifier @code{SONG} instead of typing it out over and over.
Because the text @samp{99 bottles of beer on the wall...} is enclosed
by double quotation marks, it will never be interpreted as C code.

@smallexample
@group
#define SONG "99 bottles of beer on the wall..."
@end group
@end smallexample

Macros cannot define more than a single line, but they can be used
anywhere except inside strings.  (Anything enclosed in string quotes is
assumed to be untouchable by the compiler.)

Some macros are defined already in the file @file{stdio.h}, for
example, @code{NULL} (the value 0).


There are a few more directives for macro definition besides @code{#define}:
@cindex Preprocessor directives
@cindex Directives, preprocessor

@table @code

@findex #undef @r{preprocessor directive}
@item #undef
This undefines a macro, leaving the name free.

@findex #ifdef @r{preprocessor directive}
@item #ifdef
This is a kind of @code{#if} that is followed by a macro name.  If that
macro is defined then this directive is true.  @code{#ifdef} works with @code{#else}
in the same way that @code{#if} does.

@findex #ifndef @r{preprocessor directive}
@item #ifndef
This is the opposite of @code{#ifdef}. It is also
followed by a macro name.  If that name
is not defined then this is true.  It also works with @code{#else}.

@end table

Here is a code example using some macro definition directives from this
section, and some conditional compilation directives from the last
section as well.

@cindex Preprocessor directives, example
@cindex Directives, preprocessor, example
@smallexample
@group
#include <stdio.h>

#define CHOICE 500

int my_int = 0;

#undef CHOICE
#ifdef CHOICE
void set_my_int()
@{
  my_int = 23;
@}
#else
void set_my_int()
@{
  my_int = 17;
@}
#endif

int main ()
@{
  set_my_int();
  printf("%d\n", my_int);

  return 0;
@}
@end group
@end smallexample

The above code example displays @samp{17} on the screen.

@menu
* Macro functions::             
@end menu



@node Macro functions,  , Macros, Macros
@subsection Macro functions

@cindex Macro functions
@cindex Functions, macro

Macros can also accept parameters and return values.  Macros that do so
are called @dfn{macro functions}.  To create a macro function, simply
define a macro with a parameter that has whatever name you like, such as
@code{my_val}.  For example, one macro defined in the standard libraries
is @code{abs}, which returns the absolute value of its parameter.  Let
us define our own version, @code{ABS}, below. (Note that we are defining
it in upper case not only to avoid conflicting with @code{abs}, but also
because all macros should be defined in upper case, in the GNU coding
style. @xref{Style}.)

@smallexample
@group
#define ABS(my_val) ((my_val) < 0) ? -(my_val) : (my_val)
@end group
@end smallexample

@noindent
This macro uses the @code{?@dots{}:@dots{}} command to return a positive
number no matter what value is assigned to @code{my_val} --- if
@code{my_val} is defined as a positive number, the macro returns the
same number, and if @code{my_val} is defined as a negative number, the
macro returns its negative (which will be positive).  (@xref{Decisions},
for more information on the @code{?@dots{}:@dots{}} structure.  If you
write @code{ABS(-4)}, then the preprocessor will substitute @code{-4}
for @code{my_val}; if you write @code{ABS(i)}, then the preprocessor
will substitute @code{i} for @code{my_val}, and so on.  Macros can take
more than one parameter, as in the code example below.


@cindex Macro functions, caveats
@cindex Functions, macro, caveats
One caveat: macros are substituted whole wherever they are used in a
program: this is potentially a huge amount of code repetition.  The
advantage of a macro over an actual function, however, is speed.  No
time is taken up in passing control to a new function, because control
never leaves the home function; the macro just makes the function a bit
longer.

A second caveat:  function calls cannot be used as macro parameters.  The
following code will not work:

@smallexample
@group
ABS (cos(36))
@end group
@end smallexample

Here is an example of macro functions in use:


@cindex Macro functions, example
@cindex Functions, macro, example
@smallexample
@group
#include <stdio.h>

#define STRING1          "A macro definition\n"
#define STRING2          "must be all on one line!\n"
#define EXPRESSION1      1 + 2 + 3 + 4
#define EXPRESSION2      EXPRESSION1 + 10
#define ABS(x)           ((x) < 0) ? -(x) : (x)
#define MAX(a,b)         (a < b) ?  (b) : (a)
#define BIGGEST(a,b,c)   (MAX(a,b) < c) ?  (c) : (MAX(a,b))

int main ()
@{
  printf (STRING1);
  printf (STRING2);
  printf ("%d\n", EXPRESSION1);
  printf ("%d\n", EXPRESSION2);
  printf ("%d\n", ABS(-5));
  printf ("Biggest of 1, 2, and 3 is %d\n", BIGGEST(1,2,3));

  return 0;
@}
@end group
@end smallexample

The output from the code example above is as follows:

@smallexample
@group
A macro definition
must be all on one line!
10
20
5
Biggest of 1, 2, and 3 is 3
@end group
@end smallexample




@node Extended macro example, Questions 12, Macros, Preprocessor directives
@section Extended macro example

@cindex Macro functions, example
@cindex Functions, macro, example

Here are some examples of macros taken from actual working C code, in
this case the code of GNU Emacs, the text editor of choice for many C
programmers, and in fact the editor in which this edition of the book
was written.

Most of the macro examples below define various types of integer as
having certain sizes.  It can be very useful when doing advanced C
programming to know whether a long integer, for instance, is 32 or 64
bits long on your system; if you select the wrong size, your code might
crash or might not even compile.  In the case of Emacs, the maximum size
of certain variables (how many bits they contain) affects every aspect
of its operation, even determining how long an Emacs text file can be.

Each piece of code below is prefixed with the name of the file from
which the code is taken, and followed by a note on some interesting
features of the macros defined.


@itemize

@item @file{emacs/src/config.h}

@smallexample
@group
/* Note that lisp.h uses this in a preprocessor conditional, so it
   would not work to use sizeof.  That being so, we do all of them
   without sizeof, for uniformity's sake.  */
#ifndef BITS_PER_INT
#define BITS_PER_INT 32
#endif

#ifndef BITS_PER_LONG
#ifdef _LP64
#define BITS_PER_LONG 64
#else
#define BITS_PER_LONG 32
#endif
#endif
@end group
@end smallexample

In the middle of this set of macros, from @file{config.h}, the Emacs
programmer used the characters @samp{/*} and @samp{*/} to create an
ordinary C comment.  C comments can be interspersed with macros freely.

The macro @code{BITS_PER_INT} is defined here to be 32 (but only if it
is not already defined, thanks to the @code{#ifndef} directive). The
Emacs code will then treat integers as having 32 bits.  (@xref{Integer
variables}.)

The second chunk of macro code in this example checks to see whether
@code{BITS_PER_LONG} is defined.  If it is not, but @code{_LP64} is
defined, it defines @code{BITS_PER_LONG} to be 64, so that all long
integers will be treated as having 64 bits.  (@code{_LP64} is a GCC
macro that is defined on 64-bit systems.  It stands for ``longs and
pointers are 64 bits''.)  If @code{_LP64} is @emph{not} present, the
code assumes it is on a 32-bit system and defines @code{BITS_PER_LONG}
to be 32.


@item @file{emacs/src/lisp.h}

@smallexample
@group
/* These are default choices for the types to use.  */
#ifdef _LP64
#ifndef EMACS_INT
#define EMACS_INT long
#define BITS_PER_EMACS_INT BITS_PER_LONG
#endif
#ifndef EMACS_UINT
#define EMACS_UINT unsigned long
#endif
#else /* not _LP64 */
#ifndef EMACS_INT
#define EMACS_INT int
#define BITS_PER_EMACS_INT BITS_PER_INT
#endif
#ifndef EMACS_UINT
#define EMACS_UINT unsigned int
#endif
#endif
@end group
@end smallexample

This set of macros, from @file{lisp.h}, again checks to see
whether @code{_LP64} is defined.  If it is, it defines @code{EMACS_INT}
as @code{long} (if it is not already defined), and
@code{BITS_PER_EMACS_INT} to be the same as @code{BITS_PER_LONG}, which
was defined in @file{config.h}, above.  It then defines
@code{EMACS_UINT} to be an @code{unsigned long}, if it is not already
defined.

If @code{_LP64} is @emph{not} defined, it is assumed we are on a 32-bit
system.  @code{EMACS_INT} is defined to be an @code{int} if it is not
already defined, and @code{EMACS_UINT} is defined to be an
@code{unsigned int} if it is not already defined.

Again, note that the programmer has freely interspersed a comment with
the preprocessor code.


@item @file{emacs/src/lisp.h}

@smallexample
@group
/* These values are overridden by the m- file on some machines.  */
#ifndef VALBITS
#define VALBITS (BITS_PER_EMACS_INT - 4)
#endif
@end group
@end smallexample

Here is another example from @file{lisp.h}.  The macro @code{VALBITS},
which defines another size of integer internal to Emacs, is defined as
four less than @code{BITS_PER_EMACS_INT} --- that is, 60 on 64-bit systems,
and 28 on 32-bit systems.

@item @file{emacs/src/lisp.h}

@smallexample
@group
#ifndef XINT   /* Some machines need to do this differently.  */
#define XINT(a) ((EMACS_INT) (((a) << (BITS_PER_EMACS_INT - VALBITS)) \
                                   >> (BITS_PER_EMACS_INT - VALBITS)))
#endif
@end group
@end smallexample

The interesting feature of the @code{XINT} macro above is not only that
it is a function, but that it is broken across multiple lines with the
backslash character (@samp{\}).  The GCC preprocessor simply deletes the
backslash, deletes the preceding whitespace from the next line, and
appends it where the backslash was.  In this way, it is possible to
treat long, multi-line macros as though they are actually on a single
line. (@xref{Advanced operators}, for more information on the the
advanced operators @code{<<} and @code{>>}.)

@end itemize


@node Questions 12,  , Extended macro example, Preprocessor directives
@section Questions

@enumerate

@item
Define a macro called @code{BIRTHDAY} which equals the day of the
month upon which your birthday falls.

@item
Write an instruction to the preprocessor to include the math
library @file{math.h}.

@item
A macro is always a number.  True or false?

@end enumerate



@c CHAPTER 13
@node Libraries, Arrays, Preprocessor directives, Top
@chapter Libraries

@emph{Plug-in C expansions.  Header files.}

@cindex Libraries

The core of the C language is small and simple, but special
functionality is provided in the form of @dfn{external libraries} of
ready-made functions.  Standardized libraries make C code extremely
@dfn{portable}, or easy to compile on many different computers.

Libraries are files of ready-compiled code that the compiler merges, or
@dfn{links}, with a C program during compilation.  For example, there
are libraries of mathematical functions, string handling functions, and
input/output functions.  Indeed, most of the facilities C offers are
provided as libraries.

Some libraries are provided for you.  You can also make your own, but to
do so, you will need to know how GNU builds libraries.  We will discuss
that later. (@xref{Building a library}.)

Most C programs include at least one library.  You need to ensure both
that the library is linked to your program and that its header files are
included in your program.

@pindex glibc @r{library}
The standard C library, or @file{glibc}, is linked automatically with
every program, but header files are never included automatically, so you
must always include them yourself.  Thus, you must always include
@file{stdio.h} in your program if you intend to use the standard
input/output features of C, even though @file{glibc}, which contains the
input/output routines, is linked automatically.

@cindex Libraries, linking to your code
@cindex Linking libraries to your code
Other libraries, however, are not linked automatically.  You must link
them to your program yourself.  For example, to link the math library
@file{libm.so}, type

@smallexample
@group
gcc -o @var{program_name} @var{program_name}.c -lm
@end group
@end smallexample

The command-line option to link @file{libm.so} is simply @option{-lm},
without the @samp{lib} or the @samp{.so}, or in the case of static
libraries, @samp{.a}. (@xref{Kinds of library}.)

The @option{-l} option was created because the average GNU system
already has many libraries, and more can be added at any time.  This
means that sometimes two libraries provide alternate definitions of the
same function.  With judicious use of the @option{-l} option, however,
you can usually clarify to the compiler which definition of the function
should be used.  Libraries specified earlier on the command line take
precedence over those defined later, and code from later libraries is
only linked in if it matches a @dfn{reference} (function definition,
macro, global variable, etc.) that is still undefined.  (@xref{Compiling
multiple files}, for more information.)

In summary, you must always do two things:

@itemize @bullet

@item link the library with a @option{-l} option to gcc (a step that may be
skipped in the case of @file{glibc}).

@item include the library header files (a step you must always
follow, even for @file{glibc}).

@end itemize

@menu
* Header files::                
* Kinds of library::            
* Common library functions::    
* Mathematical functions::      
* Questions for Chapter 13::    
@end menu

@node Header files, Kinds of library, Libraries, Libraries
@section Header files

@cindex Header files
@cindex Files, header

As mentioned above, libraries have @dfn{header files} that define
information to be used in conjunction with the libraries, such as
functions and data types.  When you include a header file, the compiler
adds the functions, data types, and other information in the header file
to the list of reserved words and commands in the language.  After that,
you cannot use the names of functions or macros in the header file to
mean anything other than what the library specifies, in any source
code file that includes the header file.

@pindex glibc @r{library}
@pindex stdio.h @r{header file}
The most commonly used header file is for the standard input/output
routines in @file{glibc} and is called @file{stdio.h}.  This and other
header files are included with the @code{#include} command at the top of
a source code file.  For example,

@smallexample
@group
#include "@var{name}.h"
@end group
@end smallexample

@noindent
includes a header file from the current directory (the directory in
which your C source code file appears), and

@smallexample
@group
#include <@var{name}.h>
@end group
@end smallexample

@pindex /usr/include @r{directory}
@noindent
includes a file from a @dfn{system directory} --- a standard GNU
directory like @file{/usr/include}.  (The @code{#include} command is
actually a @dfn{preprocessor directive}, or instruction to a program
used by the C compiler to simplify C code.  (@xref{Preprocessor
directives}, for more information.)

Here is an example that uses the @code{#include} directive to include
the standard @file{stdio.h} header in order to print a greeting on the
screen with the @code{printf} command.  (The characters @samp{\n} cause
@code{printf} to move the cursor to the next line.)

@smallexample
@group
#include <stdio.h>

int main ()
@{
  printf ("C standard I/O file is included.\n");
  printf ("Hello world!\n");

  return 0;
@}
@end group
@end smallexample

If you save this code in a file called @file{hello.c}, you
can compile this program with the following command:

@smallexample
@group
gcc -o hello hello.c
@end group
@end smallexample

As mentioned earlier, you can use some library functions without having
to link library files explicitly, since every program is always linked
with the @dfn{standard C library}.  This is called @file{libc} on older
operating systems such as Unix, but @file{glibc} (``GNU libc'') on
GNU systems.  The @file{glibc} file includes standard functions for
input/output, date and time calculation, string manipulation, memory
allocation, mathematics, and other language features.

Most of the standard @file{glibc} functions can be incorporated into
your program just by using the @code{#include} directive to include the
proper header files.  For example, since @file{glibc} includes the
standard input/output routines, all you need to do to be able to call
@code{printf} is put the line @code{#include <stdio.h>} at the beginning
of your program, as in the example that follows.

Note that @file{stdio.h} is just one of the many header files you will
eventually use to access @file{glibc}.  The GNU C library is
automatically linked with every C program, but you will eventually need
a variety of header files to access it.  These header files are not
included in your code automatically --- you must include them  yourself!

@pindex math.h @r{header file}
@smallexample
@group
#include <stdio.h>
#include <math.h>

int main ()
@{
  double x, y;

  y = sin (x);
  printf ("Math library ready\n");

  return 0;
@}
@end group
@end smallexample

@findex sin @r{function}
However, programs that use a special function outside of @file{glibc}
--- including mathematical functions that are nominally part of
@file{glibc}, such as function @code{sin} in the example above! --- must
use the @option{-l} option to @command{gcc} in order to link the
appropriate libraries.  If you saved this code above in a file called
@file{math.c}, you could compile it with the following command:

@smallexample
@group
gcc -o math math.c -lm
@end group
@end smallexample

@noindent
The option @option{-lm} links in the library @file{libm.so}, which is
where the mathematics routines are actually located on a GNU system.

To learn which header files you must include in your program in order to
use the features of @file{glibc} that interest you, consult @ref{Top, ,
Table of Contents, libc, The GNU C Library Reference Manual}.  This document
lists all the functions, data types, and so on contained in
@file{glibc}, arranged by topic and header file.  (@xref{Common library
functions}, for a partial list of these header files.)

@strong{Note:} Strictly speaking, you need not always use a system
header file to access the functions in a library.  It is possible to
write your own declarations that mimic the ones in the standard header
files.  You might want to do this if the standard header files are too
large, for example.  In practice, however, this rarely happens, and this
technique is better left to advanced C programmers; using the header
files that came with your GNU system is a more reliable way to access
libraries.

@menu
* Kinds of library::
* Common library functions::
* Questions for Chapter 13::
@end menu


@node Kinds of library, Common library functions, Header files, Libraries
@section Kinds of library

@cindex Kinds of library
@cindex Library, kinds of
@cindex Static libraries
@cindex Shared libraries
@cindex Libraries, static
@cindex Libraries, shared

There are two kinds of library: @dfn{static libraries} and @dfn{shared
libraries}.  When you link to a static library, the code for the entire
library is merged with the object code for your program.  If you link to
many static libraries, your executable will be enormous.

Shared libraries were developed in the late 1980s to reduce the code
size of programs on operating systems like GNU.  When you link to a
shared library, the library's code is not merged with your program's
object code.  Instead, @dfn{stub code} is inserted into your object
code.  The stub code is very small and merely calls the functions in the
shared library --- the operating system does the rest.  An executable
created with a shared library can therefore be far smaller than one
created with a static library.  Shared libraries can also reduce the
amount of memory used.

Although shared libraries seem to have every advantage over static
libraries, static libraries are still useful.  For example, sometimes
you will wish to distribute an executable to people whose computers do
not have the libraries that yours does.  In that case, you might link to
a static version of the libraries.  This will incorporate the library
functions that you need into your executable, so that it will run on
systems that don't have those libraries.  (It is also sometimes easier
to debug a program that is linked to static libraries than one linked to
shared libraries.  @xref{Introduction to GDB}, for more information.)

@pindex .a @r{file suffix}
@pindex .so @r{file suffix}
The file name for a library always starts with @samp{lib} and ends with
either @samp{.a} (if it is static) or @samp{.so} (if it is shared).  For
example, @file{libm.a} is the static version of the C math library, and
@file{libm.so} is the shared version.  As explained above, you must use
the @option{-l} option with the name of a library, minus its @samp{lib}
prefix and @samp{.a} or @samp{.so} suffix, to link that library to your
program (except the library @file{glibc}, which is always linked).  For
example, the following shell command creates an executable program
called @file{math} from the source code file @file{math.c} and the
library @file{libm.so}.

@smallexample
@group
gcc -o math math.c -lm
@end group
@end smallexample

The shared version of the library is always linked by default.  If you
want to link the static version of the library, you must use the GCC
option @option{--static}.  The following example links @file{libm.a}
instead of @file{libm.so}.

@smallexample
@group
gcc -o math math.c -lm --static
@end group
@end smallexample

Type @samp{info gcc} at your shell prompt for more information about GCC options.



@node Common library functions, Mathematical functions, Kinds of library, Libraries
@section Common library functions

@emph{Checking character types.  Handling strings.  Doing maths.}

@cindex Common library functions
@cindex Library functions, common
@cindex Functions, common library

The libraries in GCC contain a repertoire of standard functions and
macros.  There are many different kinds of function and macro in the
libraries.  Here are a few of the different kinds available, with the
header files you can use to access them:

@pindex ctype.h @r{header file}
@pindex math.h @r{header file}
@pindex string.h @r{header file}
@itemize @bullet
@item  Character handling: @file{ctype.h}
@item  Mathematics: @file{math.h}
@item  String manipulation: @file{string.h}
@end itemize

@pindex /usr/include @r{directory}
@pindex /usr/include/linux @r{directory}
@findex -I @r{option of GCC}
You may find it useful to read the header files yourself. They
are usually found in the directories @file{/usr/include} and its
subdirectories on GNU/Linux systems.  The three header files listed
above can be found in @file{/usr/include}; there is a second version of
@file{ctype.h} in @file{/usr/include/linux}.@footnote{The version of
@file{ctype.h} in the @file{/usr/include} directory proper is the one
that comes with @file{glibc}; the one in @file{/usr/include/linux} is a
special version associated with the Linux kernel.  You can specify the
one you want with a full pathname inside double quotes (for example,
@code{#include "/usr/include/linux/ctype.h"}), or you can use the
@option{-I} option of @command{gcc} to force GCC to search a set of
directories in a specific order.  @xref{Building a library}, for
more information.)}

@menu
* Character handling::          
@end menu

@node Character handling,  , Common library functions, Common library functions
@subsection Character handling

@cindex Character handling
@pindex glibc @r{library}
@pindex ctype.h @r{header file}

Let's examine some simple library functions and see how they are used.
Some of the functions that are available on GNU systems for handling
individual characters are described below.  They are all macros, so the
usual caveats about macro parameters apply.  (@xref{Macro functions}.)
All of the functions below accept single variables of type @code{char}
as parameters.  To use any of them, you must include the system header
file @file{ctype.h}; the library used is simply @code{glibc},
which is linked automatically.

@table @code

@findex isalnum @r{function}
@item isalnum
Returns true if and only if the parameter is alphanumeric: that is, an
alphabetic character (see @code{isalpha}) or a digit (see
@code{isdigit}).

@findex isalpha @r{function}
@item isalpha
Returns true if and only if the parameter is alphabetic.  An
@dfn{alphabetic} character is any character from @samp{A} through
@samp{Z} or @samp{a} through @samp{z}.

@findex isascii @r{function}
@item isascii
Returns true if and only if the parameter is a valid ASCII character:
that is, it has an integer value in the range 0 through 127.  (Remember,
the @code{char} type in C is actually a kind of integer!)

@findex iscntrl @r{function}
@item iscntrl
Returns true if and only if the parameter is a control character.
Control characters vary from system to system, but are usually defined
as characters in the range 0 to 31.

@findex isdigit @r{function}
@item isdigit
Returns true if and only if the parameter is a digit in the range 0
through 9.

@findex isgraph @r{function}
@item isgraph
Returns true if and only if the parameter is graphic: that is, if the
character is either alphanumeric (see @code{isalnum}) or punctuation
(see @code{ispunct}).  All graphical characters are valid ASCII
characters, but ASCII also includes non-graphical characters such as
control characters (see @code{iscntrl}) and whitespace (see
@code{isspace}).

@findex islower @r{function}
@item islower
Returns true if and only if the parameter is a lower-case alphabetic
character (see @code{isalpha}).

@findex isprint @r{function}
@item isprint
Returns true if and only if the parameter is a printable character: that
is, the character is either graphical (see @code{isgraph}) or a space
character.

@findex ispunct @r{function}
@item ispunct
Returns true if and only if the parameter is a punctuation character.

@findex isspace @r{function}
@item isspace
Returns true if and only if the parameter is a whitespace character.
What is defined as whitespace varies from system to system, but it
usually includes space characters and tab characters, and sometimes
newline characters.

@findex isupper @r{function}
@item isupper
Returns true if and only if the parameter is an upper-case alphabetic
character (see @code{isalpha}).

@findex isxdigit @r{function}
@item isxdigit
Returns true if and only if the parameter is a valid hexadecimal digit:
that is, a decimal digit (see @code{isdigit}), or a letter from @samp{a}
through @samp{f} or @samp{A} through @samp{F}.

@findex toascii @r{function}
@item     toascii
Returns the parameter stripped of its eighth bit, so that it has an
integer value from 0 through 127 and is therefore a valid ASCII
character. (See @code{isascii}.)

@findex tolower @r{function}
@item      tolower
Converts a character into its lower-case counterpart.  Does not affect
characters which are already in lower case.

@findex toupper @r{function}
@item      toupper
Converts a character into its upper-case counterpart.  Does not affect
characters which are already in upper case.

@end table

@cindex Character functions, example of
@smallexample
/********************************************************/
/*                                                      */
/* Demonstration of character utility functions         */
/*                                                      */
/********************************************************/

#include <stdio.h>
#include <ctype.h>

#define  allchars    ch = 0; isascii(ch); ch++

int main ()           /* A criminally long main program! */

@{
  char ch;

  printf ("\n\nVALID CHARACTERS FROM isgraph:\n\n");
  for (allchars)
    @{
      if (isgraph(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM isalnum:\n\n");
  for (allchars)
    @{
      if (isalnum(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM isalpha:\n\n");
  for (allchars)
    @{
      if (isalpha(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM isupper:\n\n");
  for (allchars)
    @{
      if (isupper(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM islower:\n\n");
  for (allchars)
    @{
      if (islower(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM isdigit:\n\n");
  for (allchars)
    @{
      if (isdigit(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM isxdigit:\n\n");
  for (allchars)
    @{
      if (isxdigit(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\nVALID CHARACTERS FROM ispunct:\n\n");
  for (allchars)
    @{
      if (ispunct(ch))
	@{
	  printf ("%c ",ch);
	@}
    @}

  printf ("\n\n");

  return 0;
@}
@end smallexample

The output of the above code example is as follows:

@smallexample
VALID CHARACTERS FROM isgraph:

! " # $ % & ' ( ) * + , - . / 0 1 2 3 4 5 6 7 8 9 : ; < = > ? @@ A B C D
E F G H I J K L M N O P Q R S T U V W X Y Z [ \ ] ^ _ ` a b c d e f g h
i j k l m n o p q r s t u v w x y z @{ | @} ~

VALID CHARACTERS FROM isalnum:

0 1 2 3 4 5 6 7 8 9 A B C D E F G H I J K L M N O P Q R S T U V W X Y Z
a b c d e f g h i j k l m n o p q r s t u v w x y z

VALID CHARACTERS FROM isalpha:

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z a b c d e f g h i j
k l m n o p q r s t u v w x y z

VALID CHARACTERS FROM isupper:

A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

VALID CHARACTERS FROM islower:

a b c d e f g h i j k l m n o p q r s t u v w x y z

VALID CHARACTERS FROM isdigit:

0 1 2 3 4 5 6 7 8 9

VALID CHARACTERS FROM isxdigit:

0 1 2 3 4 5 6 7 8 9 A B C D E F a b c d e f

VALID CHARACTERS FROM ispunct:

! " # $ % & ' ( ) * + , - . / : ; < = > ? @@ [ \ ] ^ _ ` @{ | @} ~
@end smallexample




@node Mathematical functions, Questions for Chapter 13, Common library functions, Libraries
@section Mathematical functions

@cindex Mathematical function
@cindex Functions, mathematical

Let us now examine some simple math library functions.
(This section presupposes some familiarity on your part with trigonometry.
If you have none, you might want to skip this section for now -- but reading it
won't hurt you!)

The following mathematical functions, among others, are available on GNU
systems.  Many of the functions described below are macros, so the usual
caveats about macro parameters apply.  (@xref{Macro functions}.)  All of
these functions require parameters of type @code{double} or @code{long
float}.  Constants used must be written in floating point form: for
instance, write @samp{7.0} instead of just @samp{7}.

@pindex math.h @r{header file}
@pindex tgmath.h @r{header file}
@pindex limits.h @r{header file}
Here is a list of some functions you can expect to find in the headers
@file{math.h}, @file{tgmath.h}, and @file{limits.h}.

@table @code

@findex abs @r{function}
@item abs
Returns the unsigned value of the parameter in brackets.  This function
is a macro; see @code{fabs} for a proper function version.

@findex acos @r{function}
@item acos
Returns the arccosine (or inverse cosine) of the parameter, which must lie
between -1.0 and +1.0 inclusive.
(The result is always in radians.)

@findex asin @r{function}
@item asin
Returns the arcsine (or inverse sine) of the parameter, which must lie
between -1.0 and +1.0 inclusive.
(The result is always in radians.)

@findex atan @r{function}
@item atan
Returns the arctangent (or inverse tangent) of the parameter.
(The result is always in radians.)

@findex atan2 @r{function}
@item atan2
This is a special function for calculating the inverse tangent of the
second parameter divided by the first. @code{atan2} will find the result
more accurately than @code{atan} will.

@smallexample
@group
result = atan2 (x, y);
result = atan2 (x, 3.14);
@end group
@end smallexample

@findex ceil @r{function}
@item       ceil
Returns the ceiling for the parameter: that is, the integer
just above it.  In effect, rounds the parameter up.

@findex cos @r{function}
@item       cos
Returns the cosine of the parameter in radians.
(The parameter is also assumed to be specified in radians.)

@findex cosh @r{function}
@item       cosh
Returns the hyperbolic cosine of the parameter.

@findex exp @r{function}
@item       exp
Returns the exponential function of the parameter (i.e. @emph{e} to the power
of the parameter).

@findex fabs @r{function}
@item       fabs
Returns the absolute or unsigned value of the parameter in brackets.
This is the version that is a proper function; see @code{abs} if you
want one that is a macro.

@findex floor @r{function}
@item       floor
Returns the floor for the parameter: that is, the integer just below it.
In effect, rounds the parameter down to the nearest integer value,
i.e. truncates it.

@findex log @r{function}
@item       log
Returns the natural logarithm of the parameter.  The parameter used must
be greater than zero, but does not have to be declared as unsigned.

@findex log10 @r{function}
@item       log10
Returns the base 10 logarithm of the parameter.  The parameter used must
be greater than zero, but does not have to be declared as unsigned.

@findex pow @r{function}
@item       pow
Returns the first parameter raised to the power of the second.

@smallexample
@group
result = pow (x,y); /*raise x to the power y */
result = pow (x,2); /* square x */
@end group
@end smallexample

@findex sin @r{function}
@item       sin
Returns the sine of the parameter in radians.
(The parameter is also assumed to be specified in radians.)

@findex sinh @r{function}
@item       sinh
Returns the hyperbolic sine of the parameter.  (Pronounced ``shine'' or
``sinch''.)

@findex sqrt @r{function}
@item       sqrt
Returns the positive square root of the parameter.

@findex tan @r{function}
@item       tan
Returns the tangent of the parameter in radians.
(The parameter is also assumed to be specified in radians.)

@findex tanh @r{function}
@item       tanh
Returns the hyperbolic tangent of the parameter.

@end table

Here is a code example that uses a few of the math library routines listed above.

@cindex Math functions, example of
@smallexample
@group
#include <stdio.h>
#include <math.h>

int main()
@{
  double my_pi;

  my_pi = 4 * atan(1.0);

  /* Print the value of pi we just calculated, to 32 digits. */
  printf ("my_pi = %.32f\n", my_pi);

  /* Print value of pi from math library, to 32 digits. */
  printf ("M_PI  = %.32f\n", M_PI);

  return 0;
@}
@end group
@end smallexample


If you save the above example as @file{pi.c}, you will have to
enter a command such as the one below to compile it.

@smallexample
@group
gcc pi.c -o pi -lm
@end group
@end smallexample

When you compile and run the code example, it should print the following
results:

@smallexample
@group
my_pi = 3.14159265358979311599796346854419
M_PI  = 3.14159265358979311599796346854419
@end group
@end smallexample


@node Questions for Chapter 13,  , Mathematical functions, Libraries
@section Questions for Chapter 13

@enumerate
@item
How do you incorporate a library file into a C program?

@item
Name the most commonly used library file in C.

@item
Is it possible to define new functions with the same names as
standard library functions?

@item
What type of data is returned from mathematical functions?

@item
True or false? All mathematical calculations are performed using
doubles.

@item
Name five kinds of error which can occur in a mathematical function.

@end enumerate



@c CHAPTER 14
@node Arrays, Strings, Libraries, Top
@chapter Arrays
@emph{Rows and tables of storage.}

@cindex Arrays

Suppose you have a long list of numbers, but you don't want to assign
them to variables individually.  For example, you are writing a simple
program for a restaurant to keep a list of the amount each diner has on
his or her tab, but you don't want to go through the tedium of writing a
list like the following:

@smallexample
@group

float alfies_tab, bettys_tab, charlies_tab @var{@dots{}};

alfies_tab = 88.33;
bettys_tab = 17.23;
charlies_tab = 55.55;
@var{etc.}
@end group
@end smallexample

A list like that could run to hundreds or thousands of entries, and for
each diner you'd have to write ``special-case'' code referring to every
diner's data individually.  No, what you really want is a single table
in which you can find the tab corresponding to a particular diner.  You
can then look up the tab of the diner with dining club card number 7712
in row number 7712 of the table much more easily.

@cindex Arrays, multidimensional
This is why arrays were invented.  Arrays are a convenient way to group
many variables under a single variable name.  They are like pigeonholes,
with each compartment storing a single value.  Arrays can be
one-dimensional like a list, two-dimensional like a chessboard, or
three-dimensional like an apartment building --- in fact, they can have
any arbitrary dimensionality, including ones humans cannot visualise
easily.

@cindex Arrays, defining
An array is defined using square brackets @code{[@dots{}]}.  For example: an
array of three integers called @code{my_list} would be declared thus:

@smallexample
@group
int my_list[3];
@end group
@end smallexample

@noindent
This statement would cause space for three adjacent integers to be
created in memory, as in the diagram below.  Notice that there is no
space between the name of the array above (@code{my_array}) and the
opening square bracket @samp{[}.

@smallexample
@group
          ------------------------------------
my_list: |           |           |            |
          ------------------------------------
@end group
@end smallexample

@noindent
The number in the square brackets of the declaration is referred
to as the @dfn{subscript} of the array, and
it must be an integer greater than or equal to zero.

The three integer ``pigeonholes'' in the above array are called its
@dfn{locations}, and the values filling them are called the array's
@dfn{elements}. The position of an element in the array is called its
@dfn{index} (the plural is @dfn{indices}).  In the following example, 5,
17, and 23 are the array's elements, and 0, 1, and 2 are its
corresponding indices.

@cindex Zero-based arrays in C
@cindex Arrays, zero-based nature of
@cindex One-based arrays
@cindex Arrays, one-based
Notice also that although we are creating space for three integers,
arrays in C are @dfn{zero-based}, so the indices of the array run (0, 1,
2).  If arrays in C were @dfn{one-based}, the indices would run (1, 2, 3).

@smallexample
@group
int my_list[3];
my_list[0] = 5;
my_list[1] = 17;
my_list[2] = 23;
@end group
@end smallexample

@noindent
The above example would result in an array that ``looks like'' the
following diagram.  (Of course, an array is merely an arrangement of
bytes in the computer's memory, so it does not @emph{look like}
much of anything, literally speaking.)

@smallexample
@group
index:         0           1           2
          ------------------------------------
my_list: |     5     |    17     |    23      |
          ------------------------------------
@end group
@end smallexample

@noindent
Note that every element in an array must be of the same type, for
example, integer.  It is not possible in C to have arrays that contain
multiple data types.  However, if you want an array with multiple data
types, you might instead be able to use multiple arrays of different
data types that contain the same number of elements.  For example, to
continue our restaurant tab example above, one array, @code{diner_names}
might contain a list of the names of the diners.  If you are looking for
a particular diner, say Xavier Nougat, you might find that the index of
his name in @code{diner_names} is 7498.  If you have programmed an
associated floating-point array called @code{diner_tabs}, you might look
up element 7498 in that array and find that his tab is $99.34.

@menu
* Array bounds::                
* Arrays and for loops::        
* Multidimensional arrays::     
* Arrays and nested loops::     
* Initializing arrays::         
* Arrays as Parameters::        
* Questions for Chapter 14::    
@end menu



@node Array bounds, Arrays and for loops, Arrays, Arrays
@section Array bounds

@cindex Array bounds
@cindex Arrays, bounds of
@cindex Bounds of arrays

In keeping with C's free-wheeling, ``I assume you know what you're
doing'' policy, the compiler does not complain if you try to write to
elements of an array that do not exist.  For example, the code below
defines an array with five elements.  (Remember, C arrays are
zero-based.)

@smallexample
@group
char my_array[4];
@end group
@end smallexample

@noindent
Given the line of code below, your program will happily try to write the
character @samp{*} at location 10000.  Unfortunately, as may happen when
writing to an uninitialized pointer, this may crash the program, but
will probably do nothing worse on a GNU system. (@xref{Pointers and
initialization}.)

@smallexample
@group
my_array[10000] = '*';
@end group
@end smallexample

@noindent
The first and last positions in an array are called its @dfn{bounds}.
Remember that the bounds of an array are zero and the integer that
equals the number of elements it contains, minus one.

Although C will not warn you at compile-time when you exceed the bounds
of an array, the debugger can tell you at run-time. @xref{Introduction
to GDB}, for more information.




@node Arrays and for loops, Multidimensional arrays, Array bounds, Arrays
@section Arrays and @code{for} loops

@cindex Arrays and @code{for} loops
@cindex @code{for} loops and arrays
@findex for @r{command}
@cindex Arrays, initializing
@cindex Initializing arrays

When you declare an array, the computer allocates a block of memory for
it, but the block contains garbage (random values).  Therefore, before
using an array, you should initialise it.  It is usually a good idea to
set all elements in the array to zero.

The easiest way to initialise an array is with a @code{for} loop.
The following example loops through every element in the array
@code{my_array} and sets each to zero.

Remember, because arrays in C are zero-based, the indices of the array
@code{my_array} in the example below run 0 through 9, rather than 1
through 10.  The effect is the same, however: an array of
@code{ARRAY_SIZE} (that is, 10) elements.

@smallexample
@group
#include <stdio.h>
#define ARRAY_SIZE 10

int main ()
@{
  int index, my_array[ARRAY_SIZE];

  for (index = 0; index < ARRAY_SIZE; index++)
    @{
      my_array[index] = 0;
      printf ("my_array[%d] = %d\n", index, my_array[index]);
    @}
  printf("\n");

  return 0;
@}
@end group
@end smallexample

@noindent
The output from the above example is as follows:

@smallexample
@group
my_array[0] = 0
my_array[1] = 0
my_array[2] = 0
my_array[3] = 0
my_array[4] = 0
my_array[5] = 0
my_array[6] = 0
my_array[7] = 0
my_array[8] = 0
my_array[9] = 0
@end group
@end smallexample

You can use similar code to fill the array with different values.  The
following code example is nearly identical to the one above, but the
line @code{my_array[index] = index;} fills each element of the array
with its own index:

@smallexample
@group
#include <stdio.h>
#define ARRAY_SIZE 5

int main ()
@{
  int index, my_array[ARRAY_SIZE];

  for (index = 0; index < ARRAY_SIZE; index++)
    @{
      my_array[index] = index;
      printf ("my_array[%d] = %d\n", index, my_array[index]);
    @}
  printf("\n");

  return 0;
@}
@end group
@end smallexample

@noindent
The output is as follows:

@smallexample
@group
my_array[0] = 0
my_array[1] = 1
my_array[2] = 2
my_array[3] = 3
my_array[4] = 4
@end group
@end smallexample

@noindent
Here is a human's-eye view of the @dfn{internal representation} of the array
(how the array "looks" to the computer):

@smallexample
@group
index        0   1   2   3   4
            -------------------
element    | 0 | 1 | 2 | 3 | 4 |
            -------------------
@end group
@end smallexample

You can use loops to do more than initialize an array.  The next code
example demonstrates the use of @code{for} loops with an array to find
prime numbers.  The example uses a mathematical device called the Sieve
of Erastosthenes. Erastosthenes of Cyrene discovered that one can find
all prime numbers by first writing down a list of integers from 2 (the
first prime number) up to some arbitrary number, then deleting all
multiples of 2 (which are by definition not prime numbers), finding the
next undeleted number after 2 (which is 3), deleting all its multiples,
finding the next undeleted number after that (5), deleting all its
multiples, and so on.  When you have finished this process, all numbers
that remain are primes.

The following code example creates a Sieve of Erastosthenes for integers
up to 4999, initializes all elements with 1, then deletes all composite
(non-prime) numbers by replacing the elements that have an index equal
to the composite with the macro @code{DELETED}, which equals 0.

@smallexample
#include <stdio.h>

#define ARRAY_SIZE 5000
#define DELETED    0

int sieve[ARRAY_SIZE];


int main ()
@{
  printf ("Results of Sieve of Erastosthenes:\n\n");

  fill_sieve();
  delete_nonprimes();
  print_primes();
@}


fill_sieve ()
@{
  int index;

  for (index = 2; index < ARRAY_SIZE; index++)
    sieve[index] = 1;
@}


delete_nonprimes ()
@{
  int index;

  for (index = 2; index < ARRAY_SIZE; index++)
    @{
      if (sieve[index] != DELETED)
	delete_multiples_of_prime (index);
    @}
@}


delete_multiples_of_prime (int prime)
@{
  int index, multiplier = 2;

  for (index = prime * multiplier; index < ARRAY_SIZE; index = prime * multiplier++)
    sieve[index] = DELETED;
@}


print_primes ()
@{
  int index;

  for (index = 2; index < ARRAY_SIZE; index++)
    @{
      if (sieve[index] != DELETED)
	printf ("%d ", index);
    @}
  printf("\n\n");
@}
@end smallexample

@noindent
Part of the output from the above program is shown below, for values up
to 500.  (The full output is considerably longer.)

@smallexample
@group
Results of Sieve of Erastosthenes:

2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97
101 103 107 109 113 127 131 137 139 149 151 157 163 167 173 179 181 191
193 197 199 211 223 227 229 233 239 241 251 257 263 269 271 277 281 283
293 307 311 313 317 331 337 347 349 353 359 367 373 379 383 389 397 401
409 419 421 431 433 439 443 449 457 461 463 467 479 487 491 499 @dots{}
@end group
@end smallexample




@node Multidimensional arrays, Arrays and nested loops, Arrays and for loops, Arrays
@section Multidimensional arrays

@cindex Arrays, multidimensional
@cindex Multidimensional arrays
@cindex GNU Chess
@cindex Chess, GNU
@cindex Chessboard, represented by array

Suppose that you are writing a chess-playing program like
@uref{http://www.gnu.org/software/chess/chess.html, GNU Chess}.
A chessboard is an 8-by-8 grid.  What data structure would you use
to represent it?

You could use an array that has a chessboard-like structure, that is, a
@dfn{two-dimensional array}, to store the positions of the chess
pieces. Two-dimensional arrays use two indices to pinpoint an individual
element of the array.  This is very similar to what is called
``algebraic notation'', already commonly used in chess circles to record
games and chess problems.

In principle, there is no limit to the number of subscripts (or
dimensions) an array can have.  Arrays with more than one dimension are
called @dfn{multidimensional arrays}.  Although humans cannot easily
visualize objects with more than three dimensions, representing
multidimensional arrays presents no problem to computers.

In practice, however, the amount of memory in a computer tends to place
limits on how large an array can be.  For example, a simple
four-dimensional array of double-precision numbers, merely twenty
elements wide in each dimension, already takes up @math{20^4 * 8}, or
1,280,000 bytes of memory --- about a megabyte.  (Each element of the
array takes up 8 bytes, because doubles are 64 bits wide.
@xref{Floating point variables}, for more information.)

You can declare an array of two dimensions as follows:

@smallexample
@group
@var{variable_type} @var{array_name}[@var{size1}][@var{size2}]
@end group
@end smallexample

@noindent
In the above example, @var{variable_type} is the name of some type of
variable, such as @code{int}.  Also, @var{size1} and @var{size2} are the
sizes of the array's first and second dimensions, respectively.  Here is
an example of defining an 8-by-8 array of integers, similar to a
chessboard.  Remember, because C arrays are zero-based, the indices on
each side of the chessboard array run 0 through 7, rather than 1 through
8.  The effect is the same, however: a two-dimensional array of 64
elements.

@smallexample
@group
int chessboard[8][8];
@end group
@end smallexample

To pinpoint an element in this grid, simply supply the indices in both
dimensions.

Every element in this grid needs two indices to pin-point it.  Normally,
C programmers think of element 0,0 of a two-dimensional array as being
the upper-left corner.  The computer, however, knows nothing of left and
right, and for our purposes (attempting to conform to international
chess notation), it makes more sense to mentally ``flop'' the array
vertically so that element 0,0 is the lower-left corner of the board,
and 7,7 the upper-right.  Thus, the first index gives the row number for
the grid and the second index gives the column number.  For example, 1,0
is the square directly above the lower-left corner.  Suppose that a
value of 1 for an array location means a the chess king is on the space
in question.  To indicate the White king's usual position (that is,
square a5 in algebraic chess notation or 0,4 in our zero-based integer
notation), you would write this:

@smallexample
@group
chessboard[0][4] = 1;
@end group
@end smallexample

Since computer memory is essentially one-dimensional, with memory
locations running straight from 0 up through the highest location in
memory, a multidimensional array cannot be stored in memory as a grid.
Instead, the array is dissected and stored in rows.  Consider the
following two-dimensional array.

@smallexample
@group
        -----------
row 0  | 1 | 2 | 3 |
        -----------
row 1  | 4 | 5 | 6 |
        -----------
row 2  | 7 | 8 | 9 |
        -----------
@end group
@end smallexample

@noindent
Note that the numbers inside the boxes are not the actual indices of the
array, which is two-dimensional and has two indices for each element,
but only arbitrary placeholders to enable you to see which elements
correspond in the following example.  The row numbers do correspond to
the first index of the array, so they are numbered from 0 to 2 rather
than 1 to 3.

To the computer, the array above actually ``looks'' like this:

@smallexample
@group
------------------------------------
| 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9 |
------------------------------------
|   row 0   |   row 1   |   row 2   |
@end group
@end smallexample

Another way of saying that arrays are stored by row is that the second
index @dfn{varies fastest}. A two-dimensional array is always thought of
as follows:

@smallexample
@group
@var{array_name}[@var{row}][@var{column}]
@end group
@end smallexample

Every row stored will contain elements of many columns.  The column
index runs from 0 to @var{size} - 1 inside every row in the
one-dimensional representation (where @var{size} is the number of
columns in the array), so the column index is changing faster than the
row index, as the one-dimensional representation of the array inside the
computer is traversed.

You can represent a three-dimensional array, such as a cube, in a similar way:

@smallexample
@group
@var{variable_type} @var{array_name}[@var{size1}][@var{size2}][@var{size3}]
@end group
@end smallexample

@noindent
Arrays do not have to be shaped like squares and cubes; you can give
each dimension of the array a different size, as follows:

@smallexample
@group
int non_cube[2][6][8];
@end group
@end smallexample

@noindent
Three-dimensional arrays (and higher) are stored in the same basic way
as two-dimensional ones.  They are kept in computer memory as a linear
sequence of variables, and the last index is always the one that varies
fastest (then the next-to-last, and so on).

@node Arrays and nested loops, Initializing arrays, Multidimensional arrays, Arrays
@section Arrays and nested loops

@cindex Arrays, multidimensional, initializing
@cindex Multidimensional arrays, initializing
@cindex Initializing multidimensional arrays
@cindex Arrays, initializing
@cindex Initializing arrays
@cindex Nested @code{for} loops
@cindex @code{for} loops, nested
@cindex Nested loops
@cindex Loops, nested
@cindex Arrays and nested loops
@cindex Nested loops and arrays

To initialize multidimensional arrays, you can use nested @code{for}
loops.  Three nested loops are needed to initialize a three-dimensional
array:

@smallexample
@group
#include <stdio.h>

#define SIZE1 3
#define SIZE2 3
#define SIZE3 3

int main ()
@{
  int fast, faster, fastest;
  int my_array[SIZE1][SIZE2][SIZE3];

  for (fast = 0; fast < SIZE1; fast++)
    @{
      for (faster = 0; faster < SIZE2; faster++)
	@{
	  for (fastest = 0; fastest < SIZE3; fastest++)
	    @{
	      my_array[fast][faster][fastest] = 0;
	      printf("my_array[%d][%d][%d] DONE\n", fast, faster, fastest);
	    @}
	@}
    @}
  printf("\n");
@}
@end group
@end smallexample

@noindent
In this example, the variables @code{fast}, @code{faster}, and
@code{fastest} contain the indices of the array, and vary fast, faster,
and fastest, respectively.  In the example output below, you can see
that the @code{fastest} index changes every line, while the
@code{faster} index changes every three lines, and the @code{fast} index
changes only every nine lines.

@smallexample
my_array[0][0][0] DONE
my_array[0][0][1] DONE
my_array[0][0][2] DONE
my_array[0][1][0] DONE
my_array[0][1][1] DONE
my_array[0][1][2] DONE
my_array[0][2][0] DONE
my_array[0][2][1] DONE
my_array[0][2][2] DONE
my_array[1][0][0] DONE
my_array[1][0][1] DONE
my_array[1][0][2] DONE
my_array[1][1][0] DONE
my_array[1][1][1] DONE
my_array[1][1][2] DONE
my_array[1][2][0] DONE
my_array[1][2][1] DONE
my_array[1][2][2] DONE
my_array[2][0][0] DONE
my_array[2][0][1] DONE
my_array[2][0][2] DONE
my_array[2][1][0] DONE
my_array[2][1][1] DONE
my_array[2][1][2] DONE
my_array[2][2][0] DONE
my_array[2][2][1] DONE
my_array[2][2][2] DONE
@end smallexample

@strong{Note:} Although in this example we have followed the order in
which indices vary inside the computer, you do not have to do so in your own
code.  For example, we could have switched the nesting of the innermost
@code{fastest} and outermost @code{fast} loops, and every element would
still have been initialized.  It is better, however, to be systematic
about initializing multidimensional arrays.




@node Initializing arrays, Arrays as Parameters, Arrays and nested loops, Arrays
@section Initializing arrays

@cindex Arrays, initializing
@cindex Initializing arrays

As mentioned above, you must initialize your arrays or they will contain
garbage.  There are two main ways to do so.  The first is by assigning
values to array elements individually, either as shown in the example
below, or with @code{for} loops.  (@xref{Arrays and for loops}, above.)

@smallexample
@group
my_array[0] = 42;
my_array[1] = 52;
my_array[2] = 23;
my_array[3] = 100;
@var{@dots{}}
@end group
@end smallexample

@noindent
The second method is more efficient and less tedious.  It uses a single
assignment operator (@code{=}) and a few curly brackets
(@code{@{@dots{}@}}).

Recall that arrays are stored by row, with the last index varying
fastest.  A 3 by 3 array could be initialized in the following way:

@smallexample
@group
int my_array[3][3] =
@{
  @{10, 23, 42@},
  @{1, 654, 0@},
  @{40652, 22, 0@}
@};
@end group
@end smallexample

Here is a small program that uses the above initialization:

@smallexample
@group
#include <stdio.h>

int main()
@{
  int row, column;

  int my_array[3][3] =
  @{
    @{10, 23, 42@},
    @{1, 654, 0@},
    @{40652, 22, 0@}
  @};

  for (row = 0; row <=2; row++)
    @{
      for (column = 0; column <= 2; column++)
	@{
	  printf("%d\t", my_array[row][column]);
	@}
      printf("\n");
    @}

  printf("\n");

  return 0;
@}
@end group
@end smallexample

The internal curly brackets are unnecessary, but they help to
distinguish the rows of the array. The following code has the same
effect as the first example:

@smallexample
@group
int my_array[3][3] =
@{
  10, 23, 42,
  1, 654, 0,
  40652, 22, 0
@};
@end group
@end smallexample

The same array initialization could even be written this way:

@smallexample
@group
int my_array[3][3] =
  @{10, 23, 42, 1, 654, 0, 40652, 22, 0@};
@end group
@end smallexample

Using any of these three array initializations, the program above
will print the following text:

@smallexample
@group
10      23      42
1       654     0
40652   22      0
@end group
@end smallexample

@noindent
@strong{Note 1:} Be careful to place commas after every array element except the last one
before a closing curly bracket (@samp{@}}).  Be sure you also place a
semicolon after the final curly bracket of an array initializer, since
here curly brackets are not delimiting a code block.

@strong{Note 2:}  All the expressions in an array initializer must be constants,
not variables; that is, values such as @code{235} and @code{'q'} are acceptable,
depending on the type of the array, but expressions such as the integer variable @code{my_int}
are not.

@strong{Note 3:}  If there are not enough expressions in the array initializer
to fill the array, the remaining elements will be set to 0 if the array is static,
but will be filled with garbage otherwise.


@node Arrays as Parameters, Questions for Chapter 14, Initializing arrays, Arrays
@section Arrays as Parameters

@cindex Arrays as parameters
@cindex Passing arrays as parameters
@cindex Parameters, arrays as
@cindex Parameters, passing arrays as
@cindex Pointers and arrays, equivalence of
@cindex Arrays and pointers, equivalence of
@cindex Equivalence of pointers and arrays

There will be times when you want to pass an array as a parameter to a
function.  (For example, you might want to pass an array of numbers to
a function that will sort them.)

In the following example, notice how the array @code{my_array} in
@code{main} is passed to the function @code{multiply} as an actual
parameter with the name @code{my_array}, but that the formal parameter
in the @code{multiply} function is defined as @code{int *the_array}:
that is, an integer pointer.  This is the basis for much that you will
hear spoken about the ``equivalence of pointers and arrays'' --- much
that is best ignored until you have more C programming experience.  The
important thing to understand is that arrays passed as parameters are
considered to be pointers by the functions receiving them.  Therefore,
they are always variable parameters, which means that other functions
can modify the original copy of the variable, just as the function
@code{multiply} does with the array @code{my_array} below.
(@xref{Parameters}.)

@smallexample
@group
#include <stdio.h>

void multiply (int *, int);


int main()
@{
  int index;
  int my_array[5] = @{0, 1, 2, 3, 4@};

  multiply (my_array, 2);

  for (index = 0; index < 5; index++)
    printf("%d  ", my_array[index]);

  printf("\n\n");
  return 0;
@}


void multiply (int *the_array, int multiplier)
@{
  int index;
  for (index = 0; index < 5; index++)
    the_array[index] *= multiplier;
@}
@end group
@end smallexample

@noindent
Even though the function @code{multiply} is declared @code{void} and
therefore does not return a result, it can still modify @code{my_array}
directly, because it is a variable parameter.  Therefore, the result of
the program above is as follows:

@smallexample
@group
0  2  4  6  8
@end group
@end smallexample

If you find the interchangeability of arrays and pointers as formal
parameters in function declarations to be confusing, you can always
avoid the use of pointers, and declare formal parameters to be arrays, as
in the new version of the @code{multiply} function below.  The result is
the same.

@smallexample
@group
void multiply (int the_array[], int multiplier)
@{
  int index;
  for (index = 0; index < 5; index++)
    the_array[index] *= multiplier;
@}
@end group
@end smallexample


@node Questions for Chapter 14,  , Arrays as Parameters, Arrays
@section Questions for Chapter 14

@enumerate

@item
Declare an array of type @code{double}, measuring 4 by 5 elements.

@item
How do you pass an array as a parameter?

@item
When an array parameter is received by a function, does C allocate space for a
local variable and copy the whole array to the new location?

@item
What does it mean to say that one dimension of an array ``varies fastest''?

@item
Which dimension of an array varies fastest, the first or the last?

@end enumerate



@c CHAPTER 15
@node Strings, Input and output, Arrays, Top
@chapter Strings

@cindex Strings
@cindex String values

@emph{Communication using arrays.}

So far we have examined variables that can contain integers,
floating-point numbers, and values that represent individual text
characters.  But what if you need a variable that can contain a sequence
of text characters, such as a name in a database of diners at a
restaurant, as in the examples for last chapter?  That's where strings
and string variables come in.

A @dfn{string value} is a sequence of text characters that can become a
value for a @dfn{string variable}. Both a string value and a string
variable can be referred to as a @dfn{string}, depending on context.

In C, a string value is represented by text characters enclosed by
double quotes:

@smallexample
@group
"This is a string value."
@end group
@end smallexample

@noindent
A string can contain any character, including special control
characters, such as the tab character @samp{\t}, the newline character
@samp{\n}, the ``bell'' character @samp{\7} (which causes the terminal
to beep when it is displayed), and so on.

We have been using string values since we introduced the @code{printf}
command early in the book. (@xref{The form of a C program}.)  To cause
your terminal to beep twice, include the following statement in a C
program:

@smallexample
@group
printf("This is a string value. Beep! Beep! \7\7");
@end group
@end smallexample

@menu
* Conventions and declarations::  
* Initializing strings::        
* String arrays::               
* String library functions::    
* Questions for Chapter 15::    
@end menu



@node Conventions and declarations, Initializing strings, Strings, Strings
@section Conventions and declarations

@cindex Strings, confused with characters
@cindex Characters, confused with strings
@tindex char @r{type}

Do not confuse strings in C with individual characters.  By convention,
individual characters are enclosed in single quotes, like this:
@code{'a'}, and have the variable type @code{char}.  On the other hand,
string values are enclosed in double quotes, like this:
@code{"abcdefg"}.  String variables are either arrays of type
@code{char} or have the type ``pointer to @code{char}'', that is,
@code{char *}.

Conceptually, a string is an array of characters (type @code{char}).  In
C, string variables can theoretically be of any length, unlike languages
such as Pascal where strings hold a maximum of 255 characters.  However,
the length of the string value is determined by the position of the
first null character (@code{'/0'}) in the string.  Even though a string
@emph{variable} might be 32,000 characters long, or longer, if the null
character first appears at position 5 in the character array, the string
value is considered to be of length 5 (and contains the characters in
positions 0 through 4, in sequence).  You will rarely need to consider
this end marker, as most functions in C's string library add it or
remove it automatically.


@node Initializing strings, String arrays, Conventions and declarations, Strings
@section Initializing strings

@cindex Strings, initializing
@cindex Initializing strings
@cindex String constants
@cindex Constants, string

Initializing string variables (or character arrays) with string values
is in many ways even easier than initializing other kinds of arrays.
There are three main ways of assigning string constants to string variables.
(A @dfn{string constant} is a string value that was typed into the source
code, as opposed to one that is generated by the program or entered by the user.)

@smallexample
@group
#include <stdio.h>
#include <string.h>

int main()
@{
  /* Example 1 */
  char string1[] = "A string declared as an array.\n";

  /* Example 2 */
  char *string2 = "A string declared as a pointer.\n";

  /* Example 3 */
  char string3[30];
  strcpy(string3, "A string constant copied in.\n");

  printf (string1);
  printf (string2);
  printf (string3);

  return 0;
@}
@end group
@end smallexample


@enumerate

@item @code{char string1[] = "A string declared as an array.\n";}

This is usually the best way to declare and initialize a string.  The
character array is declared explicitly.  There is no size declaration
for the array; just enough memory is allocated for the string, because
the compiler knows how long the string constant is.  The compiler stores
the string constant in the character array and adds a null character
(@samp{\0}) to the end.

@item @code{char *string2 = "A string declared as a pointer.\n";}

The second of these initializations is a pointer to an array of
characters.  Just as in the last example, the compiler calculates the
size of the array from the string constant and adds a null character.
The compiler then assigns a pointer to the first character of the
character array to the variable @code{string2}.

@strong{Note:} Most string functions will accept strings declared in
either of these two ways.  Consider the @code{printf} statements at the
end of the example program above --- the statements to print the
variables @code{string1} and @code{string2} are identical.

@item @code{char string3[30];}

Declaring a string in this way is useful when you don't know what the
string variable will contain, but have a general idea of the length of
its contents (in this case, the string can be a maximum of 30 characters
long).  The drawback is that you will either have to use some kind of
string function to assign the variable a value, as the next line of code
does (@code{ strcpy(string3, "A string constant copied in.\n");}), or
you will have to assign the elements of the array the hard way,
character by character. (@xref{String library functions}, for more information
on the function @code{strcpy}.)

@end enumerate



@node String arrays, String library functions, Initializing strings, Strings
@section String arrays

@cindex String arrays
@cindex Arrays of strings

Suppose you want to print out a screenful of text instead of a single line.
You could use one long character array, interspersed with
@samp{\n} characters where you want the lines to break, but you might
find it easier to use a @dfn{string array}.  A string array is an array
of strings, which, of course, are themselves arrays of characters; in
effect, a string array is a two-dimensional character array.

Just as there are easy methods of initializing integer arrays, float
arrays, strings, and so on, there is also an easy way of initializing
string arrays.  For example, here is a sample program which prints out a
menu for a full application program.  That's all it does, but you might
imagine that when the user chooses @samp{3} in the full program, the
application invokes the function @code{calculate_bill} we examined
earlier. (@xref{Parameters}.)

@smallexample
@group
#include <stdio.h>

char *menu[] =
@{
  "  -------------------------------------- ",
  " |            ++ MENU ++                |",
  " |           ~~~~~~~~~~~~               |",
  " |     (0) Edit Preferences             |",
  " |     (1) Print Charge Sheet           |",
  " |     (2) Print Log Sheet              |",
  " |     (3) Calculate Bill               |",
  " |     (q) Quit                         |",
  " |                                      |",
  " |                                      |",
  " |     Please enter choice below.       |",
  " |                                      |",
  "  -------------------------------------- "
@};


int main()
@{
  int line_num;

  for (line_num = 0; line_num < 13; line_num++)
    @{
      printf ("%s\n", menu[line_num]);
    @}

  return 0;
@}
@end group
@end smallexample

@noindent

Notice that the string array @code{menu} is declared @code{char
*menu[]}.  This method of defining a two-dimensional string array is a
combination of methods 1 and 2 for initializing strings from the last
section. (@xref{Initializing strings}.)  This is the most convenient
method; if you try to define @code{menu} with @code{char menu[][]}, the
compiler will return an ``unspecified bounds error''. You can get around
this by declaring the second subscript of @code{menu} explicitly
(e.g. @code{char menu[][80]}), but that necessitates you know the
maximum length of the strings you are storing in the array, which is
something you may not know and that it may be tedious to find out.

The elements of @code{menu} are initialized with string constants in the
same way that an integer array, for example, is initialized with
integers, separating each element with a comma. (@xref{Initializing
arrays}.)

@node String library functions, Questions for Chapter 15, String arrays, Strings
@section String library functions

@cindex String library functions
@cindex Library functions, string
@cindex Functions, string library
@pindex string.h @r{header file}
@pindex stdlib.h @r{header file}

The GNU C Library provides a number of very useful functions which
handle strings.  Here is a list of the more common ones.  To use the
functions beginning with @samp{ato}, you must include the header file
@file{stdlib.h}; to use the functions beginning with @samp{str}, you
must include the header file @file{string.h}.


@itemize @bullet

@findex atof @r{function}
@item @code{atof}
Converts an ASCII string to its floating-point equivalent; for example,
converts @samp{-23.5} to the value -23.5.

@smallexample
@group
#include <stdio.h>
#include <stdlib.h>

int main()
@{
  double my_value;
  char my_string[] = "+1776.23";
  my_value = atof(my_string);
  printf("%f\n", my_value);

  return 0;
@}
@end group
@end smallexample

The output from the above code is @samp{1776.230000}.


@findex atoi @r{function}
@item @code{atoi}
Converts an ASCII string to its integer equivalent; for example,
converts @samp{-23.5} to the value -23.

@smallexample
@group
int my_value;
char my_string[] = "-23.5";
my_value = atoi(my_string);
printf("%d\n", my_value);
@end group
@end smallexample


@findex atol @r{function}
@item @code{atol}
Converts an ASCII string to its long integer equivalent; for example,
converts @samp{+2000000000} to the value 2000000000.

@smallexample
@group
long my_value;
char my_string[] = "+2000000000";
my_value = atol(my_string);
printf("%ld\n", my_value);
@end group
@end smallexample


@findex strcat @r{function}
@item @code{strcat}
@dfn{Concatenates} two strings: that is, joins them together into one
string.  Example:

@smallexample
@group
char string1[50] = "Hello, ";
char string2[] = "world!\n";
strcat (string1, string2);
printf (string1);
@end group
@end smallexample

@noindent
The example above attaches the contents of @code{string2} to the
current contents of @code{string1}.  The array @code{string1} then
contains the string @samp{Hello, world!\n}.

Notice that @code{string1} was declared to be 50 characters long, more
than enough to contain the initial values of both @code{string1} and
@code{string2}.  You must be careful to allocate enough space in the
string variable that will receive the concatenated data; otherwise, your
program is likely to crash.  Again, on a GNU system, although your
program won't run, nothing more drastic than an error message from the
operating system is likely to occur in such a case.


@findex strcmp @r{function}
@item @code{strcmp}
Compares two strings and returns a value that indicates which string
comes first alphabetically.  Example:

@smallexample
@group
int comparison;
char string1[] = "alpha";
char string2[] = "beta";

comparison = strcmp (string1, string2);
printf ("%d\n", comparison);
@end group
@end smallexample

@noindent
If the two strings are identical, @code{strcmp} returns 0.  If the first
string passed to @code{strcmp} comes alphabetically before the second
(that is, the first string is ``less than'' the second one),
@code{strcmp} returns a value less than 0.  If the first string comes
alphabetically after the second one (that is, the first string is
``greater than'' the second one), @code{strcmp} returns a value greater
than zero.  (Note that numbers come before letters in ASCII, and
upper-case letters come before lower-case ones.)

The example above prints out @samp{-1}, because @samp{alpha} is
alphabetically ``less than'' @samp{beta}.

In all cases below, @code{string1} comes alphabetically before
@code{string2}, so @code{strcmp(string1, string2)} returns a negative value.

@table @samp


@item @code{string1}
@code{string2}

@item aaa
@samp{aab}

@item aaa
@samp{aaba}

@item aa
@samp{aaa}

@end table


@findex strcpy @r{function}
@item @code{strcpy}
Copies a string into a string variable.  Example:

@smallexample
@group
char dest_string[50];
char source_string[] = "Are we not men?";

/* Example 1 */
strcpy (dest_string, source_string);
printf ("%s\n", dest_string);

/* Example 2 */
strcpy (dest_string, "Are we having fun yet?");
printf ("%s\n", dest_string);
@end group
@end smallexample

@noindent
The example above produces this output:

@smallexample
@group
Are we not men?
Are we having fun yet?
@end group
@end smallexample


@strong{Notes:}

@itemize

@item The destination string in @code{strcmp} comes first, then the source
string.  This works in exactly the
opposite way from the GNU/Linux shell command, @command{cp}.

@item You can use @code{strcmp} to copy one string variable into
another (Example 1), or to copy a string constant into a string variable
(Example 2).

@item Note the use of the characters @samp{%s} in the @code{printf}
statements to display a string, rather than @samp{%d} to display an
integer or @samp{%f} to display a float.

@end itemize



@findex strlen @r{function}
@item @code{strlen}
Returns an integer that gives the length of a string in characters,
not including the null character at the end of the string.  The following
example displays the number @samp{5}.

@smallexample
@group
int string_length
char my_string[] = "fnord";

string_length = strlen (my_string);
printf ("%d\n", string_length);
@end group
@end smallexample



@findex strncat @r{function}
@item @code{strncat}
Works like @code{strcat}, but concatenates only a specified number of
characters.  The example below displays the string
@samp{Hello, world! Bye}.

@smallexample
@group
char string1[50] = "Hello, world! ";
char string2[] = "Bye now!";
strncat (string1, string2, 3);
printf ("%s\n", string1);
@end group
@end smallexample




@findex strncmp @r{function}
@item @code{strncmp}
Works like @code{strcmp}, but compares only a specified number of characters
of both strings.  The example below displays @samp{0}, because @samp{dogberry}
and @samp{dogwood} are identical for their first three characters.

@smallexample
@group
int comparison;
char string1[] = "dogberry";
char string2[] = "dogwood";

comparison = strncmp (string1, string2, 3);
printf ("%d\n", comparison);
@end group
@end smallexample


@findex strncpy @r{function}
@item @code{strncpy}
Works like @code{strcpy}, but copies only a specified number of
characters.  The example below displays the string @samp{Are we},
because only the first six characters of @code{source_string} are being
copied into @code{dest_string}.

@smallexample
@group
char dest_string[50];
char source_string[] = "Are we not men?";

strncpy (dest_string, source_string, 6);
printf ("%s\n", dest_string);
@end group
@end smallexample

@noindent
@strong{Note:} As in @code{strcmp}, the destination string in
@code{strncmp} comes first, then the source string.  This works in exactly the
opposite way from the GNU/Linux shell command, @command{cp}.


@findex strstr @r{function}
@item @code{strstr}
Tests whether a substring is present in a larger string.
Returns a pointer to the first occurrence of the substring
in the larger string, or zero if the substring is not present.
(When the substring is empty, @code{strstr} returns a pointer
to the first character of the larger string.)

The example below displays @samp{'foo' is a substring of 'Got food?'.}.

@smallexample
@group
char string1[] = "Got food?";
char string2[] = "foo";

if (strstr (string1, string2))
  printf("'%s' is a substring of '%s'.\n", string2, string1);
@end group
@end smallexample

@end itemize



@node Questions for Chapter 15,  , String library functions, Strings
@section Questions for Chapter 15

@enumerate

@item
What are the three main ways of initializing string variables?

@item
How would you declare an array of strings?

@item What information is returned by @code{strlen}?

@item What does the function @code{strcat} do?  How about @code{strncat}?

@item
Rewrite the Morse coder program more efficiently, using
static strings.  (@xref{Example 15}, for the original version.)

@end enumerate



@c CHAPTER 16
@node Input and output, Putting a program together, Strings, Top
@chapter Input and output

@cindex Input and output
@cindex Input
@cindex Output
@cindex GNU C Library

@emph{Input and output.  Talking to the user.  Why your printer is a file.}

In order for a program to do anything useful, it usually must do some
kind of input and output, whether input from the keyboard and output to
the screen, or input from and output to the computer's hard disk.  While
the C language itself does not provide much in the way of input and
output functions, the GNU C Library contains so many facilities for
input and output that a whole book could be written about them.  In this
chapter, we will focus on the basics.  For more information on the
functions described in this chapter, and many more, we urge you to
consult @ref{Top, , Table of Contents, The GNU C Library Reference
Manual}.

Most objects from which you can receive input and to which you can send
output on a GNU system are considered to be files --- not only are files
on your hard disk (such as object code files, C source code files, and
ordinary ASCII text files) considered to be files, but also such
peripherals as your printer, your keyboard, and your computer monitor.
When you write a C program that prompts the user for input from the
keyboard, your program is @dfn{reading from}, or accepting input from,
the keyboard, in much the same way that it would read a text string from
a text file.  Similarly, when your C program displays a text string on
the user's monitor, it is @dfn{writing to}, or sending output to, the
terminal, just as though it were writing a text string to a text file.
In fact, in many cases you'll be using the very same functions to read
text from the keyboard and from text files, and to write text to the
terminal and to text files.

@cindex Devices
@cindex Peripherals
@cindex Peripherals as devices

This curious fact will be explored later in the chapter.  For now it is
sufficient to say that when C treats your computer's peripherals as
files, they are known as @dfn{devices}, and each one has its own name,
called a @dfn{device name} or @dfn{pseudo-device name}.  On a GNU
system, the printer might be called @file{/dev/lp0} (for ``device line
printer zero'') and the first floppy drive might be called
@file{/dev/fd0} (for ``device floppy drive zero'').  (Why zero in both
cases?  Most objects in the GNU environment are counted by starting with
zero, rather than one --- just as arrays in C are zero-based.)

The advantage of treating devices as files is that it is often not
necessary to know how a particular device works, only that it is
connected to the computer and can be written to or read from.  For
example, C programs often get their input from the keyboard, which C
refers to with the file name @file{stdin} (for ``standard input''), and
C programs often send their output to the monitor's text display,
referred to as @file{stdout}.  In some cases, @file{stdin} and
@file{stdout} may refer to things other than the keyboard and monitor;
for example, the user may be redirecting the output from your program to
a text file with the @command{>} command in GNU/Linux.  The beauty of
the way the standard input/output library handles things is that your
program will work just the same.

@findex open @r{command}
@findex fopen @r{command}
@cindex Opening files
@cindex Files, opening
Before you can read from or write to a file, you must first connect to
it, or @dfn{open} it, usually by either the @code{fopen} command, which
returns its stream, or the @code{open} command, which returns its file
descriptor.  You can open a file for reading, writing, or both.  You can
also open a file for @dfn{appending}, that is, writing data after the
current end of the file.

@cindex Streams
@cindex File descriptors
@cindex Descriptors, file
Files are made known to functions not by their file names, except in a
few cases, but by identifiers called ``streams'' or ``file
descriptors''.  For example, @code{printf} uses a stream as an
identifier, not the name of the file.  So does @code{fclose}:

@smallexample
@group
fprintf (my_stream, "Just a little hello from fprintf.\n");
close_error = fclose (my_stream);
@end group
@end smallexample

On the other hand, @code{fopen} takes a name, and returns a stream:

@smallexample
@group
my_stream = fopen (my_filename, "w");
@end group
@end smallexample

This is how you map from names to streams or file descriptors: you open
the file (for reading, writing, or both, or for appending), and the
value returned from the @code{open} or @code{fopen} function is the
appropriate file descriptor or stream.

@cindex High-level file operations
@cindex Low-level file operations
@cindex File operations, high-level
@cindex File operations, low-level
@cindex Files, high-level operations on
@cindex Files, low-level operations on
You can operate on a file either at a high level or at a low level.
Operating on a file at a high level means that you are using the file at
a high level of abstraction.  (@xref{Introduction}, to refresh your
memory about the distinction between high and low levels of
abstraction.)  Using high-level functions is usually safer and more
convenient than using low-level functions, so we will mostly concern
ourselves with high-level functions in this chapter, although we will
touch on some low-level functions toward the end.

@cindex Streams
@cindex File descriptors
@cindex Descriptors, file
A high-level connection opened to a file is called a @dfn{stream}.  A
low-level connection to a file is called a @dfn{file descriptor}.
Streams and file descriptors have different data types, as we shall see.
You must pass either a stream or a file descriptor to most input/output
functions, to tell them which file they are operating on.  Certain
functions (usually high-level ones) expect to be passed streams, while
others (usually low-level ones) expect file descriptors.  A few
functions will accept a simple filename instead of a stream or file
descriptor, but generally these are only the functions that initialize
streams or file descriptors in the first place.

You may consider it a nuisance to have to use a stream or a file
descriptor to access your file when a simple file name would seem to
suffice, but these two mechanisms allow a level of abstraction to exist
between your code and your files.  Remember the ``black box'' analogy we
explored at the beginning of the book.  By using the data in files only
through streams or file descriptors, we are guaranteed the ability to
write a rich variety of functions that can exploit the behavior of these
two ``black box'' abstractions.

Interestingly enough, although streams are considered to be for
``high-level'' input/output, and file descriptors for ``low-level'' I/O,
and GNU systems support both, more Unix-like systems support streams
than file descriptors.  You can expect any system running ISO C to
support streams, but non-GNU systems may not support file descriptors at
all, or may only implement a subset of the GNU functions that operate on
file descriptors. Most of the file descriptor functions in the GNU
library are included in the POSIX.1 standard, however.

Once you have finished your input and output operations on the file, you
must terminate your connection to it.  This is called @dfn{closing} the
file.  Once you have closed a file, you cannot read from or write to it
anymore until you open it again.

In summary, to use a file, a program must go through the following routine:

@itemize @bullet

@item
Open the file for reading, writing, or both.

@item
Read from or write to the file as appropriate, using file-handling
functions provided by the GNU C Library.

@item
Close the file

@end itemize



@menu
* High-level file routines::    
* String output and input::     
* Single-character input and output::  
* Programming with pipes::      
* Low-level file routines::     
* Questions 16::                
@end menu

@node High-level file routines, String output and input, Input and output, Input and output
@section High-level file routines

@cindex High-level file routines
@cindex File routines, high-level

You can recognise most of the high-level input/output functions that
operate on files because they begin with the letter @samp{f}; for
example, the high-level function for opening a file called @code{fopen},
as opposed to the low-level file-opening function @code{open}.  Some of
them are more generalized versions of functions with which you may
already be familiar; for example, the function @code{fprintf} behaves
like the familiar @code{printf}, but takes an additional parameter --- a
stream --- and sends all its output to that stream instead of simply
sending its output to @file{stdout}, as @code{printf} does.


@menu
* Opening a file::              
* Closing a file::              
* Block input and output::      
* File position::               
* Stream buffering::            
* End-of-file and error functions::  
@end menu

@node Opening a file, Closing a file, High-level file routines, High-level file routines
@subsection Opening a file

@cindex Opening files
@cindex Files, opening
@findex fopen @r{command}
The main high-level function for opening files is @code{fopen}.  When
you open a file with the @code{fopen} function, the GNU C Library
creates a new stream and creates a connection between the stream and a
file.  If you pass this function the name of a file that does not exist,
that file will be created.  The @code{fopen} function normally returns a
stream.  A stream is a flow of data from a source to a destination
within a GNU system.  Programs can read characters from or write
characters to a stream without knowing either the source or destination
of the data, which may be a file on disk, a device such as a terminal
meant as a human interface, or something entirely different.  Streams
are represented by variables of type @code{FILE *} --- @code{fopen} will
return a null pointer if it fails to open the file.

@c RWHE
@c I don't think I talked about null pointers in the Pointers
@c chapter.  Better go back and do something about that...

The first parameter to this function is a string containing the filename
of the file to open.  The filename string can be either a constant or a
variable, as in the following two equivalent examples:

@smallexample
@group
FILE *my_stream;
my_stream = fopen ("foo", "r");

FILE *my_stream;
char my_filename = "foo";
my_stream2 = fopen (my_filename, "r");
@end group
@end smallexample

The second parameter is a string containing one of the following sets of
characters:

@table @code

@item r
Open the file for reading only.  The file must already exist.

@item w
Open the file for writing only.  If the file already exists,
its current contents are deleted.  If the file does not already
exist, it is created.

@item r+
Open the file for reading and writing.  The file must already exist.
The contents of the file are initially unchanged, but the file position
is set to the beginning of the file.

@item w+
Open the file for both writing and reading. If the file already exists,
its current contents are deleted.  If the file does not already
exist, it is created.

@item a
Open the file for appending only.  Appending to a file is the same
as writing to it, except that data is only written to the current
end of the file.  If the file does not already exist, it is created.

@item a+
Open the file for both appending and reading.  If the file exists,
its contents are unchanged until appended to.  If the file does not
exist, it is created.  The initial file position for reading is
at the beginning of the file, but the file position for appending
is at the end of the file.

@end table

@noindent
@xref{File position}, for more information on the concept of file position.

You can also append the character @samp{x} after any of the strings in the
table above.  This character causes @code{fopen} to fail rather than opening
the file if the file already exists.  If you append @samp{x} to any of the arguments
above, you are guaranteed not to @dfn{clobber} (that is, accidentally destroy)
any file you attempt to open.  (Any other characters in this parameter are ignored
on a GNU system, but may be meaningful on other systems.)

The following example illustrates the proper use of @code{fopen} to open
a text file for reading (as well as highlighting the fact that you
should clean up after yourself by closing files after you are done with
them).  Try running it once, then running it a second time after
creating the text file @file{snazzyjazz.txt} in the current directory
with a GNU command such as @command{touch snazzyjazz.txt}.

@findex fopen @r{command}
@cindex @code{fopen} command, example of
@smallexample
@group
#include <stdio.h>

int main()
@{
  FILE *my_stream;

  my_stream = fopen ("snazzyjazz.txt", "r");
@end group

@group
  if (my_stream == NULL)
    @{
      printf ("File could not be opened\n");
    @}
  else
    @{
      printf ("File opened!  Closing it now...\n");
      /* Close stream; skip error-checking for brevity of example */
      fclose (my_stream);
    @}
  return 0;
@}
@end group
@end smallexample

@noindent
@xref{Closing a file}, for more information on the function @code{fclose}.


@node Closing a file, Block input and output, Opening a file, High-level file routines
@subsection Closing a file

@cindex Closing files
@cindex Files, closing
@findex fclose @r{command}

The basic high-level function for closing files is @code{fclose}.
Simply pass this function a stream, and @code{fopen} will close it and
break the connection to the corresponding file, first reading any
buffered input and writing any buffered output.  If the file was closed
successfully, @code{fclose} will return 0; otherwise, it will return
@code{EOF}.

It is important to check for errors when you close a stream to which you
are writing.  For example, when @code{fclose} attempts to write the
output remaining in its buffer, it might generate an error because the
disk is full.  Following is an example of closing a file with write
access, while checking for errors.

@cindex @code{fclose} command, example of
@smallexample
@group
#include <stdio.h>

int main()
@{
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";
  int close_error;
@end group

@group
  my_stream = fopen (my_filename, "w");
  fprintf (my_stream, "Just a little hello from fprintf.\n");
@end group

@group
  close_error = fclose (my_stream);

  if (close_error != 0)
    @{
      printf ("File could not be closed.\n");
    @}
  else
    @{
      printf ("File closed.\n");
    @}

  return 0;
@}
@end group
@end smallexample



@node Block input and output, File position, Closing a file, High-level file routines
@subsection Block input and output

@cindex Block input
@cindex Block output
@cindex Input, block
@cindex Output, block
@findex fread @r{function}
@findex fwrite @r{function}

You can use the two functions in this section, @code{fread} and
@code{fwrite}, to read and write text in blocks of fixed size, rather
than by line or character.  You can also use these two functions to read
and write blocks of binary data.  This feature is useful if you want to
read and write data in the same format used by your program.  For
example, you can store an entire multidimensional array of
floating-point variables in a file with the @code{fwrite} command, then
read it back in directly later with the @code{fread} command, without
any loss of precision caused by converting the floats to strings for use
with the @code{fprintf} function, for example.  (The main drawback to
using binary files rather than formatted ASCII text files is that you
cannot easily read and edit the files you create with a text editor.)

@cindex Writing arrays to streams
@cindex Arrays, writing to streams
@cindex Streams, writing arrays to
@findex fwrite @r{function}
For example, to write an array called @code{my_array}, containing
@code{object_count} data objects (such as integers), each of size
@code{object_size}, to the stream @code{my_stream}, you might use the
following line of code:

@smallexample
@group
fwrite (&my_array, object_size, object_count, my_stream);
@end group
@end smallexample

@cindex Reading arrays from streams
@cindex Arrays, reading from streams
@cindex Streams, reading arrays from
@findex fread @r{function}
To read @code{my_array} back from @code{my_stream}, you might then use
the following line:

@smallexample
@group
fread (&my_array, object_size, object_count, my_stream);
@end group
@end smallexample

Here is a short table to help you remember the directions in which
@code{fwrite} and @code{fread} work.

@table @code
@item fwrite
from an array, to a file

@item fread
from a file, to an array
@end table

@findex fwrite @r{function}
@tindex size_t @r{type}
The @code{fwrite} function takes four parameters.  The first parameter
to @code{fwrite} is a void pointer (@code{void *}) to an array that
contains the data that will be written to the file.  The second
parameter is a variable of type @code{size_t} specifying the size of
each object to be written, and the third parameter, also of type
@code{size_t}, specifies the number of those objects that are to be
written.  The final parameter is the stream to be written to (type
@code{FILE *}).  If the value returned by @code{fopen} does not match
the third parameter passed (that is, the number of objects to be
written), then there was an error.

@findex fread @r{function}
@tindex size_t @r{type}
Like @code{fwrite}, the @code{fread} function takes four parameters.
Its first parameter is a void pointer to the array that will be written
to.  Its second parameter, of type @code{size_t}, specifies how large
each object to be read is, and its third parameter, of type
@code{size_t}, specifies how many of each object is to be read.  The
last parameter is simply the stream to read from.  Again, if the return
value of this function does not match the third parameter, which
specifies how many object were to be read, there was an error.

Here is an example that creates an array and fills it with multiples of 2,
prints it out, writes the array's data to a file with @code{fwrite}, zeroes the
array and prints it out, reads the data from the file back into the array with
@code{fread}, then prints the array out again so you can compare its data
with the first set of data.


@cindex Writing arrays to streams
@cindex Arrays, writing to streams
@cindex Streams, writing arrays to
@findex fwrite @r{function}
@cindex Reading arrays from streams
@cindex Arrays, reading from streams
@cindex Streams, reading arrays from
@findex fread @r{function}
@smallexample
@group
#include <stdio.h>

int main()
@{
  int row, column;
  FILE *my_stream;
  int close_error;
  char my_filename[] = "my_numbers.dat";
  size_t object_size = sizeof(int);
  size_t object_count = 25;
  size_t op_return;
@end group

@group
  int my_array[5][5] =
  @{
    2,  4,  6,  8, 10,
    12, 14, 16, 18, 20,
    22, 24, 26, 28, 30,
    32, 34, 36, 38, 40,
    42, 44, 46, 48, 50
  @};
  printf ("Initial values of array:\n");
  for (row = 0; row <= 4; row++)
    @{
      for (column = 0; column <=4; column++)
	@{
	  printf ("%d  ", my_array[row][column]);
	@}
      printf ("\n");
    @}
@end group

@group
  my_stream = fopen (my_filename, "w");
  op_return = fwrite (&my_array, object_size, object_count, my_stream);
  if (op_return != object_count)
    @{
      printf ("Error writing data to file.\n");
    @}
  else
    @{
      printf ("Successfully wrote data to file.\n");
    @}

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);
@end group

@group
  printf ("Zeroing array...\n");
  for (row = 0; row <= 4; row++)
    @{
      for (column = 0; column <=4; column++)
	@{
	  my_array[row][column] = 0;
	  printf ("%d  ", my_array[row][column]);
	@}
      printf ("\n");
    @}
@end group

@group
  printf ("Now reading data back in...\n");
  my_stream = fopen (my_filename, "r");
  op_return = fread (&my_array, object_size, object_count, my_stream);
  if (op_return != object_count)
    @{
      printf ("Error reading data from file.\n");
    @}
  else
    @{
      printf ("Successfully read data from file.\n");
    @}
  for (row = 0; row <= 4; row++)
    @{
      for (column = 0; column <=4; column++)
	@{
	  printf ("%d  ", my_array[row][column]);
	@}
      printf ("\n");
    @}

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);

  return 0;
@}
@end group
@end smallexample

@noindent
If all goes well, the code example above will produce the following output:

@smallexample
@group
Initial values of array:
2  4  6  8  10
12  14  16  18  20
22  24  26  28  30
32  34  36  38  40
42  44  46  48  50
Successfully wrote data to file.
Zeroing array...
0  0  0  0  0
0  0  0  0  0
0  0  0  0  0
0  0  0  0  0
0  0  0  0  0
Now reading data back in...
Successfully read data from file.
2  4  6  8  10
12  14  16  18  20
22  24  26  28  30
32  34  36  38  40
42  44  46  48  50
@end group
@end smallexample

@noindent
If you attempt to view the file @file{my_numbers.dat} produced by the
program above with a GNU command such as @command{more numbers.dat}, you
will see only garbage, because the information is stored in binary
format, not readable by humans.  After attempting to view this binary
file, your terminal may continue to show only garbage and you may have
to reset it.  You may be able to do this with a menu option (if you are
running @command{gnome-terminal}, for example), or you may have to type
@command{reset} blindly.


@node File position, Stream buffering, Block input and output, High-level file routines
@subsection File position

@cindex File position
@cindex File position, compared to bookmark
@cindex Bookmark, file position compared to
When a person reads a book, her ``location'' in the book can be
specified by a page number (and even a line number or word number, at
finer levels of detail).  Just so, it is possible (and often useful!) to
know the location, or @dfn{file position}, of a stream reading from or
writing to a file.  And just as we sometimes want to know which chapter
a friend is currently reading in a book, or to recommend that he flip
backward or forward to an interesting passage, so it is frequently
useful to be able to change the current file position to access a more
interesting part of the file.

At the high level of the functions in this section, GNU treats all
streams as streams of characters --- even binary streams like the one
associated with the file @file{numbers.dat} in the example for
@code{fread} and @code{fwrite}.  (@xref{Block input and output}.)  This
means that the file position of any stream is a simple character count
--- file position 0 means that we are reading or writing the first
character in the file, file position 522 means that we are reading the
523rd character, and so on.  (Just as with arrays in C, file positions
are zero-based.)

@cindex Random-access files
@cindex Files, random-access
@cindex Random-access memory
@cindex Memory, random-access
@cindex RAM
Not only does the file position of a stream describe where in the file
the stream is reading or writing, but reading or writing on the stream
advances the file position.  During high-level access to a file, you can
change the file position at will.  Any file that permits changing the
file position in an arbitrary way is called a @dfn{random-access file}.
(Many years ago, the people who invented computer jargon chose the word
``random'' to be part of the phrase ``random-access'' because, from the
point of view of the computer, a random-access file can be read from or
written to at any location, as if at random.  Of course, programmers are
not working randomly; they decide where their programs should read and
write.  The term @dfn{RAM} for @dfn{random-access memory} comes from the
same source.)

@findex ftell @r{function}
The main high-level function to tell where the current file position is,
is called appropriately, @code{ftell}.  It accepts a single parameter
--- a file stream --- and returns a long integer representing the file
position.@footnote{Since the file position is a long integer, the length
of a file using one of these functions cannot be any greater than the
maximum value of a 32-bit long integer under GNU, plus one (since the
file position is zero-based) --- that is, such a file cannot be any more
than 2,147,483,648 bytes, or about two gigabytes long.  If you need to
use longer files, you can use low-level file routines, which allow for
longer files and file positions through such 64-bit functions as
@code{lseek64}.} (@xref{File Position Primitive, , libc, Setting the
File Position of a Descriptor, The GNU C Library Reference Manual}, for
more information.)

@findex fseek @r{function}
The main function to seek a different file position is called
@code{fseek}.  It accepts three parameters.  The first parameter is the
stream in question, the second is a long integer offset, and the third
parameter is a constant that specifies whether the offset is relative to
the beginning of the file (@code{SEEK_SET}), to the current file
position (@code{SEEK_CUR}), or to the end of the file (@code{SEEK_END}).
The @code{fseek} function returns 0 if the operation was successful, or
a nonzero integer value otherwise.  (A successful @code{fseek} operation
also clears the end-of-file indicator (see below), and discards the
results of @code{ungetc}.  @xref{ungetc}.)

@findex rewind @r{macro}
There is a simple macro called @code{rewind} that will take the file
pointer back to the beginning of the file.  You must simply pass it the
stream that you want to rewind; it does not return a value.  It is the
same as calling @code{fseek} on the stream with an offset of 0 and a
third parameter of @code{SEEK_SET}, except that it resets the error
indicator for the stream and, as mentioned, there is no return value.

An example of these functions will not be useful until we have
introduced single-character I/O.  @xref{getc and fgetc}, if you want to
read a code example that uses the @code{ftell}, @code{fseek}, and
@code{rewind} functions.


@node Stream buffering, End-of-file and error functions, File position, High-level file routines
@subsection Stream buffering

@cindex Stream buffering
@cindex Buffering, stream
@cindex Buffers

When you write characters to a stream, they are not usually stored in
the file on a character-by-character basis as soon as they are written
to the stream, but instead are accumulated in a @dfn{buffer} first, then
written to the file in a block when certain conditions are met.  (A
buffer is an area of the computer's memory that acts as a temporary
holding area for input or output.)  Similarly, when you are reading
characters from a stream, they are often @dfn{buffered}, or stored in a
buffer first.

It's important to understand how buffering works, or you may find your
programs behaving in an unexpected way, reading and writing characters
when you do not expect them to.  (You can bypass stream buffering entirely,
however, by using low-level rather than high-level file routines.
@xref{Low-level file routines}, for more information.)

There are three main kinds of buffering you should know about:

@itemize @bullet

@cindex Buffering, no
@cindex No buffering
@item @strong{No buffering:}
When you write characters to an unbuffered stream, the operating system
writes them to the file as soon as possible.

@cindex Line buffering
@cindex Buffering, line
@item @strong{Line buffering:}
When you write characters to a line-buffered stream, the operating
system writes them to the file when it encounters a newline character.

@cindex Full buffering
@cindex Buffering, full
@item @strong{Full buffering:}
When you write characters to a fully-buffered stream, the operating system
writes them to the file in blocks of arbitrary size.

@end itemize


@cindex Standard input
@cindex Standard output
@pindex stdin @r{device}
@pindex stdout @r{device}
Most streams are fully buffered when you open them, and this is usually
the best solution.  However, streams connected to interactive devices
such as terminals are line-buffered when you open them; yes, this means
that @file{stdin} and @file{stdout} are line-buffered.

@cindex Daemons
@pindex bdflush @r{daemon}
@findex fflush @r{function}
@cindex Flushing streams
Having @file{stdin} and @file{stdout} be line-buffered is convenient,
because most meaningful chunks of data you write to them are terminated
with a newline character.  In order to ensure that the data you read
from or write to a fully-buffered stream shows up right away, use the
@code{fflush} function.  In the jargon, this is called @dfn{flushing}
the stream.  Flushing moves the characters from the buffer to the file,
if they haven't already been moved.  After the move, other functions can
then work on the characters.@footnote{Strictly speaking, there are
multiple levels of buffering on a GNU system.  Even after flushing
characters to a file, data from the file may remain in memory, unwritten
to disk.  On GNU systems, there is an independently-running system
program, or @dfn{daemon}, that periodically commits relevant data still
in memory to disk.  Under GNU/Linux, this daemon is called
@file{bdflush}.}

@c RWHE
@c Muchos gracias to Martha Koester's uber-hacker husband Kurt for 
@c the footnote info.  Acknowledge him at the start of the book.

To use @code{fflush}, simply pass the function the stream you want to
flush.  The @code{fflush} function returns 0 if successful, or the value
@code{EOF} (which is a macro defined in the GNU C Library) if there was
a write error.

Note that using @code{fflush} is not always necessary; output is flushed
automatically when you try to write and the output buffer is already
full, when the stream is closed, when the program exits, when an input
operation on a stream actually reads data from the file, and of course,
when a newline is written to a line-buffered stream.
(@xref{fputs}, for a code example that uses @code{fflush}.)


@node End-of-file and error functions,  , Stream buffering, High-level file routines
@subsection End-of-file and error functions

@cindex End-of-file functions
@cindex Error functions
@cindex End-of-file indicator
@findex feof @r{function}

If a file has been read to its end (that is, the current file position
is the end of the file), a flag indicating this, called the
@dfn{end-of-file indicator}, will be set to @code{TRUE}.  You can check
whether the end-of-file indicator has been set (and therefore whether
the current file position is the end of the file), with the @code{feof}
function.  This function takes a single argument (a stream), and returns
@code{TRUE} (a nonzero value) if the end of the file has been reached,
and @code{FALSE} (zero) otherwise.

@cindex Error indicator
@findex ferror @r{function}
Another flag, the @dfn{error indicator}, indicates whether an error has
occurred during an earlier operation on the stream.  It returns
@code{TRUE} if there has been an error, and @code{FALSE} otherwise.  You
can check the error indicator for a stream with the @code{ferror}
function.  This function takes a single argument (a stream), and returns
@code{TRUE} (a nonzero value) if an error has occured during an
operation on the stream, and @code{FALSE} (zero) otherwise.

Unfortunately, @code{ferror} will not tell you what the error was, or
when it occurred, only whether there has been an error.  To get a more
detailed diagnosis, you can check the global system variable @code{errno}.
(@xref{Usual file name errors}.)

@cindex Error indicator, resetting
@cindex End-of-file indicator, resetting
@findex clearerr @r{function}
It is possible to reset the error and end-of-file indicators once they
have been set for a stream.  To do so, simply pass the stream to the
function @code{clearerr}; this will set both the error and end-of-file
indicators back to 0.  The @code{clearerr} function does not return a
value.

You should not simply reset the error flag and try a stream operation
that failed a second time.  Because of buffering, you may lose or repeat
data when writing, or access the wrong part of the file when reading.
Before you try a failed stream operation again, you should seek to a
known file position.  (@xref{File position}.)  However, most errors
cannot be recovered from anyway --- trying the operation again will
likely result in the same error --- so it is probably better to have
your program report the error to the user and exit than to write
complicated error-recovery routines for stream operation.

An example of these functions will not be useful until we have
introduced single-character I/O.  @xref{getc and fgetc}, if you want to
read a code example that uses the @code{feof} and @code{ferror}
functions.



@node String output and input, Single-character input and output, High-level file routines, Input and output
@section String output and input

@cindex String input
@cindex String output
@cindex Input, string
@cindex Output, string
@findex puts @r{function}
@findex fputs @r{function}
@findex gets @r{function}
@findex fgets @r{function}
@findex getline @r{function}
@findex getdelim @r{function}

We will now examine some high-level file functions for reading strings
from and writing strings to streams.  The two string output methods we
will examine (@code{puts} and @code{fputs}) are very safe to use, but
the input methods run from the antiquated and very dangerous @code{gets}
to the safer @code{fgets}, to @code{getline} and @code{getdelim}, two
GNU-specific extensions to the C language that are extremely safe to
use.  

It is important to use the safer and better GNU functions when you can.
However, you will probably still want to learn how to read and
understand older (but still free) code that is unsafe (perhaps to update
it and make it safe), so this book describes functions like @code{gets}
despite the fact that they are unsafe.

@menu
* Unformatted string output::   
* Formatted string output::     
* fprintf::                     
* asprintf::                    
* Deprecated formatted string output functions::  
* String input::                
* Deprecated string input functions::  
* Formatted string input::      
* Deprecated formatted string input functions::  
* fscanf::                      
@end menu




@node Unformatted string output, Formatted string output, String output and input, String output and input
@subsection Unformatted string output

@cindex Unformatted string output
@cindex String output, unformatted
@cindex Output, unformatted string

The functions in this section are for output of strings to streams.
They are generally very safe to use.

@menu
* puts::                        
* fputs::                       
@end menu

@node puts, fputs, Unformatted string output, Unformatted string output
@subsubsection @code{puts}

@findex puts @r{function}

The most convenient function for printing a simple message on standard
outout is @code{puts}.  It is even simpler than @code{printf}, since you
do not need to include a newline character --- @code{puts} does that for
you.

Using @code{puts} couldn't be simpler.  Here is an example:

@smallexample
puts ("Hello, multiverse.");
@end smallexample

@noindent
This code example will print the string @samp{Hello, multiverse.} to standard
output.

The @code{puts} function is safe and simple, but not very flexible.
@xref{Formatted string output}, if you want to print fancier output.


@node fputs,  , puts, Unformatted string output
@subsubsection @code{fputs}

@findex fputs @r{function}

The @code{fputs} (``file put string'') function is similar to the
@code{puts} function in almost every respect, except that it accepts a
second parameter, a stream to which to write the string.  It does not
add a newline character, however; it only writes the characters in the
string.  It returns @code{EOF} if an error occurs; otherwise it returns
a non-negative integer value.

Here is a brief code example that creates a text file and uses
@code{fputs} to write into it the phrase @samp{If it's not too
late... make it a cheeseburger.}, followed by a newline character.
This example also demonstrates the use of the @code{fflush} function.
(@xref{Stream buffering}, for more information on this function.)


@smallexample
@group
#include <stdio.h>

int main()
@{
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";
  int flush_status;
@end group

@group
  my_stream = fopen (my_filename, "w");
  fputs ("If it's not too late... make it a cheeseburger.\n", my_stream);
@end group

@group
  /* 
     Since the stream is fully-buffered by default, not line-buffered,
     it needs to be flushed periodically.  We'll flush it here for
     demonstration purposes, even though we're about to close it.  
  */
  flush_status = fflush (my_stream);
  if (flush_status != 0)
    @{
      puts ("Error flushing stream!");
    @}
  else
    @{
      puts ("Stream flushed.");
    @}
@end group

@group

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);

  return 0;
@}
@end group
@end smallexample



@node Formatted string output, fprintf, Unformatted string output, String output and input
@subsection Formatted string output

@cindex Formatted string output
@cindex String output, formatted
@cindex Output, formatted string

The functions in this section are for formatted output of strings 
to streams.  They are generally quite safe to use.

Formatted output is textual output via functions such as @code{printf}
or @code{fprintf}.  These take as an argument a string containing
special character sequences such as @samp{%d} (which indicates that an
integer argument will follow).  After this string, other arguments that
correspond to the special character sequences follow.  When the
functions combine these arguments, the result is formatted textual
output.

The next several sections discuss four formatted output functions.  The
most basic, @code{printf}, prints to standard output.  The
@code{fprintf} function is a high-level routine that sends its output to
a stream, @code{sprintf} ``prints'' to a string, and @code{asprintf} is
a safer way of printing to a string.

@menu
* printf::                      
* Formatted output conversion specifiers::  
@end menu

@node printf, Formatted output conversion specifiers, Formatted string output, Formatted string output
@subsubsection @code{printf}

@findex printf @r{function}

If you have been reading the book closely up to this point, you have
seen the use of the @code{printf} function many times.  To recap, this
function prints a text string to the terminal (or, to be more precise,
the text stream @file{stdout}).  For example, the following line of code
prints the string @samp{Hello there!}, followed by a newline character,
to the console:

@smallexample
printf ("Hello there!\n");
@end smallexample

You probably also remember that you can incorporate numeric constants and
variables into your strings.  Consider the following code example:

@smallexample
printf ("I'm free!  I'm free!  (So what?  I'm %d.)\n", 4);
@end smallexample

The previous example is equivalent to the following one:

@smallexample
int age = 4;
printf ("I'm free!  I'm free!  (So what?  I'm %d.)\n", age);
@end smallexample

Both of the code examples above produce the following output:

@smallexample
I'm free!  I'm free!  (So what?  I'm 4.)
@end smallexample

You may recall that besides using @samp{%d} with @code{printf} to print
integers, we have also used @samp{%f} on occasion to print floating-point numbers,
and that on occasion we have used more than one argument.  Consider this example:

@smallexample
printf ("I'm free!  I'm free!  (So what?  I'm %d.)  Well, I'm %f.\n", 4, 4.5);
@end smallexample

That example produces the following output:

@smallexample
I'm free!  I'm free!  (So what?  I'm 4.)  Well, I'm 4.500000.
@end smallexample

@cindex Format strings, @code{printf}
@cindex @code{printf} format strings

In fact, @code{printf} is a very flexible function.  The general scheme
is that you provide it with a @dfn{format string} or @dfn{template
string} (such as @samp{"So what? I'm %d."}), which can contain zero or
more @dfn{conversion specifications}, @dfn{conversion specifiers}, or
sometimes just @dfn{conversions} (in this case @samp{%d}), and zero or
more arguments (for example, @samp{4}). Each conversion specification is
said to specify a @dfn{conversion}, that is, how to convert its
corresponding argument into a printable string. After the template
string, you supply one argument for each conversion specifier in the
template string.  The @code{printf} function then prints the template
string, including each argument as converted to a printable sub-string
by its conversion specifier, and returns an integer containing the
number of characters printed, or a negative value if there was an error.





@node Formatted output conversion specifiers,  , printf, Formatted string output
@subsubsection Formatted output conversion specifiers

@cindex Formatted output conversion specifiers
@cindex Output conversion specifiers, formatted
@cindex Conversion specifiers, formatted output

There are many different conversion specifiers that can be used for
various data types. Conversion specifiers can become quite complex; for
example, @samp{%-17.7ld} specifies that @code{printf} should print the
number left-justified (@samp{-}), in a field at least seventeen
characters wide (@samp{17}), with a minimum of seven digits (@samp{.7}),
and that the number is a long integer (@samp{l}) and should be printed
in decimal notation (@samp{%d}).

In this section, we will examine the basics of @code{printf} and its
conversion specifiers.  (For even more detail, @ref{Formatted Output, ,
Formatted Output, libc, The GNU C Library Reference Manual}.)

A conversion specifier begins with a percent sign, and ends with one of
the following @dfn{output conversion characters}.  The most basic
conversion specifiers simply use a percent sign and one of these
characters, such as @samp{%d} to print an integer.  (Note that characters
in the template string that are not part of a conversion specifier are
printed as-is.)


@cindex Formatted output conversion specifiers, table of
@cindex Output conversion specifiers, formatted, table of
@cindex Conversion specifiers, formatted output, table of
@table @samp

@findex c @r{output conversion specifier}
@item c
Print a single character.

@findex d @r{output conversion specifier}
@item d
Print an integer as a signed decimal number.

@findex e @r{output conversion specifier}
@item e
Print a floating-point number in exponential notation, using lower-case
letters.  The exponent always contains at least two digits.  Example:
@samp{6.02e23}.

@findex E @r{output conversion specifier}
@item E
Same as @samp{e}, but uses upper-case letters.  Example: @samp{6.02E23}.

@findex f @r{output conversion specifier}
@item f
Print a floating-point number in normal, fixed-point notation.

@findex i @r{output conversion specifier}
@item i
Same as @samp{d}.

@findex m @r{output conversion specifier}
@item m
Print the string corresponding to the specified value of the system
@code{errno} variable.  (@xref{Usual file name errors}.)  GNU systems
only.

@findex s @r{output conversion specifier}
@item s
Print a string.

@findex u @r{output conversion specifier}
@item u
Print an unsigned integer.

@findex x @r{output conversion specifier}
@item x
Print an integer as an unsigned hexadecimal number, using lower-case letters.

@findex X @r{output conversion specifier}
@item X
Same as @samp{x}, but uses upper-case letters.

@findex % @r{output conversion specifier}
@item %
Print a percent sign (@samp{%}).

@end table

In between the percent sign (@samp{%}) and the output conversion
character, you can place some combination of the following
@dfn{modifiers}.  (Note that the percent sign conversion (@samp{%%})
doesn't use arguments or modifiers.)

@cindex Formatted output conversion specifiers, modifiers
@cindex Output conversion specifiers, formatted, modifiers
@cindex Conversion specifiers, formatted output, modifiers
@itemize @bullet

@item Zero or more flag characters, from the following table:

@table @samp

@findex - @r{output conversion specifier modifier}
@item -

Left-justify the number in the field (right justification is the
default).  Can also be used for string and character conversions
(@samp{%s} and @samp{%c}).

@findex + @r{output conversion specifier modifier}
@item +

Always print a plus or minus sign to indicate whether the number is
positive or negative.  Valid for @samp{%d}, @samp{%e}, @samp{%E}, and
@samp{%i}.

@findex SPACE @r{output conversion specifier modifier}
@item Space character

If the number does not start with a plus or minus sign, prefix it with a
space character instead.  This flag is ignored if the @samp{+} flag is
specified.

@findex # @r{output conversion specifier modifier}
@item #

For @samp{%e}, @samp{%E}, and @samp{%f}, forces the number to include a
decimal point, even if no digits follow.  For @samp{%x} and @samp{%X},
prefixes @samp{0x} or @samp{0X}, respectively.

@findex ' @r{output conversion specifier modifier}
@item '

Separate the digits of the integer part of the number into groups, using
a locale-specific character.  In the United States, for example, this
will usually be a comma, so that one million will be rendered
@samp{1,000,000}.  GNU systems only.

@findex 0 @r{output conversion specifier modifier}
@item 0

Pad the field with zeroes instead of spaces; any sign or indication of
base (such as @samp{0x}) will be printed before the zeroes.  This flag
is ignored if the @samp{-} flag or a precision is specified.

@end table

In the example given above, @samp{%-17.7ld}, the flag given is @samp{-}.

@item An optional non-negative decimal integer specifying the minimum
field width within which the conversion will be printed.  If the
conversion contains fewer characters, it will be padded with spaces (or
zeroes, if the @samp{0} flag was specified).  If the conversion contains
more characters, it will not be truncated, and will overflow the field.
The output will be right-justified within the field, unless the @samp{-}
flag was specified.  In the example given above, @samp{%-17.7ld}, the
field width is @samp{17}.

@item For numeric conversions, an optional precision that specifies the
number of digits to be written.  If it is specified, it consists of a
dot character (@samp{.}), followed by a non-negative decimal integer
(which may be omitted, and defaults to zero if it is). In the example
given above, @samp{%-17.7ld}, the precision is @samp{.7}.  Leading
zeroes are produced if necessary.  If you don't specify a precision, the
number is printed with as many digits as necessary (with a default of
six digits after the decimal point).  If you supply an argument of zero
with and explicit precision of zero, @code{printf} will not print any
characters.  Specifying a precision for a string conversion (@samp{%s})
indicates the maximum number of characters to write.

@item An optional @dfn{type modifier character} from the table below.
This character specifies the data type of the argument if it is
different from the default.  In the example given above,
@samp{%-17.7ld}, the type modifier character is @samp{l}; normally, the
@samp{d} output conversion character expects a data type of @code{int},
but the @samp{l} specifies that a @code{long int} is being used instead.

The numeric conversions usually expect an argument of either type
@code{int}, @code{unsigned int}, or @code{double}.  (The @samp{%c}
conversion converts its argument to @code{unsigned char}.)  For the
integer conversions (@samp{%d} and @samp{%i}), @code{char} and
@code{short} arguments are automatically converted to type @code{int},
and for the unsigned integer conversions (@samp{%u}, @samp{%x}, and
@samp{%X}), they are converted to type @code{unsigned int}.  For the
floating-point conversions (@samp{%e}, @samp{%E}, and @samp{%f}), all
@code{float} arguments are converted to type @code{double}.  You can use
one of the type modifiers from the table below to specify another type
of argument.


@cindex Formatted output conversion specifiers, modifiers
@cindex Output conversion specifiers, formatted, modifiers
@cindex Conversion specifiers, formatted output, modifiers
@table @samp

@findex l @r{output conversion specifier modifier}
@item l
Specifies that the argument is a @code{long int} (for @samp{%d} and @samp{%i}),
or an @code{unsigned long int} (for @samp{%u}, @samp{%x}, and @samp{%X}).

@findex L @r{output conversion specifier modifier}
@item L
Specifies that the argument is a @code{long double} for the
floating-point conversions (@samp{%e}, @samp{%E}, and @samp{%f}).  Same
as @samp{ll}, for integer conversions (@samp{%d} and @samp{%i}).

@findex ll @r{output conversion specifier modifier}
@item ll
Specifies that the argument is a @code{long long int} (for @samp{%d} and @samp{%i}).
On systems that do not have extra-long integers, this has the same effect as @samp{l}.

@findex q @r{output conversion specifier modifier}
@item q
Same as @samp{ll}; comes from calling extra-long integers ``quad ints''.

@findex z @r{output conversion specifier modifier}
@item z
Same as @samp{Z}, but GNU only, and deprecated.

@findex Z @r{output conversion specifier modifier}
@item Z
Specifies that the argument is of type @code{size_t}.  (The
@code{size_t} type is used to specify the sizes of blocks of memory, and
many functions in this chapter use it.)

@end table

@end itemize

Make sure that your conversion specifiers use valid syntax; if they do
not, if you do not supply enough arguments for all conversion
specifiers, or if any arguments are of the wrong type, unpredictable
results may follow.  Supplying too many arguments is not a problem,
however; the extra arguments are simply ignored.

Here is a code example that shows various uses of @code{printf}.

@findex printf @r{function}
@cindex @code{printf}, example of
@smallexample
@group
#include <stdio.h>
#include <errno.h>

int main()
@{
  int my_integer = -42;
  unsigned int my_ui = 23;
  float my_float = 3.56;
  double my_double = 424242.171717;
  char my_char = 'w';
  char my_string[] = "Pardon me, may I borrow your nose?";

  printf ("Integer: %d\n", my_integer);
  printf ("Unsigned integer: %u\n", my_ui);

  printf ("The same, as hexadecimal: %#x %#x\n", my_integer, my_ui);

  printf ("Floating-point: %f\n", my_float);
  printf ("Double, exponential notation: %17.11e\n", my_double);

  printf ("Single character: %c\n", my_char);
  printf ("String: %s\n", my_string);

  errno = EACCES;
  printf ("errno string (EACCES): %m\n");

  return 0;
@}
@end group
@end smallexample

The code example above produces the following output on a GNU system:

@smallexample
@group
Integer: -42
Unsigned integer: 23
The same, as hexadecimal: 0xffffffd6 0x17
Floating-point: 3.560000
Double, exponential notation: 4.24242171717e+05
Single character: w
String: Pardon me, may I borrow your nose?
errno string (EACCES): Permission denied
@end group
@end smallexample

@node fprintf, asprintf, Formatted string output, String output and input
@subsection @code{fprintf}

@findex fprintf @r{function}

The @code{fprintf} (``file print formatted'') command is identical to @code{printf},
except that its first parameter is a stream to which to send output.  The following code example
is the same as the one for @code{printf}, except that it sends its output to the text file
@file{snazzyjazz.txt}.

@smallexample
@group
#include <stdio.h>
#include <errno.h>

int main()
@{
  int my_integer = -42;
  unsigned int my_ui = 23;
  float my_float = 3.56;
  double my_double = 424242.171717;
  char my_char = 'w';
  char my_string[] = "Pardon me, may I borrow your nose?";
@end group

@group
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";
  my_stream = fopen (my_filename, "w");
@end group

@group
  fprintf (my_stream, "Integer: %d\n", my_integer);
  fprintf (my_stream, "Unsigned integer: %u\n", my_ui);

  fprintf (my_stream, "The same, as hexadecimal: %#x %#x\n", my_integer, my_ui);

  fprintf (my_stream, "Floating-point: %f\n", my_float);
  fprintf (my_stream, "Double, exponential notation: %17.11e\n", my_double);

  fprintf (my_stream, "Single character: %c\n", my_char);
  fprintf (my_stream, "String: %s\n", my_string);
@end group

@group
  errno = EACCES;
  fprintf (my_stream, "errno string (EACCES): %m\n");

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);

  return 0;
@}
@end group
@end smallexample



@node asprintf, Deprecated formatted string output functions, fprintf, String output and input
@subsection @code{asprintf}

@findex asprintf @r{function}

The @code{asprintf} (mnemonic: ``allocating string print formatted'')
command is identical to @code{printf}, except that its first parameter
is a string to which to send output.  It terminates the string with a
null character.  It returns the number of characters stored in the
string, not including the terminating null.

The @code{asprintf} function is nearly identical to the simpler
@code{sprintf}, but is much safer, because it dynamically
allocates the string to which it sends output, so that the string will
never overflow.  The first parameter is a pointer to a string variable,
that is, it is of type @code{char **}.  The return value is the number
of characters allocated to the buffer, or a negative value if an error
occurred.

The following code example prints the string @samp{Being 4 is cool, but
being free is best of all.} to the string variable @code{my_string},
then prints the string on the screen.  Notice that @code{my_string} is
not initially allocated any space at all; @code{asprintf} allocates the
space itself.  (@xref{puts}, for more information on the @code{puts}
function.)

@smallexample
@group
#include <stdio.h>

int main()
@{
  char *my_string;

  asprintf (&my_string, "Being %d is cool, but being free is best of all.", 4);
  puts (my_string);

  return 0;
@}
@end group
@end smallexample



@node Deprecated formatted string output functions, String input, asprintf, String output and input
@subsection Deprecated formatted string output functions

@findex sprintf @r{function}
@cindex Deprecated formatted string output functions
@cindex Formatted string output functions, deprecated
@cindex String output functions, formatted, deprecated

This section discusses unsafe functions for formatted string
output.  It actually contains only one function, @code{sprintf}.
You should never use the @code{sprintf} function; use @code{asprintf}
instead.

@menu
* sprintf::                     
@end menu

@node sprintf,  , Deprecated formatted string output functions, Deprecated formatted string output functions
@subsubsection @code{sprintf}

@findex sprintf @r{function}

The @code{sprintf} (``string print formatted'') command is similar to
@code{asprintf}, except that it is much less safe.  Its first parameter
is a string to which to send output.  It terminates the string with a
null character.  It returns the number of characters stored in the
string, not including the terminating null.

This function will behave unpredictably if the string to which it is
printing overlaps any of its arguments.  It is dangerous because the
characters output to the string may overflow it.  This problem cannot be
solved with the field width modifier to the conversion specifier,
because only the minimum field width can be specified with it.  To avoid
this problem, it is better to use @code{asprintf}, but there is a lot of
C code that still uses @code{sprintf}, so it is important to know about
it. (@xref{asprintf}.)

The following code example prints the string @samp{Being 4 is cool, but
being free is best of all.}  to the string variable @code{my_string}
then prints the string on the screen.  Notice that @code{my_string} has
been allocated 100 bytes of space, enough to contain the characters
output to it. (@xref{puts}, for more information on the @code{puts}
function.)

@smallexample
@group
#include <stdio.h>

int main()
@{
  char my_string[100];

  sprintf (my_string, "Being %d is cool, but being free is best of all.", 4);
  puts (my_string);

  return 0;
@}
@end group
@end smallexample




@node String input, Deprecated string input functions, Deprecated formatted string output functions, String output and input
@subsection String input

@cindex String input
@cindex Input, string

The functions in this section are for input of strings from streams.
They are generally very safe to use.

@menu
* getline::                     
* getdelim::                    
@end menu

@node getline, getdelim, String input, String input
@subsubsection @code{getline}

@findex getline @r{function}

The @code{getline} function is the preferred method for reading lines of
text from a stream, including standard input.  The other standard
functions, including @code{gets}, @code{fgets}, and @code{scanf}, are
too unreliable.  (Doubtless, in some programs you will see code that uses
these unreliable functions, and at times you will come across compilers
that cannot handle the safer @code{getline} function.  As a
professional, you should avoid unreliable functions and any compiler
that requires you to be unsafe.)

The @code{getline} function reads an entire line from a stream, up to
and including the next newline character.  It takes three parameters.
The first is a pointer to a block allocated with @code{malloc} or
@code{calloc}.  (These two functions allocate computer memory for the
program when it is run.  @xref{Memory allocation}, for more
information.)  This parameter is of type @code{char **}; it will
contain the line read by @code{getline} when it returns.  The second
parameter is a pointer to a variable of type @code{size_t}; this
parameter specifies the size in bytes of the block of memory pointed to
by the first parameter. The third parameter is simply the stream from
which to read the line.

The pointer to the block of memory allocated for @code{getline} is merely
a suggestion.  The @code{getline} function will automatically enlarge
the block of memory as needed, via the @code{realloc} function, so there is
never a shortage of space --- one reason why @code{getline} is so safe.
Not only that, but @code{getline} will also tell you the new size of the block
by the value returned in the second parameter.

If an error occurs, such as end of file being reached without reading
any bytes, @code{getline} returns -1.  Otherwise, the first parameter
will contain a pointer to the string containing the line that was read,
and @code{getline} returns the number of characters read (up to and
including the newline, but not the final null character).  The return
value is of type @code{ssize_t}.

Although the second parameter is of type pointer to string (@code{char
**}), you cannot treat it as an ordinary string, since it may contain
null characters before the final null character marking the end of the
line.  The return value enables you to distinguish null characters that
@code{getline} read as part of the line, by specifying the size of the
line.  Any characters in the block up to the number of bytes specified
by the return value are part of the line; any characters after that
number of bytes are not.

Here is a short code example that demonstrates how to use @code{getline}
to read a line of text from the keyboard safely.  Try typing more than
100 characters.  Notice that @code{getline} can safely handle your line
of input, no matter how long it is.  Also note that the @code{puts}
command used to display the line of text read will be inadequate if the
line contains any null characters, since it will stop displaying text at
the first null, but that since it is difficult to enter null characters
from the keyboard, this is generally not a consideration.

@findex getline @r{function}
@cindex @code{getline}, example of
@smallexample
@group
#include <stdio.h>

int main()
@{
  int bytes_read;
  int nbytes = 100;
  char *my_string;

  puts ("Please enter a line of text.");
@end group

@group
  /* These 2 lines are the heart of the program. */
  my_string = (char *) malloc (nbytes + 1);
  bytes_read = getline (&my_string, &nbytes, stdin);
@end group

@group
  if (bytes_read == -1)
    @{
      puts ("ERROR!");
    @}
  else
    @{
      puts ("You typed:");
      puts (my_string);
    @}

  return 0;
@}
@end group
@end smallexample



@node getdelim,  , getline, String input
@subsubsection @code{getdelim}

@findex getdelim @r{function}

The @code{getdelim} function is a more general form of the
@code{getline} function; whereas @code{getline} stops reading input at
the first newline character it encounters, the @code{getdelim} function
enables you to specify other delimiter characters than newline.  In
fact, @code{getline} simply calls @code{getdelim} and specifies that the
delimiter character is a newline.

The syntax for @code{getdelim} is nearly the same as that of
@code{getline}, except that the third parameter specifies the delimiter
character, and the fourth parameter is the stream from which to read.
You can exactly duplicate the @code{getline} example in the last section
with @code{getdelim}, by replacing the line

@smallexample
bytes_read = getline (&my_string, &nbytes, stdin);
@end smallexample

@noindent
with the line

@smallexample
bytes_read = getdelim (&my_string, &nbytes, '\n', stdin);
@end smallexample


@node Deprecated string input functions, Formatted string input, String input, String output and input
@subsection Deprecated string input functions

@cindex String input
@cindex Input, string
@cindex Deprecated string input functions
@cindex String input functions, deprecated

The functions in this section are for input of strings from streams, but
they are generally dangerous and should only be called when there is no
alternative.  They are included here because you may come across code
imported from a non-GNU system that uses these unsafe functions.

@menu
* gets::                        
* fgets::                       
@end menu

@node gets, fgets, Deprecated string input functions, Deprecated string input functions
@subsubsection @code{gets}

@findex gets @r{function}

If you want to read a string from standard input, you can use the
@code{gets} function, the name of which stands for ``get string''.
However, this function is @dfn{deprecated} --- that means it is obsolete
and it is strongly suggested you do not use it --- because it is
dangerous.  It is dangerous because it provides no protection against
overflowing the string into which it is saving data.  Programs that use
@code{gets} can actually be a security problem on your computer.  Since
it is sometimes used in older code (which is why the GNU C Library still
provides it), we will examine it briefly; nevertheless, you should
@emph{always} use the function @code{getline} instead.
(@xref{getline}.)

The @code{gets} function takes one parameter, the string in which to
store the data read.  It reads characters from standard input up to the
next newline character (that is, when the user presses @key{RETURN}),
discards the newline character, and copies the rest into the string
passed to it.  If there was no error, it returns the same string (as a
return value, which may be discarded); otherwise, if there was an error,
it returns a null pointer.

Here is a short code example that uses @code{gets}:

@smallexample
@group
#include <stdio.h>

int main()
@{
  char my_string[500];
  printf("Type something.\n");
  gets(my_string);
  printf ("You typed: %s\n", my_string);

  return 0;
@}
@end group
@end smallexample

If you attempt to compile the example above, it will compile and will
run properly, but GCC will warn you against the use of a deprecated
function, as follows:

@smallexample
@group
/tmp/ccPW3krf.o: In function `main':
/tmp/ccPW3krf.o(.text+0x24): the `gets' function
     is dangerous and should not be used.
@end group
@end smallexample

@strong{Remember!}  Never use this function in your own code.  Always
use @code{getline} instead.



@node fgets,  , gets, Deprecated string input functions
@subsubsection @code{fgets}

@findex fgets @r{function}

The @code{fgets} (``file get string'') function is similar to the
@code{gets} function.  This function is @dfn{deprecated} --- that means
it is obsolete and it is strongly suggested you do not use it ---
because it is dangerous.  It is dangerous because if the input data
contains a null character, you can't tell. Don't use @code{fgets} unless
you know the data cannot contain a null. Don't use it to read files
edited by the user because, if the user inserts a null character, you
should either handle it properly or print a clear error message.  Always
use @code{getline} or @code{getdelim} instead of @code{fgets} if you
can.

Rather than reading a string from standard input, as @code{gets} does,
@code{fgets} reads it from a specified stream, up to and including a
newline character.  It stores the string in the string variable passed
to it, adding a null character to terminate the string. This function
takes three parameters: the first is the string into which to read data,
the second is the maximum number of characters to read. (You must supply
at least this many characters of space in the string, or your program
will probably crash, but at least the @code{fgets} function protects
against overflowing the string and creating a security hazard, unlike
@code{gets}.)  The third parameter is the stream from which to read.
The number of characters that @code{fgets} reads is actually one less
than than number specified; it stores the null character in the extra
character space.

If there is no error, @code{fgets} returns the string read as a return
value, which may be discarded.  Otherwise, for example if the stream is
already at end of file, it returns a null pointer.

Unfortunately, like the @code{gets} function, @code{fgets} is
deprecated, in this case because when @code{fgets} cannot tell whether a
null character is included in the string it reads.  If a null character
is read by @code{fgets}, it will be stored in the string along with the
rest of the characters read.  Since a null character terminates a string
in C, C will then consider your string to end prematurely, right before
the first null character.  Only use @code{fgets} if you are certain the
data read cannot contain a null; otherwise, use @code{getline}.

Here is a code example that uses @code{fgets}.  It will create a text
file containing the string @samp{Hidee ho!} plus a newline, read it back
with @code{fgets}, and print it on standard output.  Notice that
although 100 characters are allocated for the string @code{my_string},
and requested to be read in the @code{fgets} call, there are not that
many characters in the file.  The @code{fgets} function only reads the
string up to the newline character; the important thing is to allocate
enough space in the string variable to contain the string to be read.

@findex fgets @r{function}
@cindex @code{findex}, example of
@smallexample
@group
#include <stdio.h>

int main()
@{
  int input_character;
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";
  char my_string[100];
@end group

@group
  my_stream = fopen (my_filename, "w");
  fprintf (my_stream, "Hidee ho!\n");

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);
@end group

@group
  my_stream = fopen (my_filename, "r");
  fgets (my_string, 100, my_stream);

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);

  printf ("%s", my_string);

  return 0;
@}
@end group
@end smallexample




@node Formatted string input, Deprecated formatted string input functions, Deprecated string input functions, String output and input
@subsection Formatted string input

@cindex Formatted string input
@cindex String input, formatted
@cindex Input, string formatted

The formatted string input functions are the opposite of the formatted
string output functions.  Unlike @code{printf} and similar functions,
which generate formatted output, @code{scanf} and its friends parse
formatted input.  Like the opposite functions, each accepts, as a
parameter, a template string that contains conversion specifiers.  In
the case of @code{scanf} and related functions, however, the conversion
specifiers are meant to match patterns in an input string, such as
integers, floating point numbers, and character sequences, and store the
values read in variables.


@menu
* sscanf::                      
* Formatted input conversion specifiers::  
@end menu

@node sscanf, Formatted input conversion specifiers, Formatted string input, Formatted string input
@subsubsection @code{sscanf}

@findex sscanf @r{function}

The @code{sscanf} function accepts a string from which to read input,
then, in a manner similar to @code{printf} and related functions, it
accepts a template string and a series of related arguments.  It tries
to match the template string to the string from which it is reading
input, using conversion specifier like those of @code{printf}.

The @code{sscanf} function is just like the deprecated parent
@code{scanf} function, except that the first argument of @code{sscanf}
specifies a string from which to read, whereas @code{scanf} can only
read from standard input.  Reaching the end of the string is treated as
an end-of-file condition.

Here is an example of @code{sscanf} in action:

@smallexample
sscanf (input_string, "%as %as %as", &str_arg1, &str_arg2, &str_arg3);
@end smallexample

If the string @code{sscanf} is scanning overlaps with any of the arguments,
unexpected results will follow, as in the following example.  Don't do this!

@smallexample
sscanf (input_string, "%as", &input_string);
@end smallexample

Here is a good code example that parses input from the user with
@code{sscanf}.  It prompts the user to enter three integers separated by
whitespace, then reads an arbitrarily long line of text from the user
with @code{getline}.  It then checks whether exactly three arguments
were assigned by @code{sscanf}.  If the line read does not contain the
data requested (for example, if it contains a floating-point number or
any alphabetic characters), the program prints an error message and prompts
the user for three integers again.  When the program finally receives
exactly the data it was looking for from the user, it prints out a message
acknowledging the input, and then prints the three integers.

It is this flexibility of input and great ease of recovery from errors
that makes the @code{getline}/@code{sscanf} combination so vastly
superior to @code{scanf} alone.  Simply put, you should never use
@code{scanf} where you can use this combination instead.

@findex sscanf @r{function}
@cindex @code{sscanf} example
@smallexample
@group
#include <stdio.h>

int main()
@{
  int nbytes = 100;
  char *my_string;
  int int1, int2, int3;
  int args_assigned;
@end group

@group
  args_assigned = 0;

  while (args_assigned != 3)
    @{
      puts ("Please enter three integers separated by whitespace.");
      my_string = (char *) malloc (nbytes + 1);
      getline (&my_string, &nbytes, stdin);
      args_assigned = sscanf (my_string, "%d %d %d", &int1, &int2, &int3);
      if (args_assigned != 3)
	puts ("\nInput invalid!");
    @}
@end group

@group
  printf ("\nThanks!\n%d\n%d\n%d\n", int1, int2, int3);

  return 0;
@}
@end group
@end smallexample

Template strings for @code{sscanf} and related functions are somewhat
more free-form than those for @code{printf}.  For example, most
conversion specifiers ignore any preceding whitespace.  Further, you
cannot specify a precision for @code{sscanf} conversion specifiers, as
you can for those of @code{printf}.

@cindex @code{sscanf}, common errors with
Another important difference between @code{sscanf} and @code{printf} is
that the arguments to @code{sscanf} must be pointers; this allows
@code{sscanf} to return values in the variables they point to.  If you
forget to pass pointers to @code{sscanf}, you may receive some strange
errors, and it is easy to forget to do so; therefore, this is one of the
first things you should check if code containing a call to @code{sscanf}
begins to go awry.

@cindex Template string, @c{sscanf}
@cindex Formatted input conversion specifiers
@cindex Input conversion specifiers, formatted
@cindex Conversion specifiers, formatted input
A @code{sscanf} template string can contain any number of any number of
whitespace characters, any number of ordinary, non-whitespace
characters, and any number of conversion specifiers starting with
@samp{%}.  A whitespace character in the template string matches zero or
more whitespace characters in the input string.  Ordinary,
non-whitespace characters must correspond exactly in the template string
and the input stream; otherwise, a matching error occurs.  Thus, the
template string @samp{" foo "} matches @samp{"foo"} and @samp{"   foo   "},
but not @samp{" food "}.

If you create an input conversion specifier with invalid syntax, or if
you don't supply enough arguments for all the conversion specifiers in
the template string, your code may do unexpected things, so be careful.
Extra arguments, however, are simply ignored.

Conversion specifiers start with a percent sign (@samp{%}) and terminate
with a character from the following table:



@node Formatted input conversion specifiers,  , sscanf, Formatted string input
@subsubsection Formatted input conversion specifiers

@cindex Formatted input conversion specifiers
@cindex Input conversion specifiers, formatted
@cindex Conversion specifiers, formatted input

@table @samp

@findex c @r{input conversion specifier}
@item c
Matches a fixed number of characters.  If you specify a maximum field
width (see below), that is how many characters will be matched;
otherwise, @samp{%c} matches one character.  This conversion does not
append a null character to the end of the text it reads, as does the
@samp{%s} conversion.  It also does not skip whitespace characters, but
reads precisely the number of characters it was told to, or generates a
matching error if it cannot.

@findex d @r{input conversion specifier}
@item d
Matches an optionally signed decimal integer, containing the
following sequence:

@enumerate

@item An optional plus or minus sign (@samp{+} or @samp{-}).

@item One or more decimal digits.

@end enumerate

Note that @samp{%d} and @samp{%i} are not synonymous for @code{scanf},
as they are for @code{printf}.

@findex  @r{input conversion specifier}
@item e
Matches an optionally signed floating-point number, containing the
following sequence:

@enumerate

@item An optional plus or minus sign (@samp{+} or @samp{-}).

@item A floating-point number in decimal or hexadecimal format.

@itemize @bullet

@item The decimal format is a sequence of one or more decimal digits,
optionally containing a decimal point character (usually @samp{.}),
followed by an optional exponent part, consisting of a character
@samp{e} or @samp{E}, an optional plus or minus sign, and a sequence of
decimal digits.

@item The hexadecimal format is a @samp{0x} or @samp{0X}, followed by a
sequence of one or more hexadecimal digits, optionally containing a
decimal point character, followed by an optional binary-exponent part,
consisting of a character @samp{p} or @samp{P}, an optional plus or
minus sign, and a sequence of digits.

@end itemize

@end enumerate

@findex E @r{input conversion specifier}
@item E
Same as @samp{e}.

@findex f @r{input conversion specifier}
@item f
Same as @samp{e}.

@findex g @r{input conversion specifier}
@item g
Same as @samp{e}.

@findex G @r{input conversion specifier}
@item G
Same as @samp{e}.

@findex i @r{input conversion specifier}
@item i
Matches an optionally signed integer, containing the following sequence:

@enumerate

@item An optional plus or minus sign (@samp{+} or @samp{-}).

@item A string of characters representing an unsigned integer.

@itemize

@item If the string begins with @samp{0x} or @samp{0X}, the number is
assumed to be in hexadecimal format, and the rest of the string must contain
hexadecimal digits.

@item Otherwise, if the string begins with @samp{0}, the number is
assumed to be in octal format (base eight), and the rest of the
string must contain octal digits.

@item Otherwise, the number is assumed to be in decimal format, and the rest
of the string must contain decimal digits.

@end itemize

@end enumerate

Note that @samp{%d} and @samp{%i} are not synonymous for @code{scanf},
as they are for @code{printf}.  You can print integers in this syntax
with @code{printf} by using the @samp{#} flag character with the @samp{%x}
or @samp{%d} output conversions.  (@xref{printf}.)

@findex s @r{input conversion specifier}
@item s
Matches a string of non-whitespace characters.  It skips initial
whitespace, but stops when it meets more whitespace after it has read
something.  It stores a null character at the end of the text that it
reads, to mark the end of the string.  (@xref{String overflows with
scanf}, for a warning about using this conversion.)

@findex x @r{input conversion specifier}
@item x
Matches an unsigned integer in hexadecimal format.  The string matched
must begin with @samp{0x} or @samp{0X}, and the rest of the string must
contain hexadecimal digits.

@findex X @r{input conversion specifier}
@item X
Same as @samp{x}.

@findex [ @r{input conversion specifier}
@item [
Matches a string containing an arbitrary set of characters.  For
example, @samp{%12[0123456789]} means to read a string with a maximum
field width of 12, containing characters from the set @samp{0123456789}
--- in other words, twelve decimal digits.  An embedded @samp{-}
character means a range of characters; thus @samp{%12[0-9]} means the
same thing as the last example.  Preceding the characters in the square
brackets with a caret (@samp{^}) means to read a string @emph{not}
containing the characters listed.  Thus, @samp{%12[^0-9]} means to read
a twelve-character string not containing any decimal digit.
(@xref{String overflows with scanf}, for a warning about using this
conversion.)

@findex % @r{input conversion specifier}
@item %
Matches a percent sign.  Does not correspond to an argument, and does
not permit flags, field width, or type modifier to be specified (see
below).

@end table

In between the percent sign (@samp{%}) and the input conversion
character, you can place some combination of the following modifiers, in
sequence.  (Note that the percent sign conversion (@samp{%%}) doesn't
use arguments or modifiers.)

@itemize @bullet

@findex * @r{input conversion specifier modifier}
@item An optional @samp{*} flag.  This flag specifies that a match should be made
between the conversion specifier and an item in the input stream, but
that the value should @emph{not} then be assigned to an argument.

@findex a @r{input conversion specifier modifier}
@item An optional @samp{a} flag, valid with string conversions only.
This is a GNU extension to @code{scanf} that requests allocation of a
buffer long enough to safely store the string that was
read. (@xref{String overflows with scanf}, for information on how to use
this flag.)

@findex ' @r{input conversion specifier modifier}
@item An optional @samp{'} flag. This flag specifies that the number read will be grouped
according to the rules currently specified on your system.  For example,
in the United States, this usually means that @samp{1,000} will be read
as one thousand.

@item An optional decimal integer that specifies the maximum field width.
The @code{scanf} function will stop reading characters from the input stream
either when this maximum is reached, or when a non-matching character is read,
whichever comes first.  Discarded initial whitespace does not count toward
this width; neither does the null character stored by string input conversions
to mark the end of the string.

@item An optional type modifier character from the following table.
(The default type of the corresponding argument is @code{int *} for the
@samp{%d} and @samp{%i} conversions, @code{unsigned int *} for @samp{%x}
and @samp{%X}, and @code{float *} for @samp{%e} and its synonyms.  You can use these
type modifiers to specify otherwise.)

@table @samp

@findex h @r{input conversion specifier modifier}
@item h
Specifies that the argument to which the value read should be assigned is
of type @code{short int *} or @code{unsigned short int *}. Valid for the
@samp{%d} and @samp{%i} conversions.

@findex l @r{input conversion specifier modifier}
@item l
For the @samp{%d} and @samp{%i} conversions, specifies that the argument
to which the value read should be assigned is of type @code{long int *}
or @code{unsigned long int *}.  For the @samp{%e} conversion and its
synonyms, specifies that the argument is of type @code{double *}.

@findex L @r{input conversion specifier modifier}
@item L
For the @samp{%d} and @samp{%i} conversions, specifies that the argument
to which the value read should be assigned is of type @code{long long int *}
or @code{unsigned long long int *}.  On systems that do not have
extra-long integers, this has the same effect as @samp{l}.

For the @samp{%e} conversion and
its synonyms, specifies that the argument is of type @code{long double
*}.

@findex ll @r{input conversion specifier modifier}
@item ll
Same as @samp{L}, for the @samp{%d} and @samp{%i} conversions.

@findex q @r{input conversion specifier modifier}
@item q
Same as @samp{L}, for the @samp{%d} and @samp{%i} conversions.

@findex z @r{input conversion specifier modifier}
@item z
Specifies that the argument to which the value read should be assigned
is of type @code{size_t}.  (The @code{size_t} type is used to specify
the sizes of blocks of memory, and many functions in this chapter use
it.)  Valid for the @samp{%d} and @samp{%i} conversions.

@end table

@end itemize



@node Deprecated formatted string input functions, fscanf, Formatted string input, String output and input
@subsection Deprecated formatted string input functions

@cindex Deprecated formatted string input functions
@cindex Formatted string input functions, deprecated
@cindex String input functions, deprecated formatted
@cindex Input functions, string, deprecated formatted

These formatted string input functions are generally dangerous and
should only be used when there is no alternative.  However, because you
may encounter them when importing older code or code from non-GNU
systems, and because the @code{scanf} function is in a sense the parent
of the safe @code{sscanf} function, it is important that you know about
them.

@menu
* scanf::                       
* String overflows with scanf::  
@end menu

@node scanf, String overflows with scanf, Deprecated formatted string input functions, Deprecated formatted string input functions
@subsubsection @code{scanf}

@findex scanf @r{function}

The first of the functions we will examine is @code{scanf} (``scan
formatted'').  The @code{scanf} function is considered dangerous for a
number of reasons.  First, if used improperly, it can cause your program
to crash by reading character strings that overflow the string variables
meant to contain them, just like @code{gets}.  (@xref{gets}.)  Second,
@code{scanf} can hang if it encounters unexpected non-numeric input
while reading a line from standard input.  Finally, it is difficult to
recover from errors when the @code{scanf} template string does not match
the input exactly.

If you are going to read input from the keyboard, it is far better to
read it with @code{getline} and parse the resulting string with
@code{sscanf} (``string scan formatted'') than to use @code{scanf}
directly.  However, since @code{sscanf} uses nearly the same syntax as
@code{sscanf}, as does the related @code{fscanf}, and since @code{scanf}
is a standard C function, it is important to learn about it.

If @code{scanf} cannot match the template string to the input string, it
will return immediately --- and it will leave the first non-matching
character as the next character to read from the stream.  This is called
a @dfn{matching error}, and is the main reason @code{scanf} tends to
hang when reading input from the keyboard; a second call to @code{scanf}
will almost certainly choke, since the file position indicator of the
stream is not pointing where @code{scanf} will expect it to.  Normally,
@code{scanf} returns the number of assignments made to the arguments it
was passed, so check the return value to see if @code{scanf} found all
the items you expected.



@menu
* String overflows with scanf::  
@end menu

@node String overflows with scanf,  , scanf, Deprecated formatted string input functions
@subsubsection String overflows with scanf

@findex scanf @r{function}
@cindex @code{scanf}, string overflows with
@cindex String overflows with @code{scanf}

If you use the @samp{%s} and @samp{%[} conversions improperly, then the
number of characters read is limited only by where the next whitespace
character appears.  This almost cetainly means that invalid input could
make your program crash, because input too long would overflow whatever
buffer you have provided for it.  No matter how long your buffer is, a
user could always supply input that is longer.  A well-written program
reports invalid input with a comprehensible error message, not with a
crash.

Fortunately, it is possible to avoid @code{scanf} buffer overflow
by either specifying a field width or using the @samp{a} flag.

When you specify a field width, you need to provide a buffer (using
@code{malloc} or a similar function) of type @code{char *}.
(@xref{Memory allocation}, for more information on @code{malloc}.)
You need to make sure that the field width you specify does not exceed
the number of bytes allocated to your buffer.

On the other hand, you do not need to allocate a buffer if you specify
the @samp{a} flag character --- @code{scanf} will do it for you.  Simply
pass @code{scanf} an pointer to an unallocated variable of type
@code{char *}, and @code{scanf} will allocate however large a buffer the
string requires, and return the result in your argument.  This is a
GNU-only extension to @code{scanf} functionality.

Here is a code example that shows first how to safely read a string of
fixed maximum length by allocating a buffer and specifying a field width, then
how to safely read a string of any length by using the @samp{a} flag.

@smallexample
@group
#include <stdio.h>

int main()
@{
  int bytes_read;
  int nbytes = 100;
  char *string1, *string2;

  string1 = (char *) malloc (25);

  puts ("Please enter a string of 20 characters or fewer.");
  scanf ("%20s", string1);
  printf ("\nYou typed the following string:\n%s\n\n", string1);

  puts ("Now enter a string of any length.");
  scanf ("%as", &string2);
  printf ("\nYou typed the following string:\n%s\n", string2);

  return 0;
@}
@end group
@end smallexample

There are a couple of things to notice about this example program.
First, notice that the second argument passed to the first @code{scanf}
call is @code{string1}, not @code{&string1}.  The @code{scanf} function
requires pointers as the arguments corresponding to its conversions, but
a string variable is already a pointer (of type @code{char *}), so you
do not need the extra layer of indirection here.  However, you do need
it for the second call to @code{scanf}.  We passed it an argument of
@code{&string2} rather than @code{string2}, because we are using the
@samp{a} flag, which allocates a string variable big enough to contain
the characters it read, then returns a pointer to it.

The second thing to notice is what happens if you type a string of more
than 20 characters at the first prompt.  The first @code{scanf} call
will only read the first 20 characters, then the second @code{scanf}
call will gobble up all the remaining characters without even waiting
for a response to the second prompt.  This is because @code{scanf} does
not read a line at a time, the way the @code{getline} function does.
Instead, it immediately matches attempts to match its template string to
whatever characters are in the @code{stdin} stream.  The second
@code{scanf} call matches all remaining characters from the overly-long
string, stopping at the first whitespace character.  Thus, if you type
@samp{12345678901234567890xxxxx} in response to the first prompt, the
program will immediately print the following text without pausing:

@smallexample
@group
You typed the following string:
12345678901234567890

Now enter a string of any length.

You typed the following string:
xxxxx
@end group
@end smallexample

(@xref{sscanf}, for a better example of how to parse input from the user.)



@node fscanf,  , Deprecated formatted string input functions, String output and input
@subsection @code{fscanf}

@findex fscanf @r{function}

The @code{fscanf} function is just like the @code{scanf} function,
except that the first argument of @code{fscanf} specifies a stream from
which to read, whereas @code{scanf} can only read from standard input.

Here is a code example that generates a text file containing five
numbers with @code{fprintf}, then reads them back in with @code{fscanf}.
Note the use of the @samp{#} flags in the @samp{%#d} conversions in the
@code{fprintf} call; this is a good way to generate data in a format
that @code{scanf} and related functions can easily read with the
@samp{%i} input conversion.

@smallexample
@group
#include <stdio.h>
#include <errno.h>

int main()
@{
  float f1, f2;
  int i1, i2;
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";
@end group

@group
  my_stream = fopen (my_filename, "w");
  fprintf (my_stream, "%f %f %#d %#d", 23.5, -12e6, 100, 5);

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);
@end group

@group
  my_stream = fopen (my_filename, "r");
  fscanf (my_stream, "%f %f %i %i", &f1, &f2, &i1, &i2);

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);
@end group

@group
  printf ("Float 1 = %f\n", f1);
  printf ("Float 2 = %f\n", f2);
  printf ("Integer 1 = %d\n", i1);
  printf ("Integer 2 = %d\n", i2);

  return 0;
@}
@end group
@end smallexample

This code example prints the following output on the screen:

@smallexample
@group
Float 1 = 23.500000
Float 2 = -12000000.000000
Integer 1 = 100
Integer 2 = 5
@end group
@end smallexample

If you examine the text file @file{snazzyjazz.txt}, you will see it
contains the following text:

@smallexample
23.500000 -12000000.000000 100 5
@end smallexample





@node Single-character input and output, Programming with pipes, String output and input, Input and output
@section Single-character input and output

@cindex Single-character input
@cindex Single-character output
@cindex Input, single-character
@cindex Output, single-character

This section covers the use of several functions for the input and output of
single characters from standard input and output or files.

@menu
* getchar::                     
* putchar::                     
* getc and fgetc::              
* putc and fputc::              
* ungetc::                      
@end menu


@node getchar, putchar, Single-character input and output, Single-character input and output
@subsection @code{getchar}

@findex getchar @r{function}

If you want to read a single character from standard input, you can use the
@code{getchar} function.  This function takes no parameters, but
reads the next character from @file{stdin} as an @code{unsigned char}, and
returns its value, converted to an integer. Here is a short program that uses
@code{getchar}:

@smallexample
@group
#include <stdio.h>

int main()
@{
  int input_character;

  printf("Hit any key, then hit RETURN.\n");
  input_character = getchar();
  printf ("The key you hit was '%c'.\n", input_character);
  printf ("Bye!\n");

  return 0;
@}
@end group
@end smallexample

Note that because @code{stdin} is line-buffered, @code{getchar} will not
return a value until you hit the @key{RETURN} key.  However,
@code{getchar} still only reads one character from @code{stdin}, so if
you type @samp{hellohellohello} at the prompt, the program above will
still only get once character.  It will print the following line, and
then terminate:

@smallexample
@group
The key you hit was 'h'.
Bye!
@end group
@end smallexample


@node putchar, getc and fgetc, getchar, Single-character input and output
@subsection @code{putchar}

@findex putchar @r{function}

If you want to print a single character on standard output, you can use
the @code{putchar} function.  It takes a single integer parameter
containing a character (the argument can be a single-quoted text
character, as in the example below), and sends the character to
@code{stdout}.  If a write error occurs, @code{putchar} returns
@code{EOF}; otherwise, it returns the integer it was passed. This can
simply be disregarded, as in the example below.

Here is a short code example that makes use of @code{putchar}.  It
prints an @samp{X}, a space, and then a line of ten exclamation marks
(@samp{!!!!!!!!!!}) on the screen, then outputs a newline so that the
next shell prompt will not occur on the same line.  Notice the use of
the @code{for} loop; by this means, @code{putchar} can be used not just
for one character, but multiple times.

@smallexample
@group
#include <stdio.h>

int main()
@{
  int i;
@end group

@group
  putchar ('X');
  putchar (' ');
  for (i=1; i<=10; i++)
    @{
      putchar ('!');
    @}
  putchar ('\n');
@end group

@group
  return 0;
@}
@end group
@end smallexample



@node getc and fgetc, putc and fputc, putchar, Single-character input and output
@subsection @code{getc} and @code{fgetc}

@findex getc @r{function}
@findex fgetc @r{function}

If you want to read a single character from a stream other than
@code{stdin}, you can use the @code{getc} function.  This function is
very similar to @code{getchar}, but accepts an argument that specifies
the stream from which to read.  It reads the next character from the
specified stream as an @code{unsigned char}, and returns its value,
converted to an integer.  If a read error occurs or the end of the file
is reached, @code{getc} returns @code{EOF} instead.

Here is a code example that makes use of @code{getc}.  This code example
creates a text file called @file{snazzyjazz.txt} with @code{fopen},
writes the alphabet in upper-case letters plus a newline to it with
@code{fprintf}, reads the file position with @code{ftell}, and gets the
character there with @code{getc}.  It then seeks position 25 with
@code{fseek} and repeats the process, attempts to read past the end of
the file and reports end-of-file status with @code{feof}, and generates
an error by attempting to write to a read-only stream.  It then reports
the error status with @code{ferror}, returns to the start of the file
with @code{rewind} and prints the first character, and finally attempts
to close the file and prints a status message indicating whether it
could do so.

@xref{File position}, for information on @code{ftell}, @code{fseek}, and
@code{rewind}.  @xref{End-of-file and error functions}, for more
information on @code{feof} and @code{ferror}.

@smallexample
@group
#include <stdio.h>

int main()
@{
  int input_char;
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";
  long position;
  int eof_status, error_status, close_error;
@end group

@group
  my_stream = fopen (my_filename, "w");
  fprintf (my_stream, "ABCDEFGHIJKLMNOPQRSTUVWXYZ");

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);
@end group

@group
  printf ("Opening file...\n");
  my_stream = fopen (my_filename, "r");
  position = ftell (my_stream);
  input_char = getc (my_stream);
  printf ("Character at position %d = '%c'.\n\n", position, input_char);
@end group

@group
  printf ("Seeking position 25...\n");
  fseek (my_stream, 25, SEEK_SET);
  position = ftell (my_stream);
  input_char = getc (my_stream);
  printf ("Character at position %d = '%c'.\n\n", position, input_char);
@end group

@group
  printf ("Attempting to read again...\n");
  input_char = getc (my_stream);
  eof_status = feof (my_stream);
  printf ("feof returns %d.\n\n", eof_status);
@end group

@group
  error_status = ferror (my_stream);
  printf ("ferror returns %d.\n", error_status);
  printf ("Attempting to write to this read-only stream...\n");
  putc ('!', my_stream);
  error_status = ferror (my_stream);
  printf ("ferror returns %d.\n\n", error_status);
@end group

@group
  printf ("Rewinding...\n");
  rewind (my_stream);
  position = ftell (my_stream);
  input_char = getc (my_stream);
  printf ("Character at position %d = '%c'.\n", position, input_char);
@end group

@group
  close_error = fclose (my_stream);

  /* Handle fclose errors */
  if (close_error != 0)
    @{
      printf ("File could not be closed.\n");
    @}
  else
    @{
      printf ("File closed.\n");
    @}
  
  return 0;
@}
@end group
@end smallexample

There is another function in the GNU C Library called @code{fgetc}.  It
is identical to @code{getc} in most respects, except that @code{getc} is
usually implemented as a macro function and is highly optimised, so is
preferable in most situations.  (In situations where you are reading
from standard input, @code{getc} is about as fast as @code{fgetc}, since
humans type slowly compared to how fast computers can read their input,
but when you are reading from a stream that is not interactively
produced by a human, @code{fgetc} is probably better.)


@node putc and fputc, ungetc, getc and fgetc, Single-character input and output
@subsection @code{putc} and @code{fputc}

@findex putc @r{function}
@findex fputc @r{function}

If you want to write a single character to a stream other than
@code{stdout}, you can use the @code{putc} function.  This function is
very similar to @code{putchar}, but accepts an argument that specifies
the stream to which to write.  It takes a single integer parameter containing
a character (the argument can be a single-quoted text character, as in the
example below), and sends the character to the specified stream.  If a write error
occurs, @code{putc} returns @code{EOF}; otherwise, it returns the integer
it was passed. This can simply be disregarded, as in the example below.

The following code example creates a text file called
@file{snazzyjazz.txt}.  It then writes an @samp{X}, a space, and then a
line of ten exclamation marks (@samp{!!!!!!!!!!}) to the file, and a
newline character to it using the @code{putc} function.  Notice the use
of the @code{for} loop; by this means, @code{putchar} can be used not
just for one character, but multiple times.  , then writes ten
exclamation mark characters (@samp{!!!!!!!!!!})

@smallexample
@group
#include <stdio.h>

int main()
@{
  int i;
  FILE *my_stream;
  char my_filename[] = "snazzyjazz.txt";

  my_stream = fopen (my_filename, "w");
@end group

@group
  putc ('X', my_stream);
  putc (' ', my_stream);
  for (i=1; i<=10; i++)
    @{
      putc ('!', my_stream);
    @}
  putc ('\n', my_stream);
@end group

@group
  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);

  return 0;
@}
@end group
@end smallexample

There is another function in the GNU C Library called @code{fputc}.  It
is identical to @code{putc} in most respects, except that @code{putc} is
usually implemented as a macro function and is highly optimised, so is
preferable in most situations.



@node ungetc,  , putc and fputc, Single-character input and output
@subsection @code{ungetc()}

@findex ungetc @r{function}
@cindex File position indicator
@cindex Unreading characters
@cindex Pushing back characters

Every time a character is read from a stream by a function like
@code{getc}, the file position indicator advances by 1.  It is possible
to reverse the motion of the file position indicator with the function
@code{ungetc}, which steps the file position indicator back by one
byte within the file and reverses the effect of the last character
read operation.  (This is called @dfn{unreading} the character or
@dfn{pushing it back} onto the stream.)

The intended purpose is to leave the indicator in the correct file
position when other functions have moved too far ahead in the stream.
Programs can therefore @dfn{peek ahead}, or get a glimpse of the input
they will read next, then reset the file position with @code{ungetc}.

@cindex Pushback
On GNU systems, you cannot call @code{ungetc} twice in a row without
reading at least one character in between; in other words, GNU only
supports one character of @dfn{pushback}.

@findex fseek @r{function}
@findex rewind @r{function}
Pushing back characters does not change the file being accessed at all;
@code{ungetc} only affects the stream buffer, not the file.  If
@code{fseek}, @code{rewind}, or some other file positioning function is
called, any character due to be pushed back by @code{ungetc} is
discarded.

@findex EOF @r{character}
Unreading a character on a stream that is at end-of-file resets the
end-of-file indicator for the stream, because there is once again a
character available to be read.  However, if the character pushed back
onto the stream is @code{EOF}, @code{ungetc} does nothing and just
returns @code{EOF}.

Here is a code example that reads all the whitespace at the beginning of
a file with @code{getc}, then backs up one byte to the first
non-whitespace character, and reads all following characters up to a
newline character with the @code{getline} function. (@xref{getline}, for
more information on that function.)

@smallexample
@group
#include <stdio.h>

int main()
@{
  int in_char;
  FILE *my_stream;
  char *my_string = NULL;
  size_t nchars = 0;
@end group

@group
  my_stream = fopen ("snazzyjazz.txt", "w");
  fprintf (my_stream, "          Here's some non-whitespace.\n");

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);
@end group

@group
  my_stream = fopen ("snazzyjazz.txt", "r");

  /* Skip all whitespace in stream */
  do
    in_char = getc (my_stream);
  while (isspace (in_char));
@end group

@group
  /* Back up to first non-whitespace character */
  ungetc (in_char, my_stream);

  getline (&my_string, &nchars, my_stream);

  /* Close stream; skip error-checking for brevity of example */
  fclose (my_stream);

  printf ("String read:\n");
  printf ("%s", my_string);

  return 0;
@}
@end group
@end smallexample

@noindent
The code example will skip all initial whitespace in the file
@file{snazzyjazz.txt}, and display the following text on standard
output:

@smallexample
@group
String read:
Here's some non-whitespace.
@end group
@end smallexample



@node Programming with pipes, Low-level file routines, Single-character input and output, Input and output
@section Programming with pipes

@cindex Pipes, programming with

There may be times when you will wish to manipulate other programs on a
GNU system from within your C program.  One good way to do so is the
facility called a @dfn{pipe}.  Using pipes, you can read from or write
to any program on a GNU system that writes to standard output and reads
from standard input.  (In the ancestors of modern GNU systems, pipes
were frequently files on disk; now they are usually streams or something
similar.  They are called ``pipes'' because people usually visualise
data going in at one end and coming out at the other.)

For example, you might wish to send output from your program to a
printer.  As mentioned in the introduction to this chapter, each printer
on your system is assigned a device name such as @file{/dev/lp0}.  Pipes
provide a better way to send output to the printer than writing directly
to the device, however.

Pipes are useful for many things, not just sending output to the
printer.  Suppose you wish to list all programs and processes running on
your computer that contain the string @samp{init} in their names.  To do
so at the GNU/Linux command line, you would type something like the
following command:

@smallexample
@group
ps -A | grep init
@end group
@end smallexample

@cindex Pipe symbol (@samp{|})
@pindex | @r{(pipe symbol)}
@pindex ps @r{command}
@pindex grep @r{command}

This command line takes the output of the @command{ps -A} command, which lists
all running processes, and pipes it with the pipe symbol (@samp{|}) to the 
@command{grep init} command, which returns all lines that were passed to it
that contain the string @samp{init}.  The output of this whole process will 
probably look something like this on your system:

@smallexample
@group
    1 ?        00:00:11 init
 4884 tty6     00:00:00 xinit
@end group
@end smallexample

@findex popen @r{function}
@findex pclose @r{function}
The pipe symbol @samp{|} is very handy for command-line pipes and pipes
within shell scripts, but it is also possible to set up and use pipes
within C programs.  The two main C functions to remember in this regard
are @code{popen} and @code{pclose}.

The @code{popen} function accepts as its first argument a string
containing a shell command, such as @command{lpr}.  Its second argument
is a string containing either the mode argument @samp{r} or @samp{w}.
If you specify @samp{r}, the pipe will be open for reading; if you
specify @samp{w}, it will be open for writing.  The return value is a
stream open for reading or writing, as the case may be; if there is an
error, @code{popen} returns a null pointer.

The @code{pclose} function closes a pipe opened by @code{popen}.  It
accepts a single argument, the stream to close.  It waits for the stream
to close, and returns the status code returned by the program that was
called by @code{popen}.

If you open the pipe for reading or writing, in between the @code{popen}
and @code{pclose} calls, it is possible to read from or write to the
pipe in the same way that you might read from or write to any other
stream, with high-level input/output calls such as @code{getdelim},
@code{fprintf} and so on.

The following program example shows how to pipe the output of the
@command{ps -A} command to the @command{grep init} command, exactly
as in the GNU/Linux command line example above.  The output of this
program should be almost exactly the same as sample output shown
above.

@smallexample
@group
#include <stdio.h>
#include <stdlib.h>

int
main ()
@{
  FILE *ps_pipe;
  FILE *grep_pipe;

  int bytes_read;
  int nbytes = 100;
  char *my_string;
@end group

@group
  /* Open our two pipes */
  ps_pipe = popen ("ps -A", "r");
  grep_pipe = popen ("grep init", "w");
@end group

@group
  /* Check that pipes are non-null, therefore open */
  if ((!ps_pipe) || (!grep_pipe))
    @{
      fprintf (stderr,
               "One or both pipes failed.\n");
      return EXIT_FAILURE;
    @}
@end group

@group
  /* Read from ps_pipe until two newlines */
  my_string = (char *) malloc (nbytes + 1);
  bytes_read = getdelim (&my_string, &nbytes, "\n\n", ps_pipe);
@end group

@group
  /* Close ps_pipe, checking for errors */
  if (pclose (ps_pipe) != 0)
    @{
      fprintf (stderr,
               "Could not run 'ps', or other error.\n");
    @}
@end group

@group  
  /* Send output of 'ps -A' to 'grep init', with two newlines */
  fprintf (grep_pipe, "%s\n\n", my_string);
@end group

@group
  /* Close grep_pipe, cehcking for errors */
  if (pclose (grep_pipe) != 0)
    @{
      fprintf (stderr,
               "Could not run 'grep', or other error.\n");
    @}
@end group

@group
  /* Exit! */
  return 0;
@}
@end group
@end smallexample




@node Low-level file routines, Questions 16, Programming with pipes, Input and output
@section Low-level file routines

@cindex Low-level file functions
@cindex File functions, low-level

High-level file routines such as those already described are usually
convenient and easy to use.  However, low-level file routines such as
the ones in this section have some advantages.  For example, they do not
treat all file input/output as text streams, as the high-level routines
do; for that reason, working with binary files may be easier using
low-level routines.  For another thing, low-level routines do not buffer
their input and output, so you will never need to remember to flush your
streams with @code{fflush} or similar functions, as you sometimes must
with high-level routines.

Unfortunately, because low-level routines work at a lower level of
abstraction, they can be tricky, even dangerous to use --- that is to
say, if used incorrectly, they may corrupt your data or cause your
program to terminate unexpectedly; never fear, they will not explode
your monitor or cause your computer to become sapient and attempt world
domination.

@cindex File descriptors
As mentioned, low-level file routines do not use text streams; instead,
the connection they open to your file is an integer called a @dfn{file
descriptor}.  You pass the file descriptor that designates your file to
most low-level file routines, just as you pass the stream that
designates your file to most high-level file routines.  For example,
while the low-level @code{open} function takes a filename string to open a file, the matched
@code{close} function takes the file descriptor returned by @code{open}:

@smallexample
@group
my_file_descriptor = open ("foo_file", O_RDONLY);
close_err = close (my_file_descriptor);
@end group
@end smallexample

@menu
* Usual file name errors::      
* Opening files at a low level::  
* Closing files at a low level::  
* Reading files at a low level::  
* Writing files at a low level::  
* Finding file positions at a low level::  
* Deleting files at a low level::  
* Renaming files at a low level::  
@end menu

@node Usual file name errors, Opening files at a low level, Low-level file routines, Low-level file routines
@subsection Usual file name errors

@cindex Usual file name errors
@cindex File name errors, usual
Most low-level file functions return some kind of error flag if they
cannot perform the action you request, for example, if they cannot parse
the file name or find the file.  However, to discover @emph{which} error
or @emph{what kind of} error has occurred, you must frequently refer to the
system variable @code{errno}.  This is an integer specifying the most recent
error that has occurred.  Macros for values of @code{errno} are listed below.
They are all defined in the GNU C Library.

The word @dfn{component} below refers to part of a full file name.  For
example, in the file name @file{/home/fred/snozzberry.txt}, @file{fred}
is a component that designates a subdirectory of the directory
@file{/home}, and @file{snozzberry.txt} is the name of the file proper.

Most functions that accept file name arguments can detect the following
error conditions.  These are known as the @dfn{usual file name errors}.
The names of the errors, such as @code{EACCES}, are compounded of 
@samp{E} for ``error'' and a term indicating the type of error, such as 
@samp{ACCES} for ``access''.

@table @code

@findex EACCES @r{file name error}
@item EACCES
The program is not permitted to search within one of the directories in
the file name.

@findex ENAMETOOLONG @r{file name error}
@item ENAMETOOLONG
Either the full file name is too long, or some component is too long.
GNU does not limit the overall length of file names, but depending on
which file system you are using, the length of component names may be
limited.  (For example, you may be running GNU/Linux but accessing a
Macintosh HFS disk; the names of Macintosh files cannot be longer than
31 characters.)

@findex ENOENT @r{file name error}
@item ENOENT
Either some component of the file name does not exist, or some component is
a symbolic link whose target file does not exist.

@c RWHE
@c Explain symbolic links somewhere.

@findex ENOTDIR @r{file name error}
@item ENOTDIR
One of the file name components that is supposed to be a directory is
not a directory.

@findex ELOOP @r{file name error}
@item ELOOP
Too many symbolic links had to be followed to find the file.
(GNU has a limit on how many symbolic links can be followed at once,
as a basic way to detect recursive (looping) links.)

@end table

@findex m @r{output conversion specifier}
You can display English text for each of these errors with the @samp{m}
conversion specifier of the @code{printf} function, as in the following 
short example.

@smallexample
@group
errno = EACCES;
printf ("errno string (EACCES): %m\n");
@end group
@end smallexample

@noindent 
This example prints the following string:

@smallexample
@group
errno string (EACCES): Permission denied
@end group
@end smallexample

@noindent
@xref{Formatted output conversion specifiers}, for more information
on the @samp{m} conversion specifier.


@node Opening files at a low level, Closing files at a low level, Usual file name errors, Low-level file routines
@subsection Opening files at a low level

@cindex Opening files at a low level
@cindex Low level, opening files at

You can open a file, or create one if it does not already exist, with
the @code{open} command, which creates and returns a new file descriptor
for the file name passed to it.  If the file is successfully opened, the
file position indicator is initially set to zero (the beginning of the
file).  (Note that the @code{open} function is actually called at an
underlying level by @code{fopen}.)

The first parameter of @code{open} is a string containing the filename
of the file you wish to open.  The second parameter is an integer
argument created by the @dfn{bitwise OR} of the following file status
flags.  (Bitwise OR is a mathematical operator that we have not yet
covered in this book.  To perform bitwise OR on two variables @code{a}
and @code{b}, you simply insert a pipe character between them, thus:
@code{a | b}.  Bitwise OR is similar to the way the expression
``and/or'' is used in English.  See the code example below for the use
of bitwise OR with file status flags. @xref{Advanced operators}, for a
detailed explanation of bitwise OR and other bitwise operators.)

The following flags are the more important ones for a beginning C
programmer to know.  There are a number of file status flags which are
relevant only to more advanced programmers; for more details,
see @ref{File Status Flags, , File Status Flags, libc, The GNU C Library
Reference Manual}.)

Note that these flags are defined in macros in the GNU C Library header
file @file{fcntl.h}, so remember to insert the line @code{#include
<fcntl.h>} at the beginning of any source code file that uses them.

@table @code

@findex O_RDONLY @r{file status flag}
@item O_RDONLY
Open the file for read access.

@findex O_WRONLY @r{file status flag}
@item O_WRONLY
Open the file for write access.

@findex O_RDWR @r{file status flag}
@item O_RDWR
Open the file for both read and write access.  Same as @code{O_RDONLY |
O_WRONLY}.

@findex @r{file status flag}
@item O_READ

@c RWHE
@c Shouldn't this say it's the same as O_RDONLY, not O_RDWR?
@c Got this info from the glibc docs.

Same as @code{O_RDWR}.  GNU systems only.

@findex O_WRITE @r{file status flag}
@item O_WRITE
Same as @code{O_WRONLY}.  GNU systems only.

@findex O_EXEC @r{file status flag}
@item O_EXEC
Open the file for executing.  GNU systems only.

@findex O_CREAT @r{file status flag}
@item O_CREAT
The file will be created if it doesn't already exist.

@findex O_EXCL @r{file status flag}
@item O_EXCL
If @code{O_CREAT} is set as well, then @code{open} fails if the
specified file exists already.  Set this flag if you want to ensure
you will not clobber an existing file.

@findex O_TRUNC @r{file status flag}
@item O_TRUNC
Truncate the file to a length of zero bytes.  This option is not useful
for directories or other such special files.  You must have write
permission for the file, but you do not need to open it for write access
to truncate it (under GNU).

@findex O_APPEND @r{file status flag}
@item O_APPEND
Open the file for appending.  All @code{write} operations then write the
data at the end of the file.  This is the only way to ensure that the
data you write will always go to the end of the file, even if there are
other @code{write} operations happening at the same time.

@end table

@findex open @r{function}
@findex errno @r{system variable}
The @code{open} function normally returns a non-negative integer file
descriptor connected to the specified file.  If there is an error,
@code{open} will return -1 instead.  In that case, you can check the
@code{errno} variable to see which error occurred.  In addition to the
usual file name errors, @code{open} can set @code{errno} to the
following values.  (It can also specify a few other errors of interest
only to advanced C programmers.  @xref{Opening and Closing File, ,
Opening and Closing Files, libc, The GNU C Library Reference Manual},
for a full list of error values.  @xref{Usual file name errors}, for a
list of the usual file name errors.).

@table @code

@findex EACCES @r{file name error}
@item EACCES
The file exists but is cannot be does not have read or write access
(as requested), or the file does not exist but cannot be created because
the directory does not have write access.

@findex EEXIST @r{file name error}
@item EEXIST
Both @code{O_CREAT} and @code{O_EXCL} are set, and the named file already
exists.  To open it would clobber it, so it will not be opened.

@findex EISDIR @r{file name error}
@item EISDIR
Write access to the file was requested, but the file is actually a
directory.

@findex EMFILE @r{file name error}
@item EMFILE
Your program has too many files open.

@findex ENOENT @r{file name error}
@item ENOENT
The file named does not exist, and @code{O_CREAT} was not specified,
so the file will not be created.

@findex ENOSPC @r{file name error}
@item ENOSPC
The file cannot be created, because the disk is out of space.

@findex EROFS @r{file name error}
@item EROFS
The file is on a read-only file system, but either one of
@code{O_WRONLY}, @code{O_RDWR}, or @code{O_TRUNC} was specified, or
@code{O_CREAT} was set and the file does not exist.

@end table

@xref{Closing files at a low level}, for a code example using both the
low-level file functions @code{open} and @code{close}.




@menu
* File creation::               
@end menu

@node File creation,  , Opening files at a low level, Opening files at a low level
@subsubsection File creation

@cindex File creation
@cindex Creation of files
@findex creat @r{function}

In older C code using low-level file routines, there was a function
called @code{creat} that was used for creating files.  This function is
still included in GNU for compatibility with older C code, but is
considered obsolete.  In order to create a file, instead of writing

@smallexample
creat (@var{filename})
@end smallexample

@noindent
it is now considered better coding to practice to write the following code:

@findex open @r{function}
@smallexample
open (@var{filename}, O_WRONLY | O_CREAT | O_TRUNC)
@end smallexample


@node Closing files at a low level, Reading files at a low level, Opening files at a low level, Low-level file routines
@subsection Closing files at a low level

@cindex Closing files at a low level
@cindex Low level, closing files at

To close a file descriptor, use the low-level file function
@code{close}.  The sole argument to @code{close} is the file descriptor
you wish to close.

@findex close @r{function}
@findex errno @r{system variable}
The @code{close} function returns 0 if the call was successful, and -1
if there was an error.  In addition to the usual file name error codes,
it can set the system variable @code{errno} to one of the following
values.  It can also set @code{errno} to several other values, mostly of
interest to advanced C programmers. @xref{Opening and Closing Files, ,
Opening and Closing Files, libc, The GNU C Library Reference Manual},
for more information.

@table @code

@findex EBADF @r{file name error}
@item EBADF
The file descriptor passed to @code{close} is not valid.

@end table

@findex fclose @r{function}
Remember, close a stream by using @code{fclose} instead.  This allows
the necessary system bookkeeping to take place before the file is
closed.

Here is a code example using both the low-level file functions
@code{open} and @code{close}.

@findex open @r{function}
@findex close @r{function}
@cindex @code{open}, example of
@cindex @code{close}, example of
@smallexample
@group
#include <stdio.h>
#include <fcntl.h>

int main()
@{

  char my_filename[] = "snazzyjazz17.txt";
  int my_file_descriptor, close_err;
@end group

@group
  /*
    Open my_filename for writing.  Create it if it does not exist.
    Do not clobber it if it does.
  */

  my_file_descriptor = open (my_filename, O_WRONLY | O_CREAT | O_EXCL);
  if (my_file_descriptor == -1)
    @{
      printf ("Open failed.\n");
    @}
@end group

@group
  close_err = close (my_file_descriptor);
  if (close_err == -1)
    @{
      printf ("Close failed.\n");
    @}

  return 0;
@}
@end group
@end smallexample

Running the above code example for the first time should produce no
errors, and should create an empty text file called
@file{snazzyjazz17.txt}.  Running it a second time should display the
following errors on your monitor, since the file @file{snazzyjazz17.txt}
already exists, and should not be clobbered according to the flags
passed to @code{open}.

@smallexample
@group
Open failed.
Close failed.
@end group
@end smallexample




@node Reading files at a low level, Writing files at a low level, Closing files at a low level, Low-level file routines
@subsection Reading files at a low level

@cindex Reading files at a low level
@cindex Low level, reading files at
@findex read @r{function}

You can read a block of information from a file with the @code{read}
function.  The data read is loaded directly into a buffer in memory.
The data can be binary as well as a text, but if the latter, no
terminating newline is added.  The bytes read start at the current file
position; after reading them, @code{read} advances the file position to
immediately after the bytes read.

The @code{read} function takes three parameters.  The first one is the
file descriptor from which data is to be read.  The second is the buffer
in memory where the data read will be stored.  The buffer is of type
@code{void *}, and can be an array or a chunk of space reserved with
@code{malloc}.  The final parameter is of type @code{size_t}, and specifies
the number of bytes to read.

The return value of this function is of type @code{ssize_t}, and
represents the number of bytes actually read.  This might be less than
the number of bytes requested if there are not enough bytes left in the
file or immediately available.  Reading less than the number of bytes
requested does not generate an error.

If the number of bytes requested is not zero, a return value of zero
indicates the end of the file.  This is also not an error.  If you keep
calling @code{read} at the end of the file, it will simply keep
returning zero.  If @code{read} returns at least one character, you
cannot tell whether the end of the file was reached from that
information, but @code{read} will return zero on the next read operation
if it was.

@vindex errno @r{system variable}
If there was an error, @code{read} returns -1.  You can then check the
system variable @code{errno} for one of the following error conditions,
as well as the usual file name errors. (@xref{Usual file name errors}.)
The @code{read} function can also return some other error conditions in
@code{errno} that are mostly of interest to advanced C programmers.
(@xref{I/O Primitives, , Input and Output Primitives, libc, The GNU C
Library Reference Manual}, for more information.)

@table @code

@findex EBADF @r{file name error}
@item EBADF
The file descriptor passed to @code{read} is not valid, or is not open
for reading.

@findex EIO @r{file name error}
@item EIO
There was a hardware error.  (This error code also applies to more abstruse
conditions detailed in the GNU C Library manual.)

@end table

@xref{Writing files at a low level}, for a code example that uses the
@code{read} function.




@node Writing files at a low level, Finding file positions at a low level, Reading files at a low level, Low-level file routines
@subsection Writing files at a low level

@cindex Writing files at a low level
@cindex Low level, writing files at
@findex write @r{function}
You can write a block of information to a file with the @code{write}
function, which is called by all high-level file writing routines, such
as @code{fwrite}.  It takes three parameters.  The first is the file
descriptor of the file you wish to write to.  The second is a buffer, of
type @code{void *}, that contains the data you wish to write.  (It can
be an array of bytes, but need not be a text string. Null characters in
the data are treated in the same way as other characters.)  The third
parameter is of type @code{size_t}, and specifies the number of bytes
that are to be written.

The return value of this function is of type @code{ssize_t}, and
indicates the number of bytes actually written.  This may be the same as
the third parameter (the number of bytes to be written), but may be
less; you should always call @code{write} in a loop, and iterate the
loop until all data has been written.  If there is an error, @code{write}
returns -1.  The @code{write} function will return the following error codes
in the system variable @code{errno}, as well as the usual file name errors.
(@xref{Usual file name errors}.)

@table @code

@findex EBADF @r{file name error}
@item EBADF
The file descriptor specified is invalid, or is not open for writing.

@findex EFBIG @r{file name error}
@item EFBIG
If the data were written, the file written to would become too large.

@findex EIO @r{file name error}
@item EIO
There has been a hardware error.

@findex EINTR @r{file name error}
@item EINTR
The write operation was temporarily interrupted.

@findex ENOSPC @r{file name error}
@item ENOSPC
The device containing the file is full.

@end table

In addition to the error codes above, @code{write} can return some error
codes that are mainly of interest to advanced C programmers.  If
@code{write} fails, you should check @code{errno} to see if the error
was @code{EINTR}; if it was, you should repeat the @code{write} call
each time.

@findex fsync @r{function}
Even though low-level file routines do not use buffering, and once you
call @code{write}, your data can be read from the file immediately, it
may take up to a minute before your data is physically written to disk.
You can call the @code{fsync} routine (see below) to ensure that all
data is written to the file; this usage is roughly analogous to the
high-level file routine @code{fflush}.

@vindex errno @r{system variable}
The @code{fsync} routine takes a single parameter, the file descriptor
to synchronise.  It does not return a value until all data has been written.
If no error occurred, it returns a 0; otherwise, it returns -1 and sets
the system variable @code{errno} to one of the following values:

@table @code

@findex EBADF @r{file name error}
@item EBADF
The file descriptor specified is invalid.

@findex EINVAL @r{file name error}
@item EINVAL
No synchronization is possible because the system does not implement it.

@end table

Here is a code example that demonstrates the use of the @code{write},
@code{read}, and @code{fsync} functions. (@xref{Reading files at a low
level}, for more information on @code{read}.)

@findex write @r{function}
@findex read @r{function}
@findex fsync @r{function}
@cindex @code{write}, example of
@cindex @code{read}, example of
@cindex @code{fsync}, example of
@smallexample
@group
#include <stdio.h>
#include <fcntl.h>

int main()
@{
  char my_write_str[] = "1234567890";
  char my_read_str[100];
  char my_filename[] = "snazzyjazz.txt";
  int my_file_descriptor, close_err;
@end group

@group
  /* Open the file.  Clobber it if it exists. */
  my_file_descriptor = open (my_filename, O_RDWR | O_CREAT | O_TRUNC);

  /* Write 10 bytes of data and make sure it's written */
  write (my_file_descriptor, (void *) my_write_str, 10);
  fsync (my_file_descriptor);
@end group

@group
  /* Seek the beginning of the file */
  lseek (my_file_descriptor, 0, SEEK_SET);

  /* Read 10 bytes of data */
  read (my_file_descriptor, (void *) my_read_str, 10);
@end group

@group
  /* Terminate the data we've read with a null character */
  my_read_str[10] = '\0';

  printf ("String read = %s.\n", my_read_str);

  close (my_file_descriptor);

  return 0;
@}
@end group
@end smallexample


@node Finding file positions at a low level, Deleting files at a low level, Writing files at a low level, Low-level file routines
@subsection Finding file positions at a low level

@cindex Finding file positions at a low level
@cindex Low level, finding file positions at
@findex lseek @r{function}

If you want to find a particular file position within a file, using a
low-level file routine, you can call the @code{lseek} function.  This is
very similar to the high-level file routine @code{fseek}, except that it
accepts a file descriptor rather than a stream as an argument.

The @code{lseek} function specifies the file position for the next
@code{read} or @code{write} operation.  (@xref{File position}, for more
information on file positions.)

@findex SEEK_SET @r{constant}
@findex SEEK_CUR @r{constant}
@findex SEEK_END @r{constant}
The @code{lseek} function takes three parameters.  The first parameter
is the file descriptor. The second is of type @code{off_t} and specifies
the number of bytes to move the file position indicator. The third
argument and the third parameter is a constant that specifies whether
the offset is relative to the beginning of the file (@code{SEEK_SET}),
to the current file position (@code{SEEK_CUR}), or to the end of the
file (@code{SEEK_END}).  If @code{SEEK_CUR} or @code{SEEK_END} is used,
the offset specified can be positive or negative.  If you specify
@code{SEEK_END}, set the position past the current end of the file, and
actually write data, you will extend the file with zeroes up to the
position you specify.  However, the blocks of zeroes are not actually
written to disk, so the file takes up less space on disk than it seems
to; this is called a @dfn{sparse file}.

@tindex off_t @r{type}
The return value of @code{lseek} is of type @code{off_t} and normally
contains the resulting file position, as measured in bytes from the
beginning of the file.  If you wish to read the current file position,
therefore, you can specify an offset of 0 and a third parameter of
@code{SEEK_CUR}, as follows:

@smallexample
@var{file_position} = lseek (@var{file_descriptor}, 0, SEEK_CUR);
@end smallexample

If there was an error, @code{lseek} returns a -1 and sets the system variable
@code{errno} to one of the following values:

@table @code

@findex EBADF @r{file name error}
@item EBADF
The file descriptor specified is invalid.

@findex EINVAL @r{file name error}
@item EINVAL
Either the third parameter of @code{lseek} is invalid, or the file offset
is invalid.

@findex ESPIPE @r{file name error}
@item ESPIPE
The file descriptor corresponds to an object that cannot be positioned,
such as a terminal device.

@end table

The @code{lseek} function is called by many high-level file position functions,
including @code{fseek}, @code{rewind}, and @code{ftell}.



@node Deleting files at a low level, Renaming files at a low level, Finding file positions at a low level, Low-level file routines
@subsection Deleting files at a low level

@cindex Deleting files at a low level
@cindex Low level, deleting files at
@findex unlink @r{function}

If you want to delete a file, you can use the low-level file routine
@code{unlink}, as declared in the file @file{unistd.h}.  Simply pass
this routine the name of the file you wish to delete.  If this is the
only name the file has (that is, if no one has created a hard link to
the file with the @code{link} function, the GNU command @command{ln}, or
something similar), then the file itself will be deleted; otherwise,
only that name will be deleted.  (See the section "Hard Links" in the
GNU C Library manual for more information on hard links.)  If the file
is open when @code{unlink} is called, @code{unlink} will wait for the
file to be closed before it deletes it.

The @code{unlink} function returns 0 if the file or file name was
successfully deleted.  If there was an error, @code{unlink} returns -1.
In addition to the usual file name errors, @code{unlink} can set
@code{errno} to the following values.  (@xref{Usual file name
errors}, for a list of the usual file name errors.)

@table @code

@findex EACCES @r{file name error}
@item EACCES
Your program does not have permission to delete the file from the
directory that contains it.

@findex EBUSY @r{file name error}
@item EBUSY
The file is currently being used by the system and cannot be deleted.

@findex ENOENT @r{file name error}
@item ENOENT
The file name to be deleted does not exist.

@findex EPERM @r{file name error}
@item EPERM
Your program tried to delete a directory with @code{unlink};
this is not permitted under GNU.  (See @code{remove} below.)

@findex EROFS @r{file name error}
@item EROFS
The file name is on a read-only file system and cannot be deleted.

@end table

@vindex errno @r{system variable}
@findex rmdir @r{function}
If you wish to delete a directory rather than an ordinary file, use the
@code{rmdir} function.  Simply pass it the name of an empty directory
you wish to delete.  It acts like @code{unlink} in most respects, except
that it can return an extra error code in the system variable
@code{errno}:

@table @code

@findex ENOTEMPTY @r{file name error}
@item ENOTEMPTY
The directory was not empty, so cannot be deleted.  This code is synonymous
with @code{EEXIST}, but GNU always returns @code{ENOTEMPTY}.

@end table



@node Renaming files at a low level,  , Deleting files at a low level, Low-level file routines
@subsection Renaming files at a low level

@cindex Renaming files at a low level
@cindex Low level, renaming files at
@findex rename @r{function}

If you want to rename a file, you can use the @code{rename} function,
which takes two parameters.  The first parameter is a string containing
the old name of the file, and the second is a string containing the new
name.  (As with @code{unlink}, this function only operates on one of the
names of a file, if the file has hard links.  @xref{Deleting files at a
low level}, for caveats and information on hard links.)

Both the new name and the old name must be on the same file system.
Any file in the same directory that has the same name as the new file name
will be deleted in the process of renaming the file.

@vindex errno @r{system variable}
If @code{rename} fails, it will return -1.  In addition to the usual
file name errors, @code{unlink} can set @code{errno} to the following
values.  (@xref{Usual file name errors}, for a list of the usual file
name errors.)

@table @code

@findex EACCES @r{file name error}
@item EACCES
Either one of the directories in question (either the one containing the
old name or the one containing the new name) refuses write permission,
or the new name and the old name are directories, and write permission
is refused for at least one of them.

@findex EBUSY @r{file name error}
@item EBUSY
One of the directories used by the old name or the new name is being used
by the system and cannot be changed.

@findex ENOTEMPTY @r{file name error}
@item ENOTEMPTY
The directory was not empty, so cannot be deleted.  This code is synonymous
with @code{EEXIST}, but GNU always returns @code{ENOTEMPTY}.

@findex EINVAL @r{file name error}
@item EINVAL
The old name is a directory that contains the new name.

@findex EISDIR @r{file name error}
@item EISDIR
The new name is a directory, but the old name is not.

@findex EMLINK @r{file name error}
@item EMLINK
The parent directory of the new name would contain too many entries
if the new name were created.

@findex ENOENT @r{file name error}
@item ENOENT
The old name does not exist.

@findex ENOSPC @r{file name error}
@item ENOSPC
The directory that would contain the new name has no room for another entry,
and cannot be expanded.

@findex EROFS @r{file name error}
@item EROFS
The rename operation would involve writing on a read-only file system.

@findex EXDEV @r{file name error}
@item EXDEV
The new name and the old name are on different file systems.

@end table


@node Questions 16,  , Low-level file routines, Input and output
@section Questions

@enumerate

@item
What are the following?

@enumerate
@item
File name
@item
File descriptor
@item
Stream
@end enumerate

@item
What is a pseudo-device name?

@item
Where does @file{stdin} usually get its input?

@item
Where does @file{stdout} usually send its output?

@item
Write a program that simply prints out the following string to the
screen: @samp{6.23e+00}.

@item
Investigate what happens when you type the wrong conversion
specifier in a program. e.g. try printing an integer with @samp{%f} or a
floating point number with @samp{%c}.  This is bound to go wrong -- but how
will it go wrong?

@item
What is wrong with the following statements?

@enumerate
@item
@code{printf (x);}
@item
@code{printf ("%d");}
@item
@code{printf ();}
@item
@code{printf ("Number = %d");}
@end enumerate
Hint: if you don't know, try them in a program!

@item
What is a whitespace character?

@item
Write a program that aceepts two integers from the user,
multiplies them together, and prints the answer on your printer.
Try to make the input as safe as possible.

@item
Write a program that simply echoes all the input to the output.

@item
Write a program that strips all space characters out of the input and
replaces each string of them with a single newline character.

@item
The @code{scanf} function always takes pointer arguments.  True or false?

@item
What is the basic difference between high-level and low-level file routines?

@item
Write a statement that opens a high level file for reading.

@item
Write a statement that opens a low level file for writing.

@item
Write a program that checks for illegal characters in text files.  The
only valid characters are ASCII codes 10, 13, and 32..126.

@item
What statement performs formatted writing to text files?

@item
Poke around in the header files on your system so you can
see what is defined where.

@end enumerate




@c CHAPTER 17
@node Putting a program together, Advanced operators, Input and output, Top
@chapter Putting a program together

This chapter explains, step by step, how to create a ``real'' program
that meets GNU standards for a command-line interface.  It also
discusses how to create a program whose source is split into multiple
files, and how to compile it, with or without the GNU utility
@command{make}.  Finally, it discusses how to create a code library, in
case you write some useful functions that you want to share with other
programmers.

@emph{Putting it all together.}

@menu
* argc and argv::               
* Processing command-line options::  
* Environment variables::       
* Compiling multiple files::    
* Writing a makefile::          
* Building a library::          
* Questions 17::                
@end menu

@node argc and argv, Processing command-line options, Putting a program together, Putting a program together
@section @code{argc} and @code{argv}

@cindex Argument vector
@vindex argc @r{variable}
@vindex argv @r{variable}

So far, all the programs we have written can be run with a single command.
For example, if we compile an executable called @file{myprog}, we can run it
from within the same directory with the following command at the GNU/Linux
command line:

@smallexample
./myprog
@end smallexample

@cindex Passing information to program
@pindex gcc
However, what if you want to pass information from the command line to
the program you are running? Consider a more complex program like GCC.
To compile the hypothetical @file{myprog} executable, we type something
like the following at the command line:

@smallexample
gcc -o myprog myprog.c
@end smallexample

The character strings @samp{-o}, @samp{myprog}, and @samp{myprog.c} are
all @dfn{arguments} to the @command{gcc} command.  (Technically
@samp{gcc} is an argument as well, as we shall see.)

Command-line arguments are very useful.  After all, C functions wouldn't
be very useful if you couldn't ever pass arguments to them --- adding
the ability to pass arguments to programs makes them that much more
useful.  In fact, all the arguments you pass on the command line end up
as arguments to the @code{main} function in your program.

Up until now, the skeletons we have used for our C programs have looked
something like this:

@smallexample
@group
#include <stdio.h>

int main()
@{

  return 0;
@}
@end group
@end smallexample

From now on, our examples may look a bit more like this:

@smallexample
@group
#include <stdio.h>

int main (int argc, char *argv[])
@{

  return 0;
@}
@end group
@end smallexample

@cindex Argument count variable
@cindex Argument vector
As you can see, @code{main} now has arguments.  The name of the variable
@code{argc} stands for ``argument count''; @code{argc} contains the
number of arguments passed to the program.  The name of the variable
@code{argv} stands for ``argument vector''.  A vector is a
one-dimensional array, and @code{argv} is a one-dimensional array of
strings.  Each string is one of the arguments that was passed to the
program.

For example, the command line

@smallexample
gcc -o myprog myprog.c
@end smallexample

@noindent

would result in the following values internal to GCC:

@table @code

@item argc
4

@item argv[0]
@samp{gcc}

@item argv[1]
@samp{-o}

@item argv[2]
@samp{myprog}

@item argv[3]
@samp{myprog.c}

@end table

As you can see, the first argument (@code{argv[0]}) is the name by which
the program was called, in this case @samp{gcc}.  Thus, there will
always be at least one argument to a program, and @code{argc} will
always be at least 1.

The following program accepts any number of command-line arguments and
prints them out:

@findex argc @r{variable}
@findex argv @r{variable}
@cindex @code{argc}, example of
@cindex @code{argv}, example of
@smallexample
@group
#include <stdio.h>

int main (int argc, char *argv[])
@{
  int count;

  printf ("This program was called with \"%s\".\n",argv[0]);
@end group

@group
  if (argc > 1)
    @{
      for (count = 1; count < argc; count++)
	@{
	  printf("argv[%d] = %s\n", count, argv[count]);
	@}
    @}
  else
    @{
      printf("The command had no other arguments.\n");
    @}

  return 0;
@}
@end group
@end smallexample

If you name your executable @file{fubar}, and call it with the command @samp{./fubar a b c},
it will print out the following text:

@smallexample
@group
This program was called with "./fubar".
argv[1] = a
argv[2] = b
argv[3] = c
@end group
@end smallexample



@node Processing command-line options, Environment variables, argc and argv, Putting a program together
@section Processing command-line options

@findex getopt @r{function}
@findex argp @r{function}

It is easy, though tedious to pull options directly out of the
@code{argv} vector with your own routines.  It is slightly less tedious
to use the standard C option-processing function @code{getopt}, or the
enhanced GNU version of the same function, @code{getopt_long}, which
permits GNU-style @dfn{long options} (for example, @option{--quiet} as
opposed to @option{-q}).

The best option of all is to use the @code{argp} interface for
processing options.  Professionally written programs provide the user
with standard and useful options.  The @code{argp} function provides for
these.  For the modest price of setting up your command line arguments
in a structured way, and with surprisingly few lines of code, you can
obtain all the perks of a ``real'' GNU program, such as
``automagically''-generated output to the @option{--help},
@option{--usage}, and @option{--version} options, as defined by the GNU
coding standards.  Using @code{argp} results in a more consistent
look-and-feel for programs that use it, and makes it less likely that
the built-in documentation for a program will be wrong or out of date.

@cindex POSIX standard, command-line conventions
@cindex Command-line options
@cindex Options, command-line
POSIX, the Portable Operating System Interface standard, recommends the
following conventions for command-line arguments.  The @code{argp}
interface makes implementing them easy.

@itemize @bullet

@item
Command-line arguments are @dfn{options} if they begin with a hyphen (@samp{-}).

@item
Multiple options may follow a hyphen in a cluster if they do not take
arguments.  Thus, @option{-abc} and @option{-a -b -c} are the same.

@item
Option names are single alphanumeric characters.

@item
Options may require an argument.  For example, the @option{-o} option
of the @command{ld} command requires an output file name.

@item
The whitespace separating an option and its argument is optional.
Thus, @option{-o foo} and @option{-ofoo} are the same.

@item
Options usually precede non-option arguments.  (In fact, @code{argp} is
more flexible than this; if you want to suppress this flexibility,
define the @code{_POSIX_OPTION_ORDER} environment variable.)

@item
The argument @option{--} terminates all options; all following command-line
arguments are considered non-option arguments, even if they begin with a hyphen.

@item
A single hyphen as an argument is considered a non-option argument;
by convention, it is used to specify input from standard input or
output to standard output.

@item
Options may appear in any order, even multiple times.  The meaning
of this is left to the application.

@end itemize

@cindex Long options, GNU
@cindex GNU long options
In addition, GNU adds @dfn{long options}, like the @option{--help},
@option{--usage}, and @option{--version} options mentioned above.  A
long option starts with @samp{--}, which is then followed by a string of
alphanumeric characters and hyphens.  Option names are usually one to
three words long, with hyphens to separate words.  Users can abbreviate
the option names as long as the abbreviations are unique.  A long option
(such as @option{--verbose}) often has a short-option synonym (such as
@option{-v}).

Long options can accept optional (that is, non-necessary) arguments.
You can specify an argument for a long option as follows:

@smallexample
@group
@samp{--}@var{option-name}@samp{=}@var{value}
@end group
@end smallexample

@noindent
You may not type whitespace between the option name and the equals sign,
or between the equals sign and the option value.


@menu
* argp description::            
* argp example::                
@end menu

@node argp description, argp example, Processing command-line options, Processing command-line options
@subsection @code{argp} description

@findex argp @r{function}

This section will describe how to write a simple program that implements
most of the standards mentioned above.  It assumes some knowledge of
advanced C data structures that we have not yet covered in this book; if
you are confused, you might want to consult the chapter that discusses
this material. (@xref{More data types}.)  Note that we are only
discussing the basics of @code{argp} in this chapter; to read more about
this complicated and flexible facility of the GNU C Library, consult
@ref{Argp, , Parsing Program Options with Argp, libc, The GNU C Library
Reference Manual}.  Nevertheless, what you learn in this chapter may be
all you need to develop a program that is compliant with GNU coding
standards, with respect to command-line options.

@vindex ARGP @r{structure}
@findex argp_parse @r{function}
@vindex arguments @r{structure}
The main interface to @code{argp} is the @code{argp_parse} function.
Usually, the only argument-parsing code you will need in @code{main} is
a call to this function.  The first parameter it takes is of type
@code{const struct argp *argp}, and specifies an @code{ARGP} structure
(see below).  (A value of zero is the same as a structure containing all
zeros.)  The second parameter is simply @code{argc}, the third simply
@code{argv}.  The fourth parameter is a set of flags that modify the
parsing behaviour; setting this to zero usually doesn't hurt unless
you're doing something fancy, and the same goes for the fifth parameter.
The sixth parameter can be useful; in the example below, we use it to
pass information from @code{main} to our function @code{parse_opt},
which does most of the work of initalizing internal variables (fields in
the @code{arguments} structure) based on command-line options and
arguments.

@tindex error_t @r{function}
@findex ENOMEM @r{error code}
@findex EINVAL @r{error code}
The @code{argp_parse} returns a value of type @code{error_t}: usually
either 0 for success, @code{ENOMEM} if a memory allocation error
occurred, or @code{EINVAL} if an unknown option or argument was met
with.

@vindex ARGP @r{structure}
For this example, we are using only the first four fields in
@code{ARGP}, which are usually all that is needed.  The rest of the
fields will default to zero.  The four fields are, in order:


@enumerate

@vindex OPTIONS @r{field}
@findex argp_option @r{structure}
@item
@code{OPTIONS}: A pointer to a vector the elements of which are of type
@code{struct argp_option}, which contains four fields.  The vector
elements specify which options this parser understands.  If you assign
your option structure by initializing the array as we do in this
section's main example, unspecified fields will default to zero, and
need not be specified.  The whole vector may contain zero if there are
no options at all.  It should in any case be terminated by an entry
with a zero in all fields (as we do by specifying the last item in the
@code{options} vector to be @code{@{0@}} in the main example below.

The four main @code{argp_option} structure fields are as
follows.  (We will ignore the fifth one, which is relatively unimportant
and will simply default to zero if you do not specify it.)

@findex argp_option @r{structure fields}
@enumerate

@vindex NAME @r{field}
@item
@code{NAME}: The name of this option's long option (may be zero).
To specify multiple names for an option, follow it with additional entries, with
the @code{OPTION_ALIAS} flag set.

@vindex KEY @r{field}
@item
@code{KEY}: The integer key to pass to the @code{PARSER} function when
parsing the current option; this is the same as the name of the current
option's short option, if it is a printable ASCII character.

@vindex ARG @r{field}
@item
@code{ARG}: The name of this option's argument, if any.

@vindex FLAGS @r{field}
@item
@code{FLAGS}: Flags describing this option.  You can specify multiple
flags with logical OR (for example, @code{OPTION_ARG_OPTIONAL |
OPTION_ALIAS}).


Some of the available options are:

@itemize @bullet

@findex OPTION_ARG_OPTIONAL @r{option flag}
@item @code{OPTION_ARG_OPTIONAL}:
The argument to the current option is optional.

@findex OPTION_ALIAS @r{option flag}
@item @code{OPTION_ALIAS}:
The current option is an alias for the previous option.

@findex OPTION_HIDDEN @r{option flag}
@item @code{OPTION_HIDDEN}:
Don't show the current option in @code{--help} output.

@end itemize

@vindex DOC @r{field}
@item
@code{DOC}: A documentation string for the current option; will be shown
in @code{--help} output.

@end enumerate

@vindex PARSER @r{field}
@item
@code{PARSER}: A pointer to a function to be called by @code{argp} for
each option parsed.  It should return one of the following values:

@itemize @bullet

@findex 0 @r{return code}
@item
@code{0}: Success.

@findex ARGP_ERR_UNKNOWN @r{return code}
@item
@code{ARGP_ERR_UNKNOWN}: The given key was not recognized.

@vindex errno @r{system variable}
@item
An @code{errno} value indicating some other error.  (@xref{Usual file
name errors}.)

@end itemize

@noindent
The parser function takes the following arguments:

@enumerate

@findex KEY @r{parser function argument}
@item
@code{KEY}: An integer specifying which argument this is, taken from the @code{KEY}
field in each @code{argp_option} structure, or else a key with a special meaning,
such as one of the following:

@itemize @bullet

@findex ARGP_KEY_ARG @r{key}
@item
@code{ARGP_KEY_ARG}: The current command-line argument is not an option.

@findex ARGP_KEY_END @r{key}
@item
@code{ARGP_KEY_END}: All command-line arguments have been parsed.

@end itemize

@findex ARG @r{parser function argument}
@item
@code{ARG}: The string value of the current command-line argument,
or NULL if it has none.

@findex STATE @r{parser function argument}
@item
@code{STATE}: A pointer to an @code{argp_state} structure, containing
information about the parsing state, such as the following fields:

@enumerate

@findex input @r{field}
@item
@code{input}: The same as the last parameter to @code{argp_parse}.  We
use this in the main code example below to pass information between the
@code{main} and @code{parse_opt} functions.

@findex arg_num @r{field}
@item
@code{arg_num}: The number of the current non-option argument being parsed.

@end enumerate

@end enumerate

@findex ARGS_DOC @r{field}
@item
@code{ARGS_DOC}: If non-zero, a string describing how the non-option arguments should look.
It is only used to print the @samp{Usage:} message.  If it contains newlines,
the strings separated by them are considered alternative usage patterns, and printed on
separate lines (subsequent lines are preceded by @samp{or:} rather than @samp{Usage:}.

@findex DOC @r{field}
@item
@code{DOC}: If non-zero, a descriptive string about this program.  It
will normally be printed before the options in a help message, but if
you include a vertical tab character (@samp{\v}), the part after the
vertical tab will be printed following the options in the output to the
@code{--help} option.  Conventionally, the part before the options is just a short
string that says what the program does, while the part afterwards is longer
and describes the program in more detail.

@end enumerate

@findex argp_usage @r{function}
There are also some utility functions associated with @code{argp}, such
as @code{argp_usage}, which prints out the standard usage message.  We
use this function in the @code{parse_opt} function in the following
example.  @xref{Argp Helper Functions, , Functions For Use in Argp
Parsers, libc, The GNU C Library Reference Manual}, for more of these
utility functions.

@findex argp @r{function}
@cindex @code{argp}, example of
@node argp example,  , argp description, Processing command-line options
@subsection @code{argp} example

Here is a code example that uses @code{argp} to parse command-line
options.  Remember, to compile this example, copy it to a file called
something like @file{argex.c}, then compile it with the command
@command{gcc -o argex argex.c} and run the resulting binary with the
command @command{./argex}.

@smallexample
@group
#include <stdio.h>
#include <argp.h>

const char *argp_program_version =
"argex 1.0";

const char *argp_program_bug_address =
"<bug-gnu-utils@@gnu.org>";
@end group

@group
/* This structure is used by main to communicate with parse_opt. */
struct arguments
@{
  char *args[2];            /* ARG1 and ARG2 */
  int verbose;              /* The -v flag */
  char *outfile;            /* Argument for -o */
  char *string1, *string2;  /* Arguments for -a and -b */
@};
@end group

@group
/*
   OPTIONS.  Field 1 in ARGP.
   Order of fields: @{NAME, KEY, ARG, FLAGS, DOC@}.
*/
static struct argp_option options[] =
@{
  @{"verbose", 'v', 0, 0, "Produce verbose output"@},
  @{"alpha",   'a', "STRING1", 0,
   "Do something with STRING1 related to the letter A"@},
  @{"bravo",   'b', "STRING2", 0,
   "Do something with STRING2 related to the letter B"@},
  @{"output",  'o', "OUTFILE", 0,
   "Output to OUTFILE instead of to standard output"@},
  @{0@}
@};
@end group


@group
/*
   PARSER. Field 2 in ARGP.
   Order of parameters: KEY, ARG, STATE.
*/
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
@{
  struct arguments *arguments = state->input;
@end group

@group
  switch (key)
    @{
    case 'v':
      arguments->verbose = 1;
      break;
    case 'a':
      arguments->string1 = arg;
      break;
    case 'b':
      arguments->string2 = arg;
      break;
    case 'o':
      arguments->outfile = arg;
      break;
@end group
@group
    case ARGP_KEY_ARG:
      if (state->arg_num >= 2)
	@{
	  argp_usage(state);
	@}
      arguments->args[state->arg_num] = arg;
      break;
    case ARGP_KEY_END:
      if (state->arg_num < 2)
	@{
	  argp_usage (state);
	@}
      break;
    default:
      return ARGP_ERR_UNKNOWN;
    @}
  return 0;
@}
@end group

@group
/*
   ARGS_DOC. Field 3 in ARGP.
   A description of the non-option command-line arguments
     that we accept.
*/
static char args_doc[] = "ARG1 ARG2";
@end group

@group
/*
  DOC.  Field 4 in ARGP.
  Program documentation.
*/
static char doc[] =
"argex -- A program to demonstrate how to code command-line options
and arguments.\vFrom the GNU C Tutorial.";
@end group

@group
/*
   The ARGP structure itself.
*/
static struct argp argp = @{options, parse_opt, args_doc, doc@};
@end group

@group
/*
   The main function.
   Notice how now the only function call needed to process
   all command-line options and arguments nicely
   is argp_parse.
*/
int main (int argc, char **argv)
@{
  struct arguments arguments;
  FILE *outstream;
@end group

@group
  char waters[] =
"a place to stay
enough to eat
somewhere old heroes shuffle safely down the street
where you can speak out loud
about your doubts and fears
and what's more no-one ever disappears
you never hear their standard issue kicking in your door
you can relax on both sides of the tracks
and maniacs don't blow holes in bandsmen by remote control
and everyone has recourse to the law
and no-one kills the children anymore
and no-one kills the children anymore
  --\"the gunners dream\", Roger Waters, 1983\n";
@end group

@group
  /* Set argument defaults */
  arguments.outfile = NULL;
  arguments.string1 = "";
  arguments.string2 = "";
  arguments.verbose = 0;
@end group

@group
  /* Where the magic happens */
  argp_parse (&argp, argc, argv, 0, 0, &arguments);

  /* Where do we send output? */
  if (arguments.outfile)
    outstream = fopen (arguments.outfile, "w");
  else
    outstream = stdout;
@end group

@group
  /* Print argument values */
  fprintf (outstream, "alpha = %s\nbravo = %s\n\n",
	   arguments.string1, arguments.string2);
  fprintf (outstream, "ARG1 = %s\nARG2 = %s\n\n",
	   arguments.args[0],
	   arguments.args[1]);

  /* If in verbose mode, print song stanza */
  if (arguments.verbose)
    fprintf (outstream, waters);

  return 0;
@}
@end group
@end smallexample

Compile the code, then experiment!  For example, here is the program
output if you simply type @command{argex}:

@smallexample
@group
Usage: argex [OPTION...] ARG1 ARG2
Try `argex --help' or `argex --usage' for more information.
@end group
@end smallexample

Here is the output from @command{argex --usage}:

@smallexample
@group
Usage: argex [-v?V] [-a STRING1] [-b STRING2] [-o OUTFILE] [--alpha=STRING1]
            [--bravo=STRING2] [--output=OUTFILE] [--verbose] [--help] [--usage]
            [--version] ARG1 ARG2
@end group
@end smallexample

Here is the output from @command{argex --help}:

@smallexample
@group
Usage: argex [OPTION...] ARG1 ARG2
argex -- A program to demonstrate how to code command-line options
and arguments.

  -a, --alpha=STRING1        Do something with STRING1 related to the letter A
  -b, --bravo=STRING2        Do something with STRING2 related to the letter B
  -o, --output=OUTFILE       Output to OUTFILE instead of to standard output
  -v, --verbose              Produce verbose output
  -?, --help                 Give this help list
      --usage                Give a short usage message
  -V, --version              Print program version

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

From the GNU C Tutorial.

Report bugs to <bug-gnu-utils@@gnu.org>.
@end group
@end smallexample

Here is the output from @command{argex Foo Bar}:

@smallexample
@group
alpha =
bravo =

ARG1 = Foo
ARG2 = Bar

@end group
@end smallexample

And finally, here is the output from @command{argex --verbose -a 123 --bravo=456 Foo Bar}:

@smallexample
@group
alpha = 123
bravo = 456

ARG1 = Foo
ARG2 = Bar

a place to stay
enough to eat
somewhere old heroes shuffle safely down the street
where you can speak out loud
about your doubts and fears
and what's more no-one ever disappears
you never hear their standard issue kicking in your door
you can relax on both sides of the tracks
and maniacs don't blow holes in bandsmen by remote control
and everyone has recourse to the law
and no-one kills the children anymore
and no-one kills the children anymore
  --"the gunners dream", Roger Waters, 1983
@end group
@end smallexample

You can of course also send the output to a text file with the @option{-o}
or @option{--output} option.





@node Environment variables, Compiling multiple files, Processing command-line options, Putting a program together
@section Environment variables

@cindex Environment variables
@cindex Variables, environment

Sometimes it is useful to communicate with a program in a semi-permanent
way, so that you do not need to specify a command-line option every time
you type the command to execute the program.  One way to do this is to
generate a configuration file, in which you can store data that will be
used by the program every time it is run.  This approach is typically
useful if you have a large amount of data that you want to pass to a
program every time it runs, or if you want the program itself to be able
to change the data.

However, @dfn{environment variables} provide a more lightweight
approach.  Environment variables, sometimes called @dfn{shell
variables}, are usually set with the @command{export} command in the
shell.  (This section assumes you are using the GNU Bash shell.)
Standard environment variables are used for information about your home
directory, terminal type, and so on; you can define additional variables
for other purposes. The set of all environment variables that have
values is collectively known as the @dfn{environment}.

Names of environment variables are case-sensitive, and it is good form
to use all upper-case letters when defining a new variable; certainly
this is the case for all system-defined environment variables.

The value of an environment variable can be any string that does not contain
a null character (since the null character is used to terminate the string
value).

@vindex envp @r{array}
Environment variables are stored in a special array that can be read by
your @code{main} function.  Here is the skeleton for a @code{main}
function that can read environment variables; notice we have added a
third parameter to @code{main}, called @code{envp}, which comes after
@code{argc} and @code{argv}.

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main (int argc, char *argv[], char *envp[])
@{

  return 0;
@}
@end group
@end smallexample

Notice that @code{envp} is an array of strings, just as @code{argv} is.
It consists of a list of the environment variables of your shell,
in the following format:

@smallexample
@var{NAME}=@var{value}
@end smallexample

@findex getenv @r{function}
@findex argv @r{array}
@findex envp @r{array}
Just as you can manually process command-line options from @code{argv},
so can you manually process environment variables from @code{envp}.
However, the simplest way to access the value of an environment variable
is with the @code{getenv} function, defined in the system header
@file{stdlib.h}.  It takes a single argument, a string containing the
name of the variable whose value you wish to discover.  It returns that
value, or a null pointer if the variable is not defined.

@smallexample
@group
#include <stdio.h>
#include <stdlib.h>

/* To shorten example, not using argp */
int main (int argc, char *argv[], char *envp[])
@{
  char *home, *host;

  home = getenv("HOME");
  host = getenv("HOSTNAME");

  printf ("Your home directory is %s on %s.\n", home, host);

  return 0;
@}
@end group
@end smallexample

@noindent
When you run this code, it will print out a line like the following one.

@smallexample
Your home directory is /home/rwhe on linnaeus.
@end smallexample

@strong{Note:} Do not modify strings returned from @code{getenv}; they
are pointers to data that belongs to the system.  If you want to process
a value returned from @code{getenv}, copy it to another string first
with @code{strcpy}.  (@xref{Strings}.)  If you want to change an
environment variable from within your program (not usually advisable),
use the @code{putenv}, @code{setenv}, and @code{unsetenv} functions.
@xref{Environment Access, , Environment Access, libc, The GNU C Library
Reference Manual}, for more information on these functions.


@node Compiling multiple files, Writing a makefile, Environment variables, Putting a program together
@section Compiling multiple files

@cindex Compiling multiple files
@cindex Multiple files, compiling

It is usually very simple to compile a program that has been divided
across multiple source files.  Instead of typing

@pindex gcc
@smallexample
gcc -o @var{executable} @var{sourcefile.c}
@end smallexample

@noindent
you would type

@smallexample
gcc -o @var{executable} @var{sourcefile_1.c} @var{sourcefile_2.c} @dots{} @var{sourcefile_n.c}
@end smallexample

@noindent
For example, if you were building a simple database program called @file{mydb},
the command line might look something like this:

@smallexample
gcc -o mydb main.c keyboard_io.c db_access.c sorting.c
@end smallexample

Of course, if (say) @file{db_access.c} were lengthy, it might take a
long time to compile your program every time you executed this command,
even if you only made a small change in one of the other files.  To
avoid this, you might want to compile each of the source files into its
own object file, then link them together to make your program.  If you
did, each time you made a small change in one file, you need only
recompile that single file and then link the object files together
again, potentially a great savings in time and patience.  Here is how to
generate a permanent object file for @file{db_access.c}.

@smallexample
gcc -c db_access.c
@end smallexample

This would generate a permanent object code file called
@file{db_access.o}, indicated by the suffix @samp{.o}.  You would
perform this step when needed for each of the source code files, then
link them together with the following command line:

@smallexample
gcc -o mydb main.o keyboard_io.o db_access.o sorting.o
@end smallexample

You might even put the various commands into a shell file, so that you
wouldn't need to type them repeatedly.  For example, you could put the
last command line into a shell file called @file{build}, so that all you
would need to do to build your executable from object code files is type
the following line.

@smallexample
./build
@end smallexample

For programs on a very small scale, this approach works quite well.  If
your project grows even slightly complex, however, you will have a hard
time keeping track of which object files are ``fresh'' and which need to
be recreated because the corresponding source files have been changed
since their last compilation. That's where the GNU utility @code{make}
comes in.  (@xref{Writing a makefile}.)



@node Writing a makefile, Building a library, Compiling multiple files, Putting a program together
@section Writing a makefile

@cindex Writing makefiles
@cindex Makefiles, writing
@pindex make @r{program}

The GNU @command{make} program automatically determines which pieces of
a large program need to be recompiled, and issues the commands to
compile them.  You need a file called a @dfn{makefile} to tell
@command{make} what to do.  Most often, the makefile tells
@command{make} how to compile and link a program.
@cindex makefile

In this section, we will discuss a simple makefile that describes how to
compile and link a text editor which consists of eight C source files
and three header files.  The makefile can also tell @command{make} how to
run miscellaneous commands when explicitly asked (for example, to remove
certain files as a clean-up operation).

Although the examples in this section show C programs, you can use
@command{make} with any programming language whose compiler can be run
with a shell command.  Indeed, @command{make} is not limited to programs.
You can use it to describe any task where some files must be updated
automatically from others whenever the others change.

Your makefile describes the relationships among files in your program
and provides commands for updating each file.  In a program, typically,
the executable file is updated from object files, which are in turn made
by compiling source files.@refill

Once a suitable makefile exists, each time you change some source files,
this simple shell command:

@smallexample
make
@end smallexample

@noindent
suffices to perform all necessary recompilations.  The @command{make}
program uses the makefile database and the last-modification times of
the files to decide which of the files need to be updated.  For each of
those files, it issues the commands recorded in the database.

You can provide command line arguments to @command{make} to control which
files should be recompiled, or how.

When @command{make} recompiles the editor, each changed C source file
must be recompiled.  If a header file has changed, each C source file
that includes the header file must be recompiled to be safe.  Each
compilation produces an object file corresponding to the source file.
Finally, if any source file has been recompiled, all the object files,
whether newly made or saved from previous compilations, must be linked
together to produce the new executable editor.
@cindex recompilation
@cindex editor

@menu
* Rule Introduction::           
* A simple makefile::           
* make in action::              
* Variables simplify makefiles::  
* Letting make deduce commands::  
* Combining rules by prerequisite::  
* Rules for cleaning the directory::  
@end menu

@node Rule Introduction, A simple makefile, Writing a makefile, Writing a makefile
@subsection What a Rule Looks Like
@cindex Makefile rule, introduction to
@cindex Makefile rule parts
@cindex Parts of makefile rules

A simple makefile consists of ``rules'' with the following shape:

@cindex Makefile targets, introduction to
@cindex Makefile prerequisites, introduction to
@cindex Makefile commands, introduction to
@example
@group
@var{target} @dots{} : @var{prerequisites} @dots{}
        @var{command}
        @dots{}
        @dots{}
@end group
@end example

A @dfn{target} is usually the name of a file that is generated by a
program; examples of targets are executable or object files.  A target
can also be the name of an action to carry out, such as @samp{clean}.

A @dfn{prerequisite} is a file that is used as input to create the
target.  A target often depends on several files.

@cindex Tab characters in makefile rules
@cindex Makefile rules, tab characters in
A @dfn{command} is an action that @command{make} carries out.  A rule may
have more than one command, each on its own line.  @strong{Please note:}
you need to put a tab character at the beginning of every command line!
This is a common mistake that even experienced makefile writers can
make.

Usually a command is defined by a rule with prerequisites and serves to
create a target file if any of the prerequisites change.  However, the
rule that specifies commands for the target need not have prerequisites.
For example, the rule containing the delete command associated with the
target @samp{clean} does not have prerequisites.

A @dfn{rule}, then, explains how and when to remake certain files
which are the targets of the particular rule.  @command{make} carries out
the commands on the prerequisites to create or update the target.  A
rule can also explain how and when to carry out an action.

A makefile may contain other text besides rules, but a simple makefile
need only contain rules.  Rules may look somewhat more complicated
than shown in this template, but all fit the pattern more or less.



@node A simple makefile, make in action, Rule Introduction, Writing a makefile
@subsection A simple makefile

@cindex Simple makefile
@cindex Makefile, simple

Here is a straightforward makefile that describes the way an executable
file called @file{edit} depends on eight object files which, in turn,
depend on eight C source files and three header files.

In this example, all the C files include @file{defs.h}, but only files
that define editing commands include @file{command.h}, and only
low-level files that change the editor buffer include @file{buffer.h}.

@smallexample
@group
edit : main.o kbd.o command.o display.o \
       insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o

main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit main.o kbd.o command.o display.o \
           insert.o search.o files.o utils.o
@end group
@end smallexample

@noindent
We split each long line into two lines using a backslash; this is like
using one long line, but easier to read.

@cindex Continuation lines in makefiles
@cindex @code{\} (backslash), for makefile continuation lines
@cindex backslash (@code{\}), for makefile continuation lines
@cindex Quoting newline character in makefile
@cindex Newline character, quoting in makefile

To use this makefile to create the executable file called @file{edit},
type:

@smallexample
make
@end smallexample

To use this makefile to delete the executable file and all the object
files from the directory, type:

@smallexample
make clean
@end smallexample

In the example makefile, the targets include the executable file
@file{edit}, and the object files @file{main.o} and @file{kbd.o}.  The
prerequisites are files such as @file{main.c} and @file{defs.h}.  In
fact, each @samp{.o} file is both a target and a prerequisite.  Commands
include @command{cc -c main.c} and @command{cc -c kbd.c}.

When a target is a file, it needs to be recompiled or relinked if any
of its prerequisites change.  In addition, any prerequisites that are
themselves automatically generated should be updated first.  In this
example, @file{edit} depends on each of the eight object files; the
object file @file{main.o} depends on the source file @file{main.c} and
on the header file @file{defs.h}.

A shell command follows each line that contains a target and
prerequisites.  These shell commands tell @command{make} how to update
the target file.  A tab character must come at the beginning of every
command line to distinguish command lines from other lines in the
makefile.  (Bear in mind that @command{make} does not know anything
about how the commands work.  It is up to you to supply commands that
will update the target file properly.)
@cindex shell command

@cindex @code{clean} makefile target
@pindex rm @r{program}
The target @code{clean} is not a file, but merely the name of an action.
Since this action is not carried out as part of the other targets,
@code{clean} is not a prerequisite of any other rule.  Consequently,
@command{make} never does anything with it unless you explicitly type
@command{make clean}.  Not only is this rule @emph{not} a prerequisite,
it does not have any prerequisites itself, so the only purpose of the
rule is to run the specified commands.  Targets like @code{clean} that
do not refer to files but are just actions are called @dfn{phony
targets}.




@node make in action, Variables simplify makefiles, A simple makefile, Writing a makefile
@subsection make in action
@cindex processing a makefile
@cindex makefile, processing

@c RWHE
@c 'make' should be '@command{make}' in subsection heading, but TeX chokes

@cindex default makefile goal
@cindex goal, makefile, default
@cindex goal
By default, @command{make} starts with the first target whose name does
not start with @samp{.}.  This is called the @dfn{default goal}.
(@dfn{Goals} are the targets that @command{make} tries to update.)

@c RWHE
@c How do goals differ from targets?

In the simple example of the previous section, the default goal is to
update the executable program @file{edit}; therefore, we put that rule
first.

Thus, when you give the command:

@smallexample
make
@end smallexample

@noindent
@command{make} reads the makefile in the current directory and begins by
processing the first rule.  In the example, this rule is for relinking
@file{edit}; but before @command{make} can fully process this rule, it
must process the rules for the files that @file{edit} depends on, which
in this case are the object files.  Each of these files is processed
according to its own rule.  These rules say to update each @samp{.o}
file by compiling its source file.  The recompilation must be done if
the source file, or any of the header files named as prerequisites, is
more recent than the object file, or if the object file does not exist.

The other rules are processed because their targets appear as
prerequisites of the goal.  If some other rule is not depended on by the
goal (or anything that the goal depends on, and so forth), then that
rule is not processed, unless you tell @command{make} to do so (with a
command such as @command{make clean}.

Before recompiling an object file, @command{make} considers updating its
prerequisites (the source file and header files).  This makefile does
not specify anything to be done for them---the @samp{.c} and @samp{.h}
files are not the targets of any rules---so @command{make} does nothing
for these files.  But @command{make} can update automatically generated
C programs, such as those made by Bison or Yacc, by defining the
@samp{.c} and @samp{.h} files as targets and specifying how to create
them with Bison, Yacc, or whatever other program generated them.

After recompiling the appropriate object files, @command{make} decides
whether to link @file{edit}.  This must be done if the file @file{edit}
does not exist, or if any of the object files are newer than it is.  If
an object file was just recompiled, it is now newer than @file{edit}, so
@file{edit} is relinked.
@cindex relinking

Thus, if we change the file @file{insert.c} and run @command{make}, then
@command{make} will recompile that file, update @file{insert.o}, and
then link @file{edit}.  If we change the file @file{command.h} and run
@command{make}, @command{make} will recompile the object files
@file{kbd.o}, @file{command.o} and @file{files.o}, and then link the
file @file{edit}.

@node Variables simplify makefiles, Letting make deduce commands, make in action, Writing a makefile
@subsection Variables simplify makefiles

@cindex Variables, simplifying makefiles with
@cindex Simplifying makefiles with variables

In our example, we had to list all the object files twice in the rule for
@file{edit} (repeated here):

@example
@group
edit : main.o kbd.o command.o display.o \
              insert.o search.o files.o utils.o
        cc -o edit main.o kbd.o command.o display.o \
                   insert.o search.o files.o utils.o
@end group
@end example

@vindex objects
Such duplication is error-prone; if a new object file is added to the
system, we might add it to one list and forget the other.  We can
eliminate the risk and simplify the makefile by using a variable.
@dfn{Variables} in @command{make} enable a text string to be defined
once and substituted in multiple places later.  They are similar to C
macros. (@xref{Macros}.)

@vindex OBJECTS @r{makefile variable}
@vindex objs @r{makefile variable}
@vindex OBJS @r{makefile variable}
@vindex obj @r{makefile variable}
@vindex OBJ @r{makefile variable}
It is standard practice for every makefile to have a variable named
@code{objects}, @code{OBJECTS}, @code{objs}, @code{OBJS}, @code{obj},
or @code{OBJ} that is a list of all object file names.  We would
define such a variable @code{objects} with a line like this in the
makefile:@refill

@smallexample
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o
@end group
@end smallexample

@noindent
Then, in every place we want to put a list of the object file names, we can
substitute the variable's value by writing @code{$(objects)}

Here is how the complete simple makefile looks when you use a variable
for the object files:

@smallexample
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)
main.o : main.c defs.h
        cc -c main.c
kbd.o : kbd.c defs.h command.h
        cc -c kbd.c
command.o : command.c defs.h command.h
        cc -c command.c
display.o : display.c defs.h buffer.h
        cc -c display.c
insert.o : insert.c defs.h buffer.h
        cc -c insert.c
search.o : search.c defs.h buffer.h
        cc -c search.c
files.o : files.c defs.h buffer.h command.h
        cc -c files.c
utils.o : utils.c defs.h
        cc -c utils.c
clean :
        rm edit $(objects)
@end group
@end smallexample

@node Letting make deduce commands, Combining rules by prerequisite, Variables simplify makefiles, Writing a makefile
@subsection Letting make deduce commands

@cindex Deducing commands from implicit makefile rules
@cindex Commands, deducing from implicit makefile rules
@cindex Implicit makefile rules, introduction
@cindex Makefile rules, implicit, introduction

@c RWHE
@c Why doesn't @command work in section headers?

It is not necessary to spell out the commands for compiling the
individual C source files, because @command{make} can figure them out:
it has an @dfn{implicit rule} for updating a @samp{.o} file from a
correspondingly named @samp{.c} file using a @command{gcc -c} command.
For example, it will use the command @command{gcc -c main.c -o main.o}
to compile @file{main.c} into @file{main.o}.  We can therefore omit the
commands from the rules for the object files.@refill

When a @samp{.c} file is used automatically in this way, it is also
automatically added to the list of prerequisites.  We can therefore omit
the @samp{.c} files from the prerequisites, provided we omit the commands.

Here is the entire example, with both of these changes, and the variable
@code{objects} as suggested above:

@example
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

main.o : defs.h
kbd.o : defs.h command.h
command.o : defs.h command.h
display.o : defs.h buffer.h
insert.o : defs.h buffer.h
search.o : defs.h buffer.h
files.o : defs.h buffer.h command.h
utils.o : defs.h

.PHONY : clean
clean :
        -rm edit $(objects)
@end group
@end example

@noindent
This is how we would write the makefile in actual practice.
(@xref{Rules for cleaning the directory}, for the complications
associated with @code{clean}.)

Because implicit rules are so convenient, they are important.  You
will see them used frequently.@refill



@node Combining rules by prerequisite, Rules for cleaning the directory, Letting make deduce commands, Writing a makefile
@subsection Combining rules by prerequisite

@cindex Combining rules by prerequisite
@cindex Prerequisite, combining rules by

When the objects of a makefile are created by implicit rules alone, an
alternative style of makefile is possible.  In this style of makefile,
you group entries by their prerequisites instead of by their targets.
Here is an example of this alternative style:

@smallexample
@group
objects = main.o kbd.o command.o display.o \
          insert.o search.o files.o utils.o

edit : $(objects)
        cc -o edit $(objects)

$(objects) : defs.h
kbd.o command.o files.o : command.h
display.o insert.o search.o files.o : buffer.h
@end group
@end smallexample

@noindent
Here @file{defs.h} is given as a prerequisite of all the object files,
and @file{command.h} and @file{buffer.h} are prerequisites of the
specific object files listed for them.

Whether this is better is a matter of taste: it is more compact, but some
people dislike it because they find it clearer to put all the information
about each target in one place.


@node Rules for cleaning the directory,  , Combining rules by prerequisite, Writing a makefile
@subsection Rules for cleaning the directory
@cindex cleaning up

Compiling a program is not the only thing you might want to write rules
for.  Makefiles commonly do a few other things besides compiling a
program: for example, they can often delete all the object files and
executables so that the directory is @dfn{clean}.

@vindex clean @r{makefile target}
Here is how we could write a @command{make} rule for cleaning our
example editor:

@smallexample
@group
clean:
        rm edit $(objects)
@end group
@end smallexample

In practice, we might want to write the rule in a somewhat more
complicated manner to handle unanticipated situations.  For example:

@smallexample
@group
.PHONY : clean
clean :
        -rm edit $(objects)
@end group
@end smallexample

@noindent
This prevents @command{make} from getting confused by an actual file
called @file{clean} and causes it to continue in spite of errors from
@code{rm}.

A rule such as this should not be placed at the beginning of the
makefile, because we do not want it to run by default!  Thus, in the
example makefile, we want the rule for @file{edit}, which recompiles
the editor, to remain the default goal.

Since @code{clean} is not a prerequisite of @file{edit}, this rule will
not run at all if we give the command @command{make} with no arguments.
In order to run the rule, we have to type @command{make clean}.



@node Building a library, Questions 17, Writing a makefile, Putting a program together
@section Building a library

@cindex Building libraries
@cindex Compiling libraries
@cindex Libraries, compiling

We explored what libraries are and how to use them in a previous
chapter.  (@xref{Libraries}, if you need to refresh your memory.)  You
may have wondered how libraries are written in the first place.  Is the
whole process too complicated for a mortal C programmer to attempt?  Not
at all.

Suppose you have a function (or set of functions) that you would like to
use widely across the various C programs you write.  You might even like
to make it available to other users in a convenient way.  To create a
code library that will enable you to achieve this, follow the sequence
below.  We will use a code example, but you can create your own library
by taking similar steps.

@enumerate

@item

Here's an example of the kind of function you might like to use in
multiple programs.  It accepts one string containing some text to print,
and then prints it on the default printer.

For the sake of example, the file below is named @file{lpr_print.c}.

@smallexample
@group
#include <stdio.h>

void lpr_print (char *the_text)
@{
  FILE *printer;

  printer = popen ("lpr", "w");
  fprintf (printer, the_text);
  pclose (printer);
@}
@end group
@end smallexample

@noindent
(@xref{Programming with pipes}, for the rationale behind this function.)

@item

Now we will create a library.

@itemize @bullet

@cindex Libraries, static, creating
@cindex Static libraries, creating
@cindex Creating static libraries
@item
To create a static library called @file{liblprprint.a} containing this
function, just type the following two command lines in your GNU shell:

@pindex ar @r{program}
@findex -c @r{option of GCC}
@smallexample
@group
gcc -c lpr_print.c
ar rs liblprprint.a lpr_print.o
@end group
@end smallexample

The @option{-c} option to @command{gcc} produces only a @samp{.o} object code file,
without linking it, while the @command{ar} command (with its @option{rs} options)
permits the creation of an @dfn{archive} file, which can contain a bundle of other
files that can be re-extracted later (for example, when executing library code).
In this case, we are only archiving one object code file, but in some cases, you might
want to archive multiple ones.  (See the @command{man} page for @command{ar}
for more information.)

@cindex Libraries, shared, creating
@cindex Shared libraries, creating
@cindex Creating shared libraries
@item
To create a shared library called @file{liblprprint.so} instead, enter
the following sequence of commands:@footnote{To create library files
containing multiple object files, simply include the object files on the
same command line.  For example, to create a static library with
multiple object files, type a command such as @command{ar rs
liblprprint.a lpr_print.o lpr_print2.o lpr_print3.o}.  Similarly, to
create a shared library, type @command{gcc -shared -o liblprprint.so
lpr_print.o lpr_print2.o lpr_print3.o}.}

@findex -fpic @r{option of GCC}
@smallexample
@group
gcc -c -fpic lpr_print.c
gcc -shared -o liblprprint.so lpr_print.o
@end group
@end smallexample

@findex -fPIC @r{option of GCC}
@noindent
(For the record, @samp{pic} stands for ``position-independent code'', an
object-code format required for shared libraries.  You might need to use
the option @option{-fPIC} instead of @option{-fpic} if your library is
very large.)

@end itemize

@cindex Header files, for libraries
@cindex Library header files
@item
Now create a header file that will allow users access to the functions
in your library.  You should provide one function prototype for each
function in your library.  Here is a header file for the library we
have created, called @file{liblprprint.h}.

@smallexample
@group
/*
   liblprprint.h:
   routines in liblprprint.a
   and liblprprint.so
*/

extern void lpr_print (char *the_text);
@end group
@end smallexample

@item

Now you should put your libraries and include file somewhere your code
can access them.  For the sake of this example, create the directories
@file{include} and @file{lib} in your home directory.  Once you have
done so, move the @samp{.a} and @samp{.so} files you have created to
@file{lib}, and the @samp{.h} file to @file{include}.

@item

If you have taken the last step, and you want to run a program linked to
a shared version of your library, you should type a line like the
following into your shell (the following command line assumes you are
using the Bash shell and that your home directory is named
@file{/home/fred}):

@vindex LD_LIBRARY_PATH @r{shell variable}
@smallexample
export LD_LIBRARY_PATH=/home/fred/lib:$LD_LIBRARY_PATH
@end smallexample

This command line sets an environment variable that makes the linker
search the @file{/home/fred/lib} directory before it searches anywhere
else.  You can include it in your @file{.bashrc} or @file{.bash_profile}
file.  If you don't execute this command before you attempt to run a program
using your shared library, you will probably receive an error.

@item

Now you can write programs that use your library.  Consider the following
short program, called @file{printer.c}:

@smallexample
@group
#include <liblprprint.h>

/* To shorten example, not using argp */
int main ()
@{
  lpr_print ("Hello, Multiverse!\nHowarya?\n");
  return 0;
@}
@end group
@end smallexample

@itemize @bullet

To compile this program using your static library,
type something like the following command line:

@findex --static @r{option of GCC}
@findex -I @r{option of GCC}
@findex -L @r{option of GCC}
@findex -l @r{option of GCC}
@smallexample
gcc --static -I../include -L../lib -o printer printer.c -llprprint
@end smallexample

@noindent
The @option{--static} option forces your static library to be linked;
the default is your shared version.  The @option{-llprprint} option
makes GCC link in the @file{liblprprint} library, just as you would need
to type @option{-lm} to link in the @file{libm} math library.

The @option{-I../include} and @option{-L../lib} options specify that the
compiler should look in the @file{../include} directory for include
files and in the @file{../lib} directory for library files.  This
assumes that you have created the @file{include} and @file{lib}
directories in your home directory as outlined above, and that you are
compiling your code in a subdirectory of your home directory.  If you
are working two directories down, you would specify
@option{-I../../include}, and so on.

The above command line assumes you are using only one @samp{.c}
source code file; if you are using more than one, simply include them
on the command line as well. (@xref{Compiling multiple files}.)

@strong{Note:}
Using the @option{--static} option will force the compiler to link
all libraries you are using statically.
If you want to use the static version of your library,
but some shared versions of other libraries, you can omit the
@option{--static} option from the command line and specify the
static version of your library explicitly, as follows:

@smallexample
gcc -I../include -L../lib -o printer printer.c ../lib/liblprprint.a
@end smallexample

@item
To compile this program using your shared library, type
something like the following command line.

@smallexample
gcc -I../include -L../lib -o printer printer.c -llprprint
@end smallexample

@end itemize

@item
The executable produced is called @file{printer}.  Try it!

@end enumerate

@node Questions 17,  , Building a library, Putting a program together
@section Questions

@enumerate

@item
What is the name of the preferred method for handling command-line options?

@item
What does the @option{-c} option of the @command{gcc} command do?

@item
What information does the @code{argc} variable contain?

@item
What information does the @code{argv} variable contain?

@item
What information does the @code{envp} variable contain?

@end enumerate





@c CHAPTER 18
@node Advanced operators, More data types, Putting a program together, Top
@chapter Advanced operators

@emph{Concise expressions}

@menu
* Hidden operators and values::  
* The comma operator::          
* Machine-level operators::     
* Questions 18::                
@end menu

In this chapter, we will examine some advanced mathematical and logical
operators in C.

@node Hidden operators and values, The comma operator, Advanced operators, Advanced operators
@section Hidden operators and values

@cindex Hidden operators
@cindex Operators, hidden

Many operators in C are more versatile than they appear to be at
first glance.  Take, for example, the following operators:

@findex = @r{operator}
@findex ++ @r{operator}
@findex -- @r{operator}
@findex += @r{operator}
@findex -= @r{operator}
@itemize @bullet
@item @code{=}
@item @code{++}
@item @code{--}
@item @code{+=}
@item @code{-=}
@end itemize

These operators can be used in some surprising ways to make C source
code elegant and compact.  (@xref{Expressions and operators}, if you
need a refresher in what they do.)  All of them can form expressions
that have their own values.  Such an expression can be taken as a whole
(a ``black box'') and treated as a single value, which can then be
assigned and compared to other expressions, in effect, ``hidden'' within
another expression.

The value of an expression is the result of the operation carried out in
the expression.  Increment and decrement statements have a value that is
one greater than or one less than the value of the variable they act
upon, respectively.

Consider the following two statements:

@smallexample
@group
c = 5;
c++;
@end group
@end smallexample

@noindent
The expression @code{c++} in the above context has the value 6.

Now consider these statements:

@smallexample
@group
c = 5;
c--;
@end group
@end smallexample

@noindent
The expression @code{c--} in the above context has the value 4.

@menu
* Hidden assignments::          
* Postfix and prefix ++ and --::  
* Arrays and hidden operators::  
* A warning about style::       
@end menu



@node Hidden assignments, Postfix and prefix ++ and --, Hidden operators and values, Hidden operators and values
@subsection Hidden assignments

@cindex Hidden assignments
@cindex Assignments, hidden

Assignment expressions have values too --- their values are the value of
the assignment.  For example, the value of the expression @code{c = 5}
is 5.

The fact that assignment statements have values can be used to make
C code more elegant.  An assignment expression can itself be assigned
to a variable.  For example, the expression @code{c = 0} can be assigned
to the variable @code{b}:

@smallexample
b = (c = 0);
@end smallexample

@noindent
or simply:

@smallexample
b = c = 0;
@end smallexample

@noindent
These equivalent statements set @code{b} and @code{c} to the value 0,
provided @code{b} and @code{c} are of the same type.  They are
equivalent to the more usual:

@smallexample
b = 0;
c = 0;
@end smallexample

@strong{Note:} Don't confuse this technique with a logical test for
equality.  In the above example, both @code{b} and @code{c} are set to
0.  Consider the following, superficially similar, test for equality,
however:

@smallexample
b = (c == 0);
@end smallexample

In this case, @code{b} will only be assigned a zero value (@code{FALSE})
if @code{c} does not equal 0.  If @code{c} does equal 0, then @code{b}
will be assigned a non-zero value for @code{TRUE}, probably 1.
(@xref{Comparisons and logic}, for more information.)

Any number of these assignments can be strung together:

@smallexample
a = (b = (c = (d = (e = 5))));
@end smallexample

@noindent
or simply:

@smallexample
a = b = c = d = e = 5;
@end smallexample

@noindent
This elegant syntax compresses five lines of code into a single line.

There are other uses for treating assignment expressions as values.
Thanks to C's flexible syntax, they can be used anywhere a value can be used.
Consider how an assignment expression might be used as a parameter to a function.
The following statement gets a character from standard input and
passes it to a function called @code{process_character}.

@smallexample
process_character (input_char = getchar());
@end smallexample

This is a perfectly valid statement in C, because the hidden assignment
statements passes the value it assigns on to @code{process_character}.
The assignment is carried out first and then the
@code{process_character} function is called, so this is merely a more
compact way of writing the following statements.

@smallexample
@group
input_char = getchar();
process_character (input_char);
@end group
@end smallexample

All the same remarks apply about the specialized assignment operators
@code{+=}, @code{*=}, @code{/=}, and so on.

The following example makes use of a hidden assignment in a @code{while}
loop to print out all values from 0.2 to 20.0 in steps of 0.2.

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main ()
@{
  double my_dbl = 0;

  while ((my_dbl += 0.2) < 20.0)
    printf ("%lf ", my_dbl);

  printf ("\n");

  return 0;
@}
@end group
@end smallexample


@node Postfix and prefix ++ and --, Arrays and hidden operators, Hidden assignments, Hidden operators and values
@subsection Postfix and prefix @code{++} and @code{--}

@findex ++ @r{postfix operator}
@findex -- @r{postfix operator}
@findex ++ @r{increment operator}
@findex -- @r{decrement operator}
@cindex Postfix operators
@cindex Postfix @code{++} operator
@cindex Postfix @code{--} operator
@findex ++ @r{prefix operator}
@findex -- @r{prefix operator}
@cindex Prefix operators
@cindex Prefix @code{++} operator
@cindex Prefix @code{--} operator

Increment (@code{++}) and decrement (@code{--}) expressions also have
values, and like assignment expressions, can be hidden away in
inconspicuous places.  These two operators are slightly more complicated
than assignments because they exist in two forms, postfix (for example,
@code{my_var++}) and prefix (for example, @code{++my_var}).

Postfix and prefix forms have subtly different meanings.  Take the
following example:

@smallexample
@group
int my_int = 3;
printf ("%d\n", my_int++);
@end group
@end smallexample

The increment operator is hidden in the parameter list of the
@code{printf} call.  The variable @code{my_int} has a value before the
@code{++} operator acts on it (3) and afterwards (4).

Which value is passed to @code{printf}?  Is @code{my_int} incremented
before or after the @code{printf} call?  This is where the two forms of
the operator (postfix and prefix) come into play.

@strong{If the increment or decrement operator is used as a prefix, the
operation is performed @emph{before} the function call.  If the operator
is used as a postfix, the operation is performed @emph{after} the function
call.}

In the example above, then, the value passed to @code{printf} is 3, and when
the @code{printf} function returns, the value of @code{my_int} is incremented
to 4.  The alternative is to write

@smallexample
@group
int my_int = 3;
printf ("%d\n", ++my_int);
@end group
@end smallexample

@noindent
in which case the value 4 is passed to @code{printf}.

The same remarks apply to the decrement operator as to the increment operator.



@node Arrays and hidden operators, A warning about style, Postfix and prefix ++ and --, Hidden operators and values
@subsection Arrays and hidden operators

@cindex Arrays and hidden operators
@cindex Hidden operators and arrays
@cindex Operators, hidden, and arrays

Hidden operators can simplify dealing with arrays and strings quite a
bit.  Hiding operators inside array subscripts or hidding assignments
inside loops can often streamline tasks such as array initialization.
Consider the following example of a one-dimensional array of integers.

@smallexample
#include <stdio.h>

#define ARRAY_SIZE 20

/* To shorten example, not using argp */
int main ()
@{
  int idx, array[ARRAY_SIZE];

  for (idx = 0; idx < ARRAY_SIZE; array[idx++] = 0)
    ;

  return 0;
@}
@end smallexample

@noindent
This is a convenient way to initialize an array to zero.  Notice that
the body of the loop is completely empty!

Strings can benefit from hidden operators as well.  If the standard
library function @code{strlen}, which finds the length of a string, were
not available, it would be easy to write it with hidden operators:

@smallexample
@group
#include <stdio.h>

int my_strlen (char *my_string)
@{
  char *ptr;
  int count = 0;

  for (ptr = my_string; *(ptr++) != '\0'; count++)
    ;

  return (count);
@}
@end group

@group
/* To shorten example, not using argp */
int main (int argc, char *argv[], char *envp[])
@{
  char string_ex[] = "Fabulous!";

  printf ("String = '%s'\n", string_ex);
  printf ("Length = %d\n", my_strlen (string_ex));

  return 0;
@}
@end group
@end smallexample

@noindent
The @code{my_strlen} function increments @code{count} while the end of
string marker @samp{\0} is not found.  Again, notice that the body of
the loop in this function is completely empty.


@node A warning about style,  , Arrays and hidden operators, Hidden operators and values
@subsection A warning about style

@cindex Style, warning about
@cindex Style

Overuse of ``hidden'' operators can produce code that is difficult
to understand.  @xref{Hidden operators and style}, for some cautions
about when not to use them.



@node The comma operator, Machine-level operators, Hidden operators and values, Advanced operators
@section The comma operator

@cindex Comma operator
@cindex Operator, comma
@findex , @r{operator}

The comma operator (@code{,}) works almost like the semicolon @samp{;}
that separates one C statement from another.  You can separate almost
any kind of C statment from another with a comma operator.  The
comma-separated expressions are evaluated from left to right and the
value of the whole comma-separated sequence is the value of the
rightmost expression in the sequence.  Consider the following code
example.

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main (int argc, char *argv[], char *envp[])
@{
  int a, b, c, d;

  a = (b = 2, c = 3, d = 4);
  printf ("a=%d\nb=%d\nc=%d\nd=%d\n",
	  a, b, c, d);
  return 0;
@}
@end group
@end smallexample

The value of @code{(b = 2, c = 3, d = 4)} is 4 because the value of its
rightmost sub-expression, @code{d = 4}, is 4.  The value of @code{a} is
thus also 4.  When run, this example prints out the following text:

@smallexample
@group
a=4
b=2
c=3
d=4
@end group
@end smallexample

The comma operator is very useful in @code{for} loops.  (@xref{The
flexibility of for}, for an example.)


@node Machine-level operators, Questions 18, The comma operator, Advanced operators
@section Machine-level operators

@emph{Bits and Bytes.  Flags.  Shifting.}

@cindex Bits
@cindex Bytes
@cindex Binary digits

Bits (or binary digits), the values 0 and 1, are the lowest-level
software objects in a computer; there is nothing more primitive.  C
gives programmers full access to bits and bit sequences, and even
provides high-level operators for manipulating them.

@cindex Bit strings
All computer data whatsoever is composed of @dfn{bit strings}.  The word
``string'' is being used here in its more general sense of sequence; do not
confuse the usage with ``text string''.  Although all text strings are
bit strings, not all bit strings are text strings.

The only difference between a text string and a floating-point value is
the way we interpret the pattern of bits in the computer's memory.  For
the most part, we can simply ignore the low level of the computer in
which computer data appears as bit strings.  Systems programmers, on the
other hand, such as those who wrote GNU/Linux, must frequently
manipulate bits directly in order to handle flags.

@cindex Flags
A @dfn{flag} is a bit in a bit string that can be either @dfn{set} (1)
or @dfn{cleared} (0).  We have run across a few flags already, such as
the various flags passed to the GNU C Library functions @code{open}; the
flags @code{O_RDONLY} and @code{O_WRONLY} are actually macros that
specify binary values, which can be manipulated and examined with binary
OR and similar functions.  Flags are normally declared as integers in C.

Programmers who perform bit operations on a regular basis often use either
octal (base-8) or hexadecimal (base-16) numbers, because every octal digit
specifies exactly three bits, and every hexadecimal digit specifies four.


@menu
* Bitwise operators::           
* Shift operations::            
* Truth tables and bit masks::  
@end menu

@node Bitwise operators, Shift operations, Machine-level operators, Machine-level operators
@subsection Bitwise operators

@cindex Bitwise operators
@cindex Operators, bitwise

C provides the following operators for handling bit patterns:

@table @code

@cindex Bit-shift left operator
@findex << @r{bitwise operator}
@item <<
Bit-shift left by a specified number of bit positions

@cindex Bit-shift right operator
@findex >> @r{bitwise operator}
@item >>
Bit-shift right by a specified number of bit positions

@cindex Bitwise inclusive OR
@findex | @r{bitwise operator}
@item |
Bitwise inclusive OR

@cindex Bitwise exclusive OR
@findex ^ @r{bitwise operator}
@item ^
Bitwise exclusive OR

@cindex Bitwise AND
@findex & @r{bitwise operator}
@item &
Bitwise AND

@cindex Bitwise NOT
@findex ~ @r{bitwise operator}
@item ~
Bitwise NOT

@cindex Bit-shift left assignment
@findex <<= @r{bitwise operator}
@item <<=
Bit-shift left assignment (@var{var} = @var{var} << @var{value})

@cindex Bit-shift right assignment
@findex >>= @r{bitwise operator}
@item >>=
Bit-shift right assignment (@var{var} = @var{var} >> @var{value})

@cindex Exclusive OR assignment
@findex |= @r{bitwise operator}
@item |=
Exclusive OR assignment (@var{var} = @var{var} | @var{value})

@cindex Inclusive OR assignment
@findex ^= @r{bitwise operator}
@item ^=
Inclusive OR assignment (@var{var} = @var{var} ^ @var{value})

@cindex AND assignment
@findex &= @r{bitwise operator}
@item &=
AND assignment (@var{var} = @var{var} & @var{value})

@end table

@noindent
The meaning and syntax of these operators is given below.

Don't confuse bitwise operators (such as bitwise AND, @code{&}) with
logical operators (such as logical AND, @code{&&}).  Bitwise operators
operate on each bit in the operand individually.



@node Shift operations, Truth tables and bit masks, Bitwise operators, Machine-level operators
@subsection Shift operations

@cindex Shift operators
@cindex Operators, shift

Imagine a bit string as represented by the following group of boxes.
Every box represents a bit, a binary digit; the ones and zeros inside
represent their values.  The values written across the top are
the place-values of each bit.  (Just as a decimal (base-10) number has
a ones place, a tens place, a hundreds place, a thousands place, and so on,
a binary (base-2) number has the places 1, 2, 4, 8, 16, 32, etc.)
The number after the equals sign shows the value of the bit string in
decimal notation.

@smallexample
 128  64  32  16  8   4   2   1
 -------------------------------
| 0 | 0 | 0 | 0 | 0 | 0 | 0 | 1 |  =  1
 -------------------------------
@end smallexample

@noindent
Bit-shift operators move whole bit strings left or right.
The syntax of the bit-shift left operation is @code{@var{value} << @var{positions}};
that of bit-shift right is @code{@var{value} >> @var{positions}};
So for example, using the bit string (1) above, the value of @code{1 << 1} is 2,
because the bit string would have been moved one position to the left:

@smallexample
 128  64  32  16  8   4   2   1
 -------------------------------
| 0 | 0 | 0 | 0 | 0 | 0 | 1 | 0 |  =  2
 -------------------------------
@end smallexample

@noindent
Notice how the space to the right of the shifted bit string is simply filled with a 0.

Similarly, the value of @code{1 << 4} is 16, because the original bit string
is shifted left four places:

@smallexample
 128  64  32  16  8   4   2   1
 -------------------------------
| 0 | 0 | 0 | 1 | 0 | 0 | 0 | 0 |  =  16
 -------------------------------
@end smallexample

@noindent
Notice, again, that the spaces to the right of the original
bit string are filled out with zeros.

Now for a slightly more difficult one.  The value of @code{6 << 2} is 24.
Here is the bit string representing 6:

@smallexample
 128  64  32  16  8   4   2   1
 -------------------------------
| 0 | 0 | 0 | 0 | 0 | 1 | 1 | 0 |  =  6
 -------------------------------
@end smallexample

@noindent
Shift 6 left 2 places:

@smallexample
 128  64  32  16  8   4   2   1
 -------------------------------
| 0 | 0 | 0 | 1 | 1 | 0 | 0 | 0 |  =  24
 -------------------------------
@end smallexample


@noindent
Notice that every shift left multiplies by 2.  (Since @code{6 << 2} means to shift 6 left twice,
the result is 24.)

As you might expect, every shift right performs (integer) division by two on the number.
If a bit is shifted beyond the ones position (the rightmost ``box''), however,
then it ``drops off'' and is lost.  So the following equalities hold:

@smallexample
1 >> 1 == 0
2 >> 1 == 1
2 >> 2 == 0
n >> n == 0
@end smallexample

One common use of bit-shifting is to scan through the bits of a bit-string
one by one in a loop.  This is done with bit masks, as described in the next section.



@node Truth tables and bit masks,  , Shift operations, Machine-level operators
@subsection Truth tables and bit masks

@cindex Truth tables
@cindex Bit masks
@cindex Tables, truth
@cindex Masks, bit

The binary operators AND (@code{&}), OR (inclusive OR, @code{|}) and XOR
(exclusive OR, also called EOR, @code{^}) perform comparisons, or
@dfn{masking} operations, between two bit strings.  They are also binary
operators in the sense that they take two operands.  There is another
operator called NOT (@code{~}) that is a unary operator; it takes only
one operand.

These bitwise operations are best summarized by @dfn{truth tables}.
Each truth table for a binary operator (that is, one with two operands),
indicates what the result of the operation is for every possible
combination of two bits.


@menu
* Bitwise NOT::                 
* Bitwise AND::                 
* Bitwise inclusive OR::        
* Bitwise exclusive OR (XOR/EOR)::  
* Masks::                       
@end menu

@node Bitwise NOT, Bitwise AND, Truth tables and bit masks, Truth tables and bit masks
@subsubsection Bitwise NOT

@cindex Bitwise NOT, truth table
@cindex NOT, bitwise, truth table
@findex ~ @r{bitwise operator truth table}

The unary operator NOT (@code{~}) simply generates the @dfn{one's complement}
of the bit string; that is, it returns the same bit string, with all ones replaced
with zeros and all zeros replaced with ones. As a truth table this would be summarized as follows:

@multitable {MMMMMM} {MMMMMM}
@item ~@var{value} @tab @var{result}
@item 0 @tab 1
@item 1 @tab 0
@end multitable


@node Bitwise AND, Bitwise inclusive OR, Bitwise NOT, Truth tables and bit masks
@subsubsection Bitwise AND

@cindex Bitwise AND, truth table
@cindex AND, bitwise, truth table
@findex & @r{bitwise operator truth table}

Bitwise AND operates on two values, for example @code{0 & 1}.  Both the
first value @emph{and} the second value must be 1 in order for the
result to be 1.  As a truth table this would be summarized as follows:

@multitable {MMMMMM} {MMMMMM} {MMMMMM}
@item @var{value1} @tab @var{value2} @tab @var{result}
@item 0 @tab 0 @tab 0
@item 0 @tab 1 @tab 0
@item 1 @tab 0 @tab 0
@item 1 @tab 1 @tab 1
@end multitable



@node Bitwise inclusive OR, Bitwise exclusive OR (XOR/EOR), Bitwise AND, Truth tables and bit masks
@subsubsection Bitwise inclusive OR

@cindex Bitwise inclusive OR, truth table
@cindex Inclusive OR, bitwise, truth table
@cindex OR, bitwise inclusive, truth table
@findex | @r{bitwise operator truth table}

Bitwise OR operates on two values, for example @code{0 | 1}.  The result
is 1 if the first value @emph{or} the second value is 1, @emph{or} both
are 1.  As a truth table this would be summarized as follows:

@multitable {MMMMMM} {MMMMMM} {MMMMMM}
@item @var{value1} @tab @var{value2} @tab @var{result}
@item 0 @tab 0 @tab 0
@item 0 @tab 1 @tab 1
@item 1 @tab 0 @tab 1
@item 1 @tab 1 @tab 1
@end multitable



@node Bitwise exclusive OR (XOR/EOR), Masks, Bitwise inclusive OR, Truth tables and bit masks
@subsubsection Bitwise exclusive OR (XOR/EOR)

@cindex Bitwise exclusive OR, truth table
@cindex Exclusive OR, bitwise, truth table
@cindex OR, bitwise exclusive, truth table
@cindex EOR, truth table
@cindex XOR, truth table
@findex ^ @r{bitwise operator truth table}

Bitwise XOR operates on two values, for example @code{0 ^ 1}.  The
result is 1 if the first value @emph{or} the second value is 1, but
@emph{not} if @emph{both} are 1 (hence the name ``exclusive OR'').  As a
truth table this would be summarized as follows:

@multitable {MMMMMM} {MMMMMM} {MMMMMM}
@item @var{value1} @tab @var{value2} @tab @var{result}
@item 0 @tab 0 @tab 0
@item 0 @tab 1 @tab 1
@item 1 @tab 0 @tab 1
@item 1 @tab 1 @tab 0
@end multitable


@node Masks,  , Bitwise exclusive OR (XOR/EOR), Truth tables and bit masks
@subsubsection Masks

@cindex Bit masks
@cindex Masks, bit

Bit strings and bitwise operators are often used to make @dfn{masks}.  A
mask is a bit string that ``fits over'' another bit string and produces
a desired result, such as singling out particular bits from the second
bit string, when the two bit strings are operated upon.  This is
particularly useful for handling flags; programmers often wish to know
whether one particular flag is set in a bit string, but may not care
about the others.  For example, you might create a mask that only allows
the flag of interest to have a non-zero value, then AND that mask with
the bit string containing the flag.

Consider the following mask, and two bit strings from which we want to
extract the final bit:

@smallexample
mask   = 00000001
value1 = 10011011
value2 = 10011100

mask & value1 == 00000001
mask & value2 == 00000000
@end smallexample

The zeros in the mask @dfn{mask off} the first seven bits and only let
the last bit show through.  (In the case of the first value, the last bit is 1;
in the case of the second value, the last bit is 0.)

Alternatively, masks can be built up by operating on several flags, usually
with inclusive OR:

@smallexample
flag1 = 00000001
flag2 = 00000010
flag3 = 00000100

mask = flag1 | flag2 | flag3

mask == 00000111
@end smallexample

@xref{Opening files at a low level}, for a code example that actually
uses bitwise OR to join together several flags.

It should be emphasized that the flag and mask examples are written
in @dfn{pseudo-code}, that is, a means of expressing information
that resembles source code, but cannot be compiled.  It is not possible to
use binary numbers directly in C.

The following code example shows how bit masks and bit-shifts can be combined.
It accepts a decimal number from the user between 0 and 128, and prints out
a binary number in response.

@smallexample
@group
#include <stdio.h>
#define NUM_OF_BITS 8

/* To shorten example, not using argp */
int main ()
@{
  char *my_string;
  int input_int, args_assigned;
  int nbytes = 100;
  short my_short, bit;
  int idx;

  /* This hex number is the same as binary 10000000 */
  short MASK = 0x80;

  args_assigned = 0;
  input_int = -1;

  while ((args_assigned != 1) ||
	 (input_int < 0) || (input_int > 128))
    @{
      puts ("Please enter an integer from 0 to 128.");
      my_string = (char *) malloc (nbytes + 1);
      getline (&my_string, &nbytes, stdin);
      args_assigned = sscanf (my_string, "%d", &input_int);
      if ((args_assigned != 1) ||
	  (input_int < 0) || (input_int > 128))
	puts ("\nInput invalid!");
    @}

  my_short = (short) input_int;

  printf ("Binary value = ");

  /*
     Convert decimal numbers into binary
     Keep shifting my_short by one to the left
     and test the highest bit.  This does
     NOT preserve the value of my_short!
  */

  for (idx = 0; idx < NUM_OF_BITS; idx++)
    @{
      bit = my_short & MASK;
      printf ("%d", bit/MASK);
      my_short <<= 1;
    @}

  printf ("\n");
  return 0;
@}
@end group
@end smallexample


@node Questions 18,  , Machine-level operators, Advanced operators
@section Questions 18

@enumerate

@item
Hidden operators can be used in return statements, for example,

@smallexample
return (++x);
@end smallexample

@noindent
Would there be any point in writing the following?

@smallexample
return (x++);
@end smallexample

@item
What distinguishes a bit string from an ordinary variable?  Can any
variable be a bit string?

@item
What is the difference between an inclusive OR operation and an
exclusive OR operation?

@item
Find out what the decimal values of the following
operations are.

@enumerate
@item
@code{7 & 2}
@item
@code{1 & 1}
@item
@code{15 & 3}
@item
@code{15 & 7}
@item
@code{15 & 7 & 3}
@end enumerate
@noindent
Try to explain the results.  (Hint: sketch out the numbers as bit strings.)

@item
Find out what the decimal values of the following operations are.

@enumerate
@item
@code{1 | 2}
@item
@code{1 | 2 | 3}
@end enumerate


@item
Find out the decimal values of the following operations.
@enumerate
@item
@code{1 & (~1)}
@item
@code{23 & (~23)}
@item
@code{2012 & (~2012)}
@end enumerate
(Hint: write a short program to work them out.)

@end enumerate







@c CHAPTER 19
@node More data types, Data structures, Advanced operators, Top
@chapter More data types

@cindex Data types

There are still a few data types in C that we have not discussed.
Actually, since C allows you to define new data types at will, no one
can ever cover all possibilities.  We will only discuss the most
important examples.

@tindex enum @r{type}
@tindex void @r{type}
@tindex volatile @r{type}
@tindex const @r{type}
@table @code
@item enum
Type specifier for variables that can have a set of different values.
@item void
Type specifier for ``empty'' data.
@item volatile
Type qualifier for data that changes independently of the program.
@item const
Type qualifier for data that cannot change.
@end table

@tindex struct @r{type}
@tindex union @r{type}
In addition, there are two data types called @code{struct} and
@code{union} that are so important, they have received their own
chapter.  (@xref{Data structures}, for more information on
@code{struct} and @code{union}.)


@menu
* enum::                        
* void::                        
* volatile::                    
* Constants::                   
* struct and union ::           
* typedef::                     
* Questions 19::                
@end menu


@node enum, void, More data types, More data types
@section @code{enum}

@tindex enum @r{type}

The @code{enum} type specifier is short for ``enumerated data''.
The user can define a fixed set of words that a variable of type
@code{enum} can take as its value.  The words are assigned
integer values by the compiler so that code can compare @code{enum}
variables.  Consider the following code example:

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main ()
@{
  enum compass_direction
  @{
    north,
    east,
    south,
    west
  @};

  enum compass_direction my_direction;
  my_direction = west;

  return 0;
@}
@end group
@end smallexample

@noindent
This example defines an enumerated variable type called @code{compass_direction},
which can be assigned one of four enumerated values: @code{north}, @code{east},
@code{south}, or @code{west}.  It then declares a variable called @code{my_direction}
of the enumerated @code{compass_direction} type, and assigns @code{my_direction}
the value @code{west}.

Why go to all this trouble?  Because enumerated data types allow the
programmer to forget about any numbers that the computer might need in
order to process a list of words, and simply concentrate on using the
words themselves.  It's a higher-level way of doing things; in fact, at
a lower level, the computer assigns each possible value in an enumerated
data type an integer cconstant --- one that you do not need to worry about.

Enumerated variables have a natural partner in the @code{switch} statement,
as in the following code example.

@smallexample
@group
#include <stdio.h>

enum compass_direction
@{
  north,
  east,
  south,
  west
@};
@end group


@group
enum compass_direction get_direction()
@{
  return south;
@}
@end group

@group
/* To shorten example, not using argp */
int main ()
@{
  enum compass_direction my_direction;
  puts ("Which way are you going?");
  my_direction = get_direction();

  switch (my_direction)
  @{
    case north:
      puts("North? Say hello to the polar bears!");
      break;
@end group

@group
    case south:
      puts("South? Say hello to Tux the penguin!");
      break;
@end group

@group
    case east:
      puts("If you go far enough east, you'll be west!");
      break;

    case west:
      puts("If you go far enough west, you'll be east!");
      break;
  @}

  return 0;
@}
@end group
@end smallexample

@noindent
In this example, the @code{compass_direction} type has been made global,
so that the @code{get_direction} function can return that type.  The
@code{main} function prompts the user, @samp{Which way are you going?},
then calls the ``dummy'' function @code{get_direction}.  In a ``real'' program,
such a function would accept input from the user and return an enumerated
value to @code{main}, but in this case it merely returns the value @code{south}.
The output from this code example is therefore as follows:

@smallexample
@group
Which way are you going?
South? Say hello to Tux the penguin!
@end group
@end smallexample

As mentioned above, enumerated values are converted into integer values
internally by the compiler.  It is practically never necessary to know
what integer values the compiler assigns to the enumerated words in the list,
but it may be useful to know the order of the enumerated items with respect
to one another.  The following code example demonstrates this.

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main ()
@{
  enum planets
  @{
    Mercury,
    Venus,
    Earth,
    Mars,
    Jupiter,
    Saturn,
    Uranus,
    Neptune,
    Pluto
  @};
@end group

@group
  enum planets planet1, planet2;

  planet1 = Mars;
  planet2 = Earth;

  if (planet1 > planet2)
    puts ("Mars is farther from the Sun than Earth is.");
  else
    puts ("Earth is farther from the Sun than Mars is.");

  return 0;
@}
@end group
@end smallexample

@noindent
The output from this example reads as follows:

@smallexample
Mars is farther from the Sun than Earth is.
@end smallexample




@node void, volatile, enum, More data types
@section @code{void}

@tindex void @r{type}

The @code{void} data type was introduced to make C syntactically
consistent.  The main reason for @code{void} is to declare functions
that have no return value.  The word ``void'' is therefore used in the
sense of ``empty'' rather than that of ``invalid''.

C functions are considered by the compiler to return type @code{int}
unless otherwise specified.  Although the data returned by a function
can legally be ignored by the function calling it, the @code{void} data
type was introduced by the ANSI standard so that C compilers can issue
warnings when an integer value is not returned by a function that is
supposed to return one.  If you want to write a function that does not
return a value, simply declare it @code{void}.  A function
declared @code{void} has no return value and simply returns with the
command @code{return;}.

Variables can be declared @code{void} as well as functions:

@smallexample
@group
void my_variable;
void *my_pointer;
@end group
@end smallexample

A variable that is itself declared @code{void} (such as
@code{my_variable} above) is useless; it cannot be assigned a value,
cannot be cast to another type, in fact, cannot be used in any way.

Void pointers (type @code{void *}) are a different case, however.  A
void pointer is a @dfn{generic pointer}; any pointer can be cast to a
void pointer and back without any loss of information.  Any type of
pointer can be assigned to (or compared with) a void pointer,
without casting the pointer explicitly.

Finally, a function call can be cast to @code{void} in order to
explicitly discard a return value.  For example, @code{printf} returns a
value, but it is seldom used.  Nevertheless, the two lines of code that
follow are equivalent:

@smallexample
@group
printf ("Hullo!\n");
(void) printf ("Hullo!\n");
@end group
@end smallexample

@noindent
There is no good reason to prefer the second line to the first, however, so
using the more concise form is preferred.



@node volatile, Constants, void, More data types
@section @code{volatile}

@tindex volatile @r{type}

The @code{volatile} type qualifier was introduced by the ANSI Standard
to permit the use of @dfn{memory-mapped variables}, that is, variables
whose value changes autonomously based on input from hardware.  One
might declare a volatile variable @code{volatile float temperature;}
whose value fluctuated according to readings from a digital thermometer
connected to the computer.

There is another use for the @code{volatile} qualifier that has to do
with multiprocessing operating systems.  Independent processes
that share common memory might each change the value of a variable
independently.  The @code{volatile} keyword serves as a warning to
the compiler that it should not @dfn{optimize} the code containing the variable
(that is, compile it so that it will run in the most efficient way possible)
by storing the value of the variable and referring to it repeatedly,
but should reread the value of the variable every time.  (Volatile
variables are also flagged by the compiler as not to be stored
in read-only memory.)



@node Constants, struct and union , volatile, More data types
@section Constants

@cindex Constants
@tindex const @r{type}

@dfn{Constants} in C usually refer to two things: either a type of
variable whose value cannot change declared with the @code{const}
qualifier (in this case, ``variable'' is something of a misnomer), or a
string or numeric value incorporated directly into C code, such as
@samp{1000}.  We will examine both kinds of constant in the next two
sections.


@menu
* const::                       
* Constant expressions::        
@end menu


@node const, Constant expressions, Constants, Constants
@subsection @code{const}

@tindex const @r{type}

Sometime a variable must be assigned a value once and once only; for
example, it might be in read-only memory.  The reserved word
@code{const} is, like @code{static} and @code{volatile}, a data type
qualifier that can be applied to many different data types.  It declares
a variable to be a constant, whose value cannot be reassigned.  A
@code{const} must be assigned a value when it is declared.

@smallexample
@group
const double avogadro = 6.02e23;
const int moon_landing = 1969;
@end group
@end smallexample

You can also declare constant arrays:

@smallexample
@group
const int my_array[] =
@{0, 1, 2, 3, 4, 5, 6, 7, 8@};
@end group
@end smallexample

Any attempt to assign a new value to a @code{const} variable
will result in a compile-time error such as the following:

@smallexample
@group
const.c: In function `main':
const.c:11: warning: assignment of read-only variable `avogadro'
@end group
@end smallexample


@node Constant expressions,  , const, Constants
@subsection Constant expressions

@cindex Constant expressions
@cindex Expressions, constant

You can declare constant expressions explicitly as a particular type of
value, such as a long integer, a float, a character, or a hexadecimal
value, with certain typographical conventions.  For example, it is
possible to declare a value explicitly as a long by placing the letter
@samp{L} after the numeric constant.  For example:

@smallexample
@group
#define MY_LONG1 23L;
#define MY_LONG2 236526598L;
@end group
@end smallexample

Similarly, you can declare a value to be a float by appending the letter
@samp{F} to it.  Of course, numeric constants containing a decimal
point are automatically considered floats.  The following constants
are both floating-point numbers:

@smallexample
@group
#define MY_FLOAT1 23F;
#define MY_FLOAT2 23.5001;
@end group
@end smallexample

You can declare a hexadecimal (base-16) number by prefixing
it with @samp{0x}; you can declare an octal (base-8) number
by prefixing it with @samp{0}.  For example:

@smallexample
@group
int my_hex_integer = 0xFF;   /* hex FF */
int my_octal_integer = 077;  /* octal 77 */
@end group
@end smallexample

You can use this sort of notation with strings and character constants
too.  ASCII character values range from 0 to 255.  You can print any character
in this range by prefixing a hexadecimal value with @samp{\x} or an octal
value with @samp{\}.  Consider the following code example, which demonstrates
how to print the letter @samp{A}, using either a hexadecimal character code
(@samp{\x41}) or an octal one (@samp{\101}).

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main ()
@{
  printf ("\\x41 hex   = \x41\n");
  printf ("\\101 octal = \101\n");

  return 0;
@}
@end group
@end smallexample

The preceding code prints the following text:

@smallexample
@group
\x41 hex   = A
\101 octal = A
@end group
@end smallexample

Of course, you can assign a variable declared with the @code{const}
qualifier (the first kind of ``constant'' we examined) a constant
expression declared with one of the typographical expressions above.
For example:

@smallexample
@group
const int my_hex_integer = 0xFF;   /* hex FF */
const int my_octal_integer = 077;  /* octal 77 */
@end group
@end smallexample




@node struct and union , typedef, Constants, More data types
@section @code{struct} and @code{union}

@tindex struct @r{type}
@tindex union @r{type}

Structures and unions are data types that are important enough to merit
a chapter of their own. @xref{Data structures}, for more information on
structures and unions.


@node typedef, Questions 19, struct and union , More data types
@section @code{typedef}

@findex typedef @r{command}

You can define your own data types in C with the @code{typedef} command,
which may be written inside functions or in global scope.  This
statement is used as follows:

@smallexample
typedef @var{existing_type} @var{new_type};
@end smallexample

You can then use the new type to declare variables, as in the following
code example, which declares a new type called @code{my_type} and declares
three variables to be of that type.

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main (int argc, char *argv[], char *envp[])
@{
  typedef int my_type;
  my_type var1, var2, var3;

  var1 = 10;
  var2 = 20;
  var3 = 30;

  return 0;
@}
@end group
@end smallexample

@noindent
The new type called @code{my_type} behaves just like an integer.
Why, then, would we use it instead of @code{integer}?

Actually, you will seldom wish to rename an existing data type.
The most important use for @code{typedef} is in renaming structures and unions,
whose names can become long and tedious to declare otherwise.
We'll investigate structures and unions in the next chapter.
(@xref{Data structures}.)

@node Questions 19,  , typedef, More data types
@section Questions 19

@enumerate

@item
Enumerated names are given integer values by the compiler so that it can do
multiplication and division with them.  True or false?

@item
Does @code{void} do anything which C cannot already do without this type?

@item
What type qualifier might a variable accessed directly by a timer be given?

@item
Write a statement which declares a new type "real" to be like the usual
type "double".

@item
Variables declared with the qualifier @code{const} can be of any type.
True or false?

@end enumerate






@c CHAPTER 20
@node Data structures, Recursion, More data types, Top
@chapter Data structures

@emph{Grouping data.  Tidying up programs.}

@cindex Data structures
@cindex Structures, data

It would be hard for a program to manipulate data if it were scattered
around with no particular structure.  C therefore has several facilities
to group data together in convenient packages, or @dfn{data structures}.
One type of data structure in C is the @code{struct} (or
@dfn{structure}) data type, which is a group of variables clustered
together with a common name.  A related data type is the @code{union},
which can contain any type of variable, but only one at a time.
Finally, structures and unions can be linked together into complex data
structures such as lists and trees.  This chapter explores all of these
kinds of data structure.

@cindex Data structures, as distinguished from structures
@cindex Structures, as distinguished from data structures
It is important to distinguish the terms @dfn{structure} and @dfn{data
structure}.  ``Data structure'' is a generic term that refers to any
pattern of data in a computer program.  An array is a data structure, as
is a string.  A structure is a particular data type in C, the
@code{struct}; all @code{struct} variables (structures) are data
structures, but not all data structures are structures.


@menu
* struct::                      
* Memory allocation::           
* union::                       
* Complex data structures::     
* Further data structure examples::  
* Questions 20::                
@end menu



@node struct, Memory allocation, Data structures, Data structures
@section @code{struct}

@cindex Structures
@tindex struct @r{type}

A @dfn{structure} is a group of one or more variables under a
single name.  Unlike arrays, structures can contain a combination of
different types of data; they can even contain arrays.  A structure can
be arbitrarily complex.

@cindex Members of structures
@cindex Structures, members of
Every type of structure that is defined is given a name, and the
variables it contains (called @dfn{members}) are also given names.
Finally, every variable declared to be of a particular structure type
has its own name as well, just as any other variable does.

@menu
* Structure declarations::      
* Using structures::            
* Arrays of structures::        
* Nested structures::           
* Pointers to structures::      
* Initializing structures::     
@end menu

@node Structure declarations, Using structures, struct, struct
@subsection Structure declarations

@cindex Declaring structures
@cindex Structures, declaring

The following statement is a type declaration, so it belongs with other
declarations, either at the start of a program or the start of a code block.

@smallexample
@group
struct personal_data
@{
  char name[100];
  char address[200];
  int year_of_birth;
  int month_of_birth;
  int day_of_birth;
@};
@end group
@end smallexample

@noindent
The statement says: define a type of variable that holds a string of 100
characters called @code{name}, a string of 200 characters called
@code{address}, and three integers called @code{year_of_birth},
@code{month_of_birth}, and @code{day_of_birth}.  Any variable declared
to be of type @code{struct personal_data} will contain these components,
which are called @dfn{members}.  Different structures, even different
@emph{types} of structure, can have members with the same name, but the
values of members of different structures are independent of one
another.  You can also use the same name for a member as for an ordinary
variable in your program, but the computer will recognize them as
different entities, with different values.  This is similar to the
naming convention for humans, where two different men may share the name
"John Smith", but are recognized as being different people.

Once you have declared a type of structure, you can declare variables to
be of that type.  For example:

@smallexample
struct personal_data person0001;
@end smallexample

The statement above declares a variable called @code{person0001} to be of type
@code{struct personal_data}.  This is probably the most common method of
declaring a structure variable, but there are two equivalent methods.
For example, a structure variable can be declared immediately after the
declaration of the structure type:

@smallexample
@group
struct personal_data
@{
  char name[100];
  char address[200];
  int year_of_birth;
  int month_of_birth;
  int day_of_birth;
@} person0001;
@end group
@end smallexample



@menu
* Structure declarations using typedef::  
@end menu

@node Structure declarations using typedef,  , Structure declarations, Structure declarations
@subsubsection Structure declarations using typedef

@cindex Declaring structures with @code{typedef}
@cindex @code{typedef}, declaring structures with
@cindex Structures, declaring with @code{typedef}

Alternatively, the @code{typedef} command can be used to cut down
on typing out code in the long term.  The type definition is made
once at the start of the program and subsequent variable declarations
are made by using the new name, without the word @code{struct}:

@smallexample
@group
typedef struct
@{
  char name[100];
  char address[200];
  int year_of_birth;
  int month_of_birth;
  int day_of_birth;
@} personal_data;

personal_data person001;
personal_data person002;
personal_data person003;
@end group
@end smallexample

Note that this use of the @code{typedef} command parallels the usage we
have already seen:

@smallexample
@group
typedef @var{existing_type} @var{new_type}
@end group
@end smallexample

In the example above of using @code{typedef} to declare a new type of
structure, the metasyntactic variable @var{new_type} corresponds to the
identifier @code{personal_data}, and the metasyntactic variable
@var{existing_type} corresponds to the following code:

@smallexample
@group
struct
@{
  char name[100];
  char address[200];
  int year_of_birth;
  int month_of_birth;
  int day_of_birth;
@}
@end group
@end smallexample

Structure type and variable declarations can be either local or global,
depending on their placement in the code, just as any other declaration
can be.



@node Using structures, Arrays of structures, Structure declarations, struct
@subsection Using structures

@cindex Structures, using
@cindex Using structures

Structures are extremely powerful data types.  Not only can you pass a
whole structure as a parameter to a function, or return one as a value
from a function.  You can even assign one structure to another.

@findex . @r{dot operator of structures}
@cindex Structures, @code{.} dot operator
@cindex Member operator of structures
@cindex Structures, member operator of
You can get and set the values of the members of a structure with the
@samp{.} dot character.  This is called the @dfn{member operator}.  The
general form of a member reference is:

@smallexample
@var{structure_name}.@var{member_name}
@end smallexample

@noindent
In the following example, the year 1852 is assigned to the
@code{year_of_birth} member of the structure variable @code{person1}, of
type @code{struct personal_data}.  Similarly, month 5 is assigned to the
@code{month_of_birth} member, and day 4 is assigned to the
@code{day_of_birth} member.

@smallexample
@group
struct personal_data person1;

person1.year_of_birth = 1852;
person1.month_of_birth = 5;
person1.day_of_birth = 4;
@end group
@end smallexample

@findex -> @r{dot operator of structures}
@cindex Structures, @code{->} operator
@cindex Member operator of structures
@cindex Structures, member operator of
Besides the dot operator, C also provides a special @code{->} member
operator for use in conjunction with pointers, because pointers and
structures are used together so often. (@xref{Pointers to structures}.)

Structures are easy to use For example, you can assign one structure to
another structure of the same type (unlike strings, for example, which
must use the string library routine @code{strcpy}).  Here is an example
of assigning one structure to another:

@smallexample
@group
struct personal_data person1, person2;

person2 = person1;
@end group
@end smallexample

The members of the @code{person2} variable now contain all the data of the members
of the @code{person1} variable.

Structures are passed as parameters in the usual way:

@smallexample
my_structure_fn (person2);
@end smallexample

You would declare such a function thus:

@smallexample
@group
void my_structure_fn (struct personal_data some_struct)
@{
@}
@end group
@end smallexample

@noindent
Note that in order to declare this function, the @code{struct personal_data}
type must be declared globally.

Finally, a function that returns a structure variable would be declared thusly:

@smallexample
@group
struct personal_data structure_returning_fn ()
@{
  struct personal_data random_person;
  return random_person;
@}
@end group
@end smallexample

@noindent
Of course, @code{random_person} is a good name for the variable returned
by this bare-bones function, because without unless one writes code to
initialize it, it can only be filled with garbage values.


@node Arrays of structures, Nested structures, Using structures, struct
@subsection Arrays of structures

@cindex Arrays of structures
@cindex Structures, arrays of

Just as arrays of basic types such as integers and floats are allowed in
C, so are arrays of structures.  An array of structures is declared in
the usual way:

@smallexample
struct personal_data my_struct_array[100];
@end smallexample

The members of the structures in the array are then accessed by
statements such as the following:

@noindent
The value of a member of a structure in an array can be assigned to
another variable, or the value of a variable can be assigned to a
member.  For example, the following code assigns the number 1965 to the
@code{year_of_birth} member of the fourth element of
@code{my_struct_array}:

@smallexample
@group
my_struct_array[3].year_of_birth = 1965;
@end group
@end smallexample

@noindent 
(Like all other arrays in C, @code{struct} arrays start their numbering
at zero.)

The following code assigns the value of the @code{year_of_birth} member
of the fourth element of @code{my_struct_array} to the variable
@code{yob}:

@smallexample
@group
yob = my_struct_array[3].year_of_birth;
@end group
@end smallexample

Finally, the following example assigns the values of all the members of
the second element of @code{my_struct_array}, namely
@code{my_struct_array[1]}, to the third element, so
@code{my_struct_array[2]} takes the overall value of
@code{my_struct_array[1]}.

@smallexample
@group
my_struct_array[2] = my_struct_array[1];
@end group
@end smallexample


@node Nested structures, Pointers to structures, Arrays of structures, struct
@subsection Nested structures

@cindex Nested structures
@cindex Structures, nested

Structures can contain other structures as members; in other words,
structures can @dfn{nest}.  Consider the following two structure types:

@smallexample
@group
struct first_structure_type
@{
  int integer_member;
  float float_member;
@};

struct second_structure_type
@{
  double double_member;
  struct first_structure_type struct_member;
@};
@end group
@end smallexample


@noindent
The first structure type is incorporated as a member of the second structure type.
You can initialize a variable of the second type as follows:

@smallexample
@group
struct second_structure_type demo;

demo.double_member = 12345.6789;
demo.struct_member.integer_member = 5;
demo.struct_member.float_member = 1023.17;
@end group
@end smallexample

@noindent
The member operator @samp{.} is used to access members of structures
that are themselves members of a larger structure.  No parentheses are
needed to force a special order of evaluation; a member operator
expression is simply evaluated from left to right.

In principle, structures can be nested indefinitely.  Statements such as
the following are syntactically acceptable, but bad style. (@xref{Style}.)

@smallexample
my_structure.member1.member2.member3.member4 = 5;
@end smallexample

What happens if a structure contains an instance of its own type,
however?  For example:

@smallexample
@group
struct regression
@{
  int int_member;
  struct regression self_member;
@};
@end group
@end smallexample

@noindent
In order to compile a statement of this type, your computer would
theoretically need an infinite amount of memory.  In practice, however,
you will simply receive an error message along the following lines:

@smallexample
@group
struct5.c: In function `main':
struct5.c:8: field `self_member' has incomplete type
@end group
@end smallexample

The compiler is telling you that @code{self_member} has been declared
before its data type, @code{regression} has been fully declared --- naturally,
since you're declaring @code{self_member} in the middle of declaring its own data type!


@node Pointers to structures, Initializing structures, Nested structures, struct
@subsection Pointers to structures

@cindex Pointers to structures
@cindex Structures, pointers to

Although a structure cannot contain an instance of its own type, it can
can contain a pointer to another structure of its own type, or even to
itself.  This is because a pointer to a structure is not itself a
structure, but merely a variable that holds the address of a structure.
Pointers to structures are quite invaluable, in fact, for building data
structures such as linked lists and trees.  (@xref{Complex data structures}.)

A pointer to a structure type variable is declared by a statement
such as the following:

@smallexample
struct personal_data *my_struct_ptr;
@end smallexample

@noindent
The variable @code{my_struct_ptr} is a pointer to a variable of type
@code{struct personal_data}.  This pointer can be assigned to any other
pointer of the same type, and can be used to access the members of its
structure.  According to the rules we have outlined so far, this would
have to be done like so:

@smallexample
@group
struct personal_data person1;

my_struct_ptr = &person1;
(*my_struct_ptr).day_of_birth = 23;
@end group
@end smallexample

@noindent
This code example says, in effect, ``Let the member @code{day_of_birth}
of the structure pointed to by @code{my_struct_ptr} take the value 23.''
Notice the use of parentheses to avoid confusion about the precedence of
the @samp{*} and @samp{.} operators.

There is a better way to write the above code, however, using a new
operator: @samp{->}.  This is an arrow made out of a minus sign and a
greater than symbol, and it is used as follows:

@smallexample
my_struct_ptr->day_of_birth = 23;
@end smallexample

The @samp{->} enables you to access the members of a structure directly
via its pointer.  This statement means the same as the last line of the
previous code example, but is considerably clearer.  The @samp{->} operator
will come in very handy when manipulating complex data structures.
(@xref{Complex data structures}.)



@node Initializing structures,  , Pointers to structures, struct
@subsection Initializing structures

@cindex Initializing structures
@cindex Structures, initializing

In the chapter on arrays, we explored how to initialize an array with
values at compile time.  (@xref{Initializing arrays}.)  It is also
possible to initialize structures at compile time, as shown below.
(This code example also shows how to dynamically allocate structures
with @code{malloc} and initialize them with the @code{->} operator.
@xref{Memory allocation}, for more information on this technique.)

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main()
@{
  struct personal_data
  @{
    char name[100];
    char address[200];
    int year_of_birth;
    int month_of_birth;
    int day_of_birth;
  @};
@end group

@group  
  struct personal_data person1 =
  @{
    "Liddell, Alice",
    "Wonderland",
    1852,
    5,
    4
  @};
@end group

@group
  struct personal_data person2 =
  @{
    "Hale-Evans, Ron",
    "Seattle, Washington",
    1965,
    6,
    27
  @};
@end group

@group
  struct personal_data* person_ptr1;
  struct personal_data* person_ptr2;

  person_ptr1 = (struct personal_data*)
    malloc (sizeof (struct personal_data));

  strcpy (person_ptr1->name, "Adams, Douglas");
  strcpy (person_ptr1->address, "The Galaxy");
  person_ptr1->year_of_birth = 1952;
  person_ptr1->month_of_birth = 3;
  /* Don't know his exact birthday */
@end group

@group
  person_ptr2 = (struct personal_data*)
    malloc (sizeof (struct personal_data));

  strcpy (person_ptr2->name, "Egan, Greg");
  strcpy (person_ptr2->address, "Permutation City");
  person_ptr2->year_of_birth = 1961;
  /* Don't know his birthday */
@end group

@group
  puts ("Data contained:");
  puts (person1.name);
  puts (person2.name);
  puts (person_ptr1->name);
  puts (person_ptr2->name);

  return 0;
@}
@end group
@end smallexample

Any trailing items not initialized by data you specify are set to zero.



@node Memory allocation, union, struct, Data structures
@section Memory allocation

@cindex Memory allocation
@cindex Allocation of memory

Most variables in C have a fixed size.  For example, a string declared
to be 200 bytes long will always be 200 bytes long throughout the
program.  Sometimes, however, you will need variables whose size can
vary.  You might want a string whose size can vary between 0 and 100
kilobytes, for instance.  We have already seen occasions where this sort
of string is needed with the @code{getline} function. (@xref{getline}.)

@cindex Dynamic data
@cindex Data, dynamic
@findex malloc @r{function}
@findex realloc @r{function}
This is where @dfn{dynamic data}, or data whose size can vary, comes in.
Dynamic data is created via the process of @dfn{memory allocation}, that
is, assigning a block of memory to a variable.  Blocks of memory are
usually assigned with the @code{malloc} function (the function name is
from the phrase ``memory allocation''), and can be resized with the
@code{realloc} (``memory reallocation'') function, and even merged back
into the pool of available memory with the @code{free} function.

@findex malloc @r{function}
The @code{malloc} function takes one argument, the number of bytes to
allocate.  It returns a void pointer, which provides the address of the
beginning of a block of memory that the program can use.  This void
pointer can be assigned to any other type of pointer.  The only way to
make use of the block of memory that has been allocated is through its
pointer; in that sense, the block is not a ``real'' variable, that is to
say, you cannot assign a value to the memory block directly.  Instead,
the address returned by @code{malloc} enables you to use the block
indirectly; in this way, the block can contain any kind of value a real
variable can. Having to use blocks indirectly through pointers is a
small price to pay for the flexibility of dynamic data.

The following code example allocates a ten-byte string:

@smallexample
@group
char *my_string;
my_string = (char *) malloc(10+1);
@end group
@end smallexample

@noindent
Notice that the void pointer returned by @code{malloc} is cast to a
character pointer (type @code{char *}) before it is assigned to
@code{my_string}.  (@xref{The cast operator}.)  Also notice that we have
actually allocated 11 bytes of space; this is because the 11th byte must
contain a null character that terminates the string but does not count
toward its actual length.  @strong{Careful!}  The newly-allocated block
will be filled with garbage.

@findex realloc @r{function}
To reallocate the memory, use the @code{realloc} function.  This
function takes two parameters.  The first is the pointer to the memory
block to be reallocated, and the second is a number of type
@code{size_t} that specifies the new size for the block.  It returns a
void pointer to the newly reallocated block.  Here is how to reallocate
the block allocated for @code{my_string} above, to a new size of 1000
bytes:

@smallexample
my_string = (char *) realloc (my_string, 1001);
@end smallexample

@noindent
The new block will contain all the data in the old block, followed by
enough space to pad out the block to the new length.  The new space will
be filled with garbage.

@findex free @r{function}
Finally, to free up the memory allocated to a block and return it to the
common pool of memory available to your program, use the @code{free}
function, which takes only one argument, the pointer to the block you
wish to free.  It does not return a value.

@smallexample
free (my_string);
@end smallexample

@findex -> @r{member operator}
It is also possible to allocate the memory for a structure when it is
needed and use the @samp{->} operator to access the members of the
structure, since we must access the structure via a pointer.  (See the
code sample following the next paragraph for an example of how to do
this.)  If you are creating complex data structures that require
hundreds or thousands of structure variables (or more), the ability to
create and destroy them dynamically can mean quite a savings in memory.

@findex sizeof @r{function}
It's easy enough to allocate a block of memory when you know you want
1000 bytes for a string, but how do you know how much memory to allocate
for a structure?  For this task, C provides the @code{sizeof} function,
which calculates the size of an object.  For example, @code{sizeof
(int)} returns the numbers of bytes occupied by an integer variable.
Similarly, @code{sizeof (struct personal_data)} returns the number of
bytes occupied by our @code{personal_data} structure.  To allocate a
pointer to one of these structures, then set the @code{year_of_birth}
member to 1852, you would write something like the following:

@smallexample
@group
struct personal_data* my_struct_ptr;

my_struct_ptr = (struct personal_data*)
  malloc (sizeof (struct personal_data));
my_struct_ptr->year_of_birth = 1852;
@end group
@end smallexample



@node union, Complex data structures, Memory allocation, Data structures
@section @code{union}

@cindex Unions
@tindex union @r{type}

A union is like a structure in which all of the members are stored at
the same address.  Only one member can be in a union at one time.  The
@code{union} data type was invented to prevent the computer from
breaking its memory up into many inefficiently sized chunks, a condition
that is called @dfn{memory fragmentation}.  

The @code{union} data type prevents fragmentation by creating a standard
size for certain data.  When the computer allocates memory for a
program, it usually does so in one large block of bytes.  Every variable
allocated when the program runs occupies a segment of that block.  When
a variable is freed, it leaves a ``hole'' in the block allocated for the
program.  If this hole is of an unusual size, the computer may have
difficulty allocating another variable to ``fill'' the hole, thus
leading to inefficient memory usage.  Since unions have a standard data
size, however, any ``hole'' left in memory by freeing a union can be
filled by another instance of the same type of union.  A union works
because the space allocated for it is the space taken by its largest
member; thus, the small-scale memory inefficiency of allocating space
for the worst case leads to memory efficiency on a larger scale.

@menu
* Declaration of unions::       
* Using unions::                
@end menu

@node Declaration of unions, Using unions, union, union
@subsection Declaration of unions

@cindex Declaring unions
@cindex Unions, declaring

A union is declared in the same way as a structure.  It has a list
of members, as in the example below:

@smallexample
@group
union int_or_float
@{
  int int_member;
  float float_member;
@};
@end group
@end smallexample

Declaring union variables is similar to declaring structure variables:

@smallexample
union int_or_float my_union1, my_union2;
@end smallexample

Just like structures, the members of unions can be accessed with the
@samp{.}  and @samp{->} operators.  However, unlike structures, the
variables @code{my_union1} and @code{my_union2} above can be treated as
either integers or floating-point variables at different times during
the program.  For example, if you write @code{my_union1.int_member =
5;}, then the program sees @code{my_union1} as being an integer.  (This
is only a manner of speaking.  However, @code{my_union1} by itself does
not have a value; only its members have values.)  On the other hand, if
you then type @code{my_union1.float_member = 7.7;}, the @code{my_union}
variable loses its integer value.  It is crucial to remember that a
union variable can only have one type at the same time.



@node Using unions,  , Declaration of unions, union
@subsection Using unions

@cindex Unions, using
@cindex Using unions
@cindex Unions and flag variables

One way to tell what type of member is currently stored in the union
is to maintain a flag variable for each union.  This can be done easily with
enumerated data.  For example, for the @code{int_or_float} type,
we might want an associated enumerated type like this:

@smallexample
@group
enum which_member
@{
  INT,
  FLOAT
@};
@end group
@end smallexample

@noindent
Notice that we used all-uppercase letters for the enumerated values.
We would have received a syntax error if we had actually used the
C keywords @code{int} and @code{float}.

Associated union and enumerated variables can now be declared in pairs:

@smallexample
@group
union int_or_float my_union1;
enum which_member my_union_status1;
@end group
@end smallexample

Handling union members is now straightforward.  For example:

@smallexample
@group
switch (my_union_status1)
  @{
  case INT:
    my_union1.int_member += 5;
    break;
  case FLOAT:
    my_union1.float_member += 23.222333;
    break;
  @}
@end group
@end smallexample

These variables could even be grouped into a structure for ease of use:

@smallexample
@group
struct multitype
@{
    union int_or_float number;
    enum which_member status;
@};

struct multitype my_multi;
@end group
@end smallexample

You would then make assignments to the members of this structure in pairs:

@smallexample
@group
my_multi.number.int_member = 5;
my_multi.status = INT;
@end group
@end smallexample




@node Complex data structures, Further data structure examples, union, Data structures
@section Complex data structures

@cindex Complex data structures
@cindex Data structures, complex

When building data structures, it is best to model the situation in
question clearly and efficiently.  Different types of data structure are
good for different things.  For example, arrays are good for storing
tabular information.  A chessboard looks like a two-dimensional array,
so such an array is a good data structure to model a chess game.  In
this section we will examine more complex data structures that are
useful for modeling more complex situations.

@menu
* Data structure diagrams::     
* Dynamic data structures::     
* Lists and trees::             
* Setting up a data structure::  
@end menu


@node Data structure diagrams, Dynamic data structures, Complex data structures, Complex data structures
@subsection Data structure diagrams

@cindex Data structure diagrams
@cindex Diagrams, data structures

Sometimes you will want to draw a picture that shows how to solve a
problem by displaying how all its parts are connected.  Such a picture
is called a @dfn{structure diagram}.

Consider a hypothetical application that stores a map of the local
countryside.  This program must store information about individual towns
and be able to give directions to the user about how to get from one
town to another.  A person driving a car from town to town might use a
map, but the application programmer might use a structure diagram.  Here
is a structure diagram for the imaginary town of New Haven, and its
neighboring towns North Haven, East Haven, South Haven, and West Haven:

@smallexample
@group
              North Haven

                   ^
                   |
                   v

West Haven <-> New Haven <-> East Haven

                   ^
                   |
                   v

              South Haven
@end group
@end smallexample

Once you have a structure diagram that represents your information, 
you can create a data structure that translates the structure diagram
into the computer's memory.  In this case, we can create a ``town structure''
that contains pointers to the towns that lie at the end of roads in the various
compass directions.  The town structure might look something like this:

@smallexample
@group
struct town 
@{ 
  struct town *north; 
  struct town *south; 
  struct town *east; 
  struct town *west; 
  char name[50]; 
@};
@end group
@end smallexample

If the user of this hypothetical application wishes to know what is to 
the north of a particular town, the program only has to check that town's
@code{north} pointer.


@node Dynamic data structures, Lists and trees, Data structure diagrams, Complex data structures
@subsection Dynamic data structures, Pointers and Dynamic Memory

@cindex Dynamic data structures
@cindex Data structures, dynamic
@cindex Complex data structures
@cindex Data structures, complex

For programs dealing with large sets of data, it would be a nuisance to
have to name every structure variable containing every piece of data in
the code --- for one thing, it would be inconvenient to enter new data
at run time because you would have to know the name of the variable in
which to store the data when you wrote the program.  For another thing,
variables with names are permanent --- they cannot be freed and their
memory reallocated, so you might have to allocate an impractically large
block of memory for your program at compile time, even though you might
need to store much of the data you entered at run time temporarily.

Fortunately, complex data structures are built out of dynamically allocated 
memory, which does not have these limitations.  All your program needs to do
is keep track of a pointer to a dynamically allocated block, and it will
always be able to find the block.

A complex data structure is usually built out of the following components:

@table @emph

@cindex Nodes
@item nodes
Dynamically-allocated blocks of data, usually structures.

@cindex Links
@item links
Pointers from nodes to their related nodes.

@cindex Root node
@cindex Node, root
@item root 
The node where a data structure starts, also known as the 
@dfn{root node}.  The address of the root of a data structure
must be stored explicitly in a C variable, or else you will lose
track of it.

@end table

There are some advantages to the use of dynamic storage for data
structures:

@itemize @bullet

@item As mentioned above, since memory is allocated as needed, 
we don't need to declare how much we shall use in advance.

@item Complex data structures can be made up of lots of ``lesser''
data structures in a modular way, making them easier to program.

@item Using pointers to connect structures means that they
can be re-connected in different ways as the need arises.  (Data
structures can be sorted, for example.)

@end itemize


@node Lists and trees, Setting up a data structure, Dynamic data structures, Complex data structures
@subsection Lists and trees

@cindex Lists
@cindex Trees
@cindex Nodes
@cindex Links

Two data structures that use nodes and links are very common:
the linked list and the binary tree

@menu
* Linked lists::                
* Binary trees::                
@end menu

@node Linked lists, Binary trees, Lists and trees, Lists and trees
@subsubsection Linked lists.

@cindex Linked lists
@cindex Lists, linked

A @dfn{linked list} is a linear sequence of structures joined together by
pointers.  Each node's pointer links to the next node in the sequence.
Linked lists have two main advantages over one dimensional arrays: they
can be sorted easily simply by redirecting pointers, and they can be
made any length at all dynamically.

Here is an example of a structure type from a linked list:

@smallexample
@group
struct list_node
@{
  double value;
  struct list_node *next;
@};
@end group
@end smallexample

@noindent
Here the @code{value} member holds the actual content of the node, in
this case a double-precision floating-point number, and the @code{next}
member points to the next node in the list.

You will often encounter another basic kind of linked list, called
a @dfn{doubly-linked list}.  Each node in a doubly-linked list contains
not only a pointer to the next node, but also to the previous node.
This kind of list makes it easier to determine what the node preceding
a node is, as well as the node succeeding it.



@node Binary trees,  , Linked lists, Lists and trees
@subsubsection Binary trees

@cindex Trees, binary
@cindex Binary trees

A @dfn{binary tree} is a data structure in which each node contains
links to two successor nodes, so that the whole structure is shaped like
a branching tree. A typical use for a binary tree might be storing
genealogical information; since (at this point in human evolution) every
individual has two parents, each node can represent a person and the two
linked nodes can represent that person's mother and father.  Let's
extend our @code{personal_data} structure to incorporate this kind of
information:

@smallexample
@group
struct personal_data
@{
  char name[100];
  char address[200];
  int year_of_birth;
  int month_of_birth;
  int day_of_birth;

  struct personal_data *mother;
  struct personal_data *father;
@};
@end group
@end smallexample



@node Setting up a data structure,  , Lists and trees, Complex data structures
@subsection Setting up a data structure

@cindex Data structures, setting up
@cindex Setting up data structures

Plan your data structures well, before you write any program code.
Changes in program code may not affect data structures, but changes
to data structures will likely imply drastic changes to program code.

@menu
* Designing your data structure::  
* Initializing your data structure::  
@end menu

@node Designing your data structure, Initializing your data structure, Setting up a data structure, Setting up a data structure
@subsubsection Designing your data structure

The steps you should take in designing a data structure follow a basic
pattern:

@enumerate

@item Group together all the kinds of information that must be stored
and define a structure type with a member for each kind of information.

@item Add structure pointers to the structure type to reflect
the way in which each bundle of information is connected to the others.

@item Design the algorithms to handle the memory allocation,
node linking, and data storage.

@end enumerate


@node Initializing your data structure,  , Designing your data structure, Setting up a data structure
@subsubsection Initializing your data structure

@cindex Data structures, initializing
@cindex Initializing data structurse

Once you understand your data structure, you can set about initializing it
in the following way:

@enumerate

@item  Declare your structure type.  For example:

@smallexample
@group
struct town 
@{ 
  struct town *north; 
  struct town *south; 
  struct town *east; 
  struct town *west; 
  char name[50]; 
@};
@end group
@end smallexample

@item    Declare two pointers to this type:

@smallexample
struct town *root, *current;
@end smallexample

@cindex Root nodes
@cindex Nodes, root
@noindent
The @code{root} pointer is used to point to the root node of the
data structure, and the @code{current} pointer points to the node
with which we are currently working.

@item   Allocate memory for the root node:

@smallexample
root = (struct town *) malloc (sizeof (struct town));
@end smallexample

@noindent
Be sure to check for errors. The variable @code{root} will be a null
pointer if no memory could be allocated for the node.

@item Initialize the members of the root node:

@smallexample
@group
root->north = NULL;
root->south = NULL;
root->east  = NULL;
root->west  = NULL;
strcpy (root->name, "New Haven");
@end group
@end smallexample

@cindex Null pointers
@vindex NULL @r{pointer}
@noindent
Note that @code{NULL} pointers tell the program when it has come to the
edge of the data structure, that is, when it has found a link that
doesn't lead anywhere.  At the moment, the links of the root node do not
point anywhere.  This will change as we add more nodes to the data
structure.

@item Create a new, non-root node:

@smallexample
@group
current = (struct town *) malloc (sizeof (struct town));
@end group
@end smallexample

@item Initialize the current node:

@smallexample
@group
current->north = NULL;
current->south = root;
current->east  = NULL;
current->west  = NULL;
strcpy (current->name, "North Haven");
@end group
@end smallexample

@item Link neighboring nodes to the current node, as appropriate:

@smallexample
@group
root->north = current;
@end group
@end smallexample

@item Repeat steps 5 through 7, as necessary.

@end enumerate

@xref{Controlled recursion with data structures}, for a practical
example of building a simple linked list programmatically.


@node Further data structure examples, Questions 20, Complex data structures, Data structures
@section Further data structure examples

@xref{Example programs}, to see a complete application program that uses
a complex data structure with nodes and links to stores its data later
in the book.


@node Questions 20,  , Further data structure examples, Data structures
@section Questions 20

@enumerate

@item
What is the difference between a structure and a union?

@item
What is a member?

@item
If @code{foo} is a structure variable, how would you find out the value of
its member @code{bar}?

@item
If @code{foo} is a pointer to a structure variable, how would you find
out the value of its member @code{bar}?

@item
How are data usually linked to make a complex data structure?

@item
Every structure variable in a complex data structure must have its own
variable name.  True or false?

@item
How are the members of structures accessed in a data structure?

@item
Write a small program to make linked list that contains three nodes
long and set all their values to be zero.  Can you automate this
program with a loop?  Can you make it work for any number of
nodes?

@end enumerate






@c CHAPTER 21
@node Recursion, Style, Data structures, Top
@chapter Recursion

@emph{The program that swallowed its tail.}

@cindex Recursion

This chapter is about functions that call themselves.  Consider the
program below:

@smallexample
@group
#include <stdio.h>

void black_hole()
@{
  black_hole();
@}

/* To shorten example, not using argp */
int main ()
@{
  black_hole();
  return 0;
@}
@end group
@end smallexample

The @code{main} function calls the @code{black_hole} function, which
calls itself, which calls itself, which calls@dots{} Once the control
flow enters @code{black_hole}, it will never exit.  This kind of
function is called a @dfn{recursive function}, and a function's act of
calling itself is called @dfn{recursion}.


@menu
* The stack::                   
* Controlled recursion::        
* Controlled recursion with data structures::  
* Recursion summary::           
* Questions 21::                
@end menu

@node The stack, Controlled recursion, Recursion, Recursion
@section The stack

@cindex Stack

What happens when we run the last example program?  The
@code{black_hole} function calls itself indefinitely.  Each function
call uses up a small portion of the computer's memory called the
@dfn{stack}.  Eventually all of this memory is used up, and a kind of
error called a @dfn{stack overflow} occurs.  The program then crashes
with a @dfn{Segmentation fault} error.

It is sometimes helpful to think of a function as a robot that does a
job.  A function definition in effect provides the blueprints for a
robot.  When the function is executed, it is as though a robot is built
on an assembly line in a robot factory.  A recursive function is like a
robot that builds a copy of itself on the same assembly line.  The
second robot is identical to the first in every way, except that it is
an assistant to the first robot, and has been passed different
arguments. This second robot may in turn build a copy of itself as well,
and so on.  It is crucial that the process of robots building robots
stop at some point; otherwise, the robot factory will run out of raw
materials (that is, computer memory), and the assembly line will grind
to a halt.

@menu
* The stack in detail::         
@end menu



@node The stack in detail,  , The stack, The stack
@subsection The stack in detail

@cindex Stack

Let's examine this process in detail.  When one function calls another
function in a C program, control passes from the first function to the
second function.  When the second function ends, control passes back to
the statement in the first function that immediately follows the
function call.  But how does the computer know where in its memory this
statement resides?

The answer is simple.  The computer keeps a list of the addresses in
memory of the places to which it must return, no matter how many
function calls are made.  This list is the stack.

The stack gets its name from the fact that it is a @dfn{LIFO}, or
@dfn{last in, first out} structure, meaning that the last item to be
@dfn{pushed onto} the stack is the first item to be @dfn{popped off}.
It works, in other words, like the stack of dinner plates you keep in
your kitchen cabinet.  As you wash plates, you pile them one by one on
top of the stack, and when you want a plate, you take one from the top
of the stack.  The stack of plates in your cabinet is therefore also a
last in, first out structure, like the computer's stack.

When one C function calls a second function, the computer leaves itself
an address at the top of the stack of where it should return when it has
finished executing the second function.  If the second function calls a
third function, the computer will push another address onto the stack.
When the third function has finished executing, the computer pops the
top address off the stack, which tells it where in the second function
it should return.  When the second function has finished, the computer
again pops the top address off the stack --- which tells it where in the
first function it should return.  Perhaps the first function then calls
another function, and the whole process starts again.

What happens when @code{black_hole} calls itself?  The computer makes a
note of the address it must return to and pushes that address onto the
top of the stack.  It begins executing @code{black_hole} again, and
encounters another call to @code{black_hole}.  The computer pushes
another address onto the top of the stack, and begins executing
@code{black_hole} again.  Since the program has no chance of popping
addresses off the stack, as the process continues, the stack gets filled
up with addresses.  Eventually, the stack fills up and the program
crashes.


@node Controlled recursion, Controlled recursion with data structures, The stack, Recursion
@section Controlled recursion

@cindex Recursion, controlled

If that were all there is to recursion, no one would ever use it.
However, recursion can be limited so it does not go out of control.
Controlled recursion can be a powerful programming technique.

When we discussed data structures, we remarked that programs and data
structures should aim to model the situation they deal with closely.
Some structures, both in real life and in computer memory, are made up
of many levels of detail, and the details are roughly the same at every
level.  For example, a genealogical tree starts with an individual with
two parents, each of whom has two parents, each of whom@dots{}  These sorts
of structure are called @dfn{self-similar}.

Since recursion employs functions that contain calls to themselves, in
effect creating multiple self-similar levels of detail, controlled
recursion is useful for dealing with self-similar problems.

Recursive functions can be controlled by making sure that there is a
safe way to exit them at some point in the chain of function calls.  The
number of times recursion takes place is limited by making a decision
about whether the function calls itself or not.  Simply put, somewhere
along the chain of function calls, the function makes the decision not
to call itself again, in a process nicknamed @dfn{bottoming out}.  At
that point, the program begins popping addresses off the stack and
returning to the previous functions.  Eventually, the very first
function in the chain terminates, and the program ends successfully.

A standard example of controlled recursion is the factorial function.
This is a mathematical function which is important in statistics.  The
factorial function is defined to be the product (multiplication) of all
integers from 1 to the parameter of the function.  (The factorial of 0 is 1.)

Here are some examples of the factorial function.  These are not executable
C code examples, but pseudocode:

@smallexample
@group
factorial(3) == 1 * 2 * 3         ==   6
factorial(4) == 1 * 2 * 3 * 4     ==  24
factorial(3) == 1 * 2 * 3 * 4 * 5 == 120
@end group
@end smallexample

Formally, the factorial function is defined by two equations.
(Again, these are in pseudocode).

@smallexample
@group
factorial(n) = n * factorial(n-1)
factorial(0) = 1
@end group
@end smallexample

The first of these statements is recursive, because it defines
the value of @code{factorial(n)} in terms of @code{factorial(n-1)}.
The second statement allows the function to ``bottom out''.

Here is a short code example that incorporates a @code{factorial} function.

@smallexample
@group
#include <stdio.h>

int factorial (int n)
@{
  if (n == 0)
    return 1;
  else
    return (n * factorial (n-1));
@}

/* To shorten example, not using argp */
int main ()
@{
  printf ("%d\n", factorial(3));
  return 0;
@}
@end group
@end smallexample

Let's follow the control flow in this program to see how controlled
recursion can work.  The @code{main} function prints the value of
@code{factorial(3)}.  First, the @code{factorial} function is called
with the parameter 3.  The function tests whether its parameter @code{n}
is zero.  It is not, so it takes the @code{else} branch if the @code{if}
statement, which instructs it to return the value of
@code{factorial(3-1)}.  It therefore calls itself recursively with a
parameter of 2.

The new call checks whether its parameter is zero.  It isn't (it's 2),
so it takes the @code{else} branch again, and tries to calculate @code{2
* factorial (1)}.  In order to do so, it calls itself recursively with a
value of 2-1, or 1.  The new call checks whether its parameter is zero.
It is actually 1, so it takes the @code{else} branch again and attempts
to calculate @code{1 * factorial (0)}. In order to do so, it calls
itself again with the parameter 0.

Again, the function checks whether its parameter is zero.  This time it
is, so the function bottoms out.  It takes the first branch of the
@code{if} statement and returns a value of 1.  Now the previous function
call can also return a value, and so on, until the very first call to
@code{factorial} terminates, and the function returns a value of 6.

To sum up, the expression @code{factorial(3)} goes
through the following steps before finally being evaluated:

@smallexample
factorial (3) == 3 * factorial(2)
              == 3 * (2 * factorial(1))
              == 3 * (2 * (1 * factorial(0)))
              == 3 * (2 * (1 * 1)))
              == 6
@end smallexample
@noindent

@strong{Note:} Make sure that the test for whether to bottom out your
recursive function does not depend on a global variable.  

Suppose you have a global variable called @code{countdown}, which your
recursive function decrements by 1 every time it is called.  When
@code{countdown} equals zero, your recursive function bottoms out.
However, since other functions than the recursive function have access
to global variables, it is possible that another function might
independently change @code{countdown} in such a way that your recursive
function would never bottom out --- perhaps by continually incrementing it,
or perhaps even by setting it to a negative number.


@node Controlled recursion with data structures, Recursion summary, Controlled recursion, Recursion
@section Controlled recursion with data structures

@cindex Recursive data structures
@cindex Data structures, recursive
@cindex Data structures with controlled recursion
@cindex Controlled recursion with data structures
@cindex Recursion, controlled, with data structures

Self-similar data structures are sometimes called @dfn{recursive data
structures}.  The simplest recursive data structure is the linked list.
At every node in a linked list, there is data of a certain type and a
link to the next node.  The next simplest recursive data structure is
the binary tree, which splits into two branches at every node.
Recursive functions be useful for manipulating such recursive data
structures.

The following code example makes use of recursion to print the value
contained in the last node in a linked list.

@smallexample
@group
#include <stdio.h>

struct list_node
@{
  int data;
  struct list_node *next;
@};
@end group

@group
struct list_node *last_node (struct list_node *node)
@{
  if (node->next == NULL)
    return node;
  else
    return last_node (node->next);
@}
@end group

@group
/* To shorten example, not using argp */
int main ()
@{
  struct list_node *root;
  struct list_node *current;
  struct list_node *old;
  struct list_node *last;
@end group

@group
  /* Initialize list. */
  root = (struct list_node *) malloc (sizeof (struct list_node));
  root->data = 1;
  old = root;
@end group

@group
  current = (struct list_node *) malloc (sizeof (struct list_node));
  current->data = 2;
  old->next = current;
  old = current;
@end group

@group
  current = (struct list_node *) malloc (sizeof (struct list_node));
  current->data = 3;
  old->next = current;
  current->next = NULL;

  /* Print data in last node. */
  last = last_node (root);
  printf ("Data in last node is %d.\n", last->data);
  
  return 0;
@}
@end group
@end smallexample

@noindent
This example program prints out the following line:

@smallexample
Data in last node is 3.
@end smallexample

The @code{last_node} function, when passed a pointer to a node (such as
the root), follows the linked list to its end from that point, and
returns a pointer to that node.  It does so through recursion.  When it
is passed a pointer to a node, it checks whether that node's @code{next}
link is a null pointer.  If the pointer is null, @code{last_node} has
found the last node, and bottoms out, returning a pointer to the current
node; otherwise, it calls itself with a pointer to the next node as a
parameter.

@node Recursion summary, Questions 21, Controlled recursion with data structures, Recursion
@section Recursion summary

Recursion can be a powerful programming technique, especially when 
dealing with mathematical functions such as factorialisation that lend
themselves naturally to recursion, or with self-similar data structures.
There is a major disadvantage to recursion, however, and that is the amount
of memory required to make it work.  Do not forget that the program stack grows
each time a function call is made.  If a function calls itself too many times,
your program will run out of memory and crash.  Recursive programming can also
be difficult; runaway recursion is a common error.  Therefore, be judicious
in your use of recursion.


@node Questions 21,  , Recursion summary, Recursion
@section Questions 21

@enumerate
@item
What is a recursive function?

@item
What is a program stack, and what is it for?

@item
State the major disadvantage of recursion.

@end enumerate





@c CHAPTER 22
@node Style, Debugging, Recursion, Top
@chapter Style

@cindex Style
@cindex Style guidelines

C has no rules about when to start new lines, where to place whitespace,
and so on.  Users are free to choose a style which best suits them, but
unless a strict style is adopted, sloppy programs tend to result.

In older compilers, memory restrictions sometimes necessitated bizarre,
cryptic styles in the interest of efficiency.  However, contemporary
compilers such as GCC have no such restrictions, and have optimizers
that can produce faster code than most programmers could write
themselves by hand, so there are no excuses not to write programs as
clearly as possible.

No simple set of rules will ever provide a complete methodology for
writing good programs.  In the end, experience and good judgment are
the factors which determine whether you will write good programs.
Nevertheless, a few guidelines to good style can be stated.

Many of the guidelines in this chapter are the distilled wisdom of
countless C programmers over the decades that C has existed, and some
come directly from the @emph{GNU Coding Standards}.  That document
contains more good advice than can be crammed into this short chapter,
so if you plan to write programs for the Free Software Foundation, you
are urged to consult @ref{Top, , Table of Contents, standards, GNU
Coding Standards}.

@menu
* Formatting code::             
* Comments and style::          
* Variable and function names::  
* Declarations and initialization::  
* Global variables and style::  
* Hidden operators and style::  
* Final words on style::        
* Questions 22::                
@end menu



@node Formatting code, Comments and style, Style, Style
@section Formatting code

@cindex Formatting code, style guidelines
@cindex Style guidelines for formatting code

Place the open curly bracket that starts the body of a C function in
the first column of your source file, and avoid placing any other open
brackets or open parentheses in that column.  This will help many
code-processing utilities find the beginnings of your functions.
Similarly, you should also place the name of your functions within
your function definitions in the first column.  Thus, your functions
should resemble the following example:

@smallexample
@group
static char *
concat (char *s1, char *s2)
@{
  @dots{}
@}
@end group
@end smallexample

When you split an expression into multiple lines, split it before an
operator, not after one.  Here is the right way:

@smallexample
@group
if (foo_this_is_long && bar > win (x, y, z)
    && remaining_condition)
@end group
@end smallexample

Don't declare multiple variables in one declaration that spans lines.
Start a new declaration on each line instead.  For example, instead of
this:

@smallexample
@group
int    foo,
       bar;
@end group
@end smallexample

@noindent
write either this:

@smallexample
@group
int foo, bar;
@end group
@end smallexample

@noindent
or this:

@smallexample
@group
int foo;
int bar;
@end group
@end smallexample



@node Comments and style, Variable and function names, Formatting code, Style
@section Comments and style

@cindex Comments, style guidelines for
@cindex Style guidelines for comments

Comments are crucial for other programmers trying to understand your code.
Every program should start with a comment saying briefly what it is for.
Example: @samp{fmt - filter for simple filling of text}.  Similarly, 
you should put a comment on each function saying what the function does,
what sort of arguments it takes, what the possible values of arguments
mean, and what they are used for.

Please write all comments in a GNU program in English, because English
is the one language that nearly all programmers in all countries can
read.



@node Variable and function names, Declarations and initialization, Comments and style, Style
@section Variable and function names

@cindex Variable names, style guidelines for
@cindex Function names, style guidelines for
@cindex Style guidelines for variable names
@cindex Style guidelines for function names

The names of variables and functions in a program serve as comments of
a sort, so try to give your variables descriptive names (for example,
@code{num_of_books}, @code{cost_per_entry}, or
@code{distance_from_center}).  Names should be in English, like other
comments.

Use underscores rather than internal capitalization in names, so that
Emacs word commands can be useful within them --- thus
@code{distance_from_center} rather than @code{distanceFromCenter} or
@code{DistanceFromCenter}.  In fact, upper-case letters should be
reserved for macros and @code{enum} constants.  Macros should be
completely in upper case, for example @code{STANDARD_SIZE}.

It used to be common practice to use the same local variables
(with names like @code{temp}) over and over for different purposes
within one function.  Instead, it is better to declare a separate local
variable for each distinct purpose, and give it a meaningful name.
This not only makes programs easier to understand, it also facilitates
optimization by good compilers.



@node Declarations and initialization, Global variables and style, Variable and function names, Style
@section Declarations and initialization

@cindex Declarations, style guidelines for
@cindex Initialization, style guidelines for
@cindex Style guidelines for declarations
@cindex Style guidelines for initialization

You should explicitly declare the types of all objects.  For example,
explicitly declare all arguments to functions, and declare all
function that return integers to return type @code{int}, even though
the ANSI Standard permits omitting the @code{int}.

If there are only a few declarations, then initializing variables
where you declare them can be tidy, but if there are many variables to
declare, then it is usually better to declare and initialize
separately, for the sake of clarity.  In a long function, it is often
good to initialize the variable near where you are using it, so that
someone reading the code does not have to hunt around in the function
to discover its initial value.  (@xref{Initialization}.)




@node Global variables and style, Hidden operators and style, Declarations and initialization, Style
@section Global variables and style

@cindex Global variables, style guidelines for
@cindex Style guidelines for global variables

Global variables have caused almost as much controversy as the
@code{goto} statement.  Some programmers say you should never use
them.  Other programmers use them on a regular basis.  In fact, while
global variables should not be overused, they can simplify your code
considerably.  The following guidelines may help you decide where to
use globals.

@itemize @bullet

@item
Always think of using local variables first.  Global variables can
puncture the @dfn{encapsulization} of your functions, that is, the
logical isolation of your functions from the rest of your code.  It is
difficult to see what variables are being passed to a function unless
they are all passed as parameters, so it is easier to debug a program
when encapsulization is maintained.

@item
Local variables may be impractical, however, if they mean passing the
same dozen parameters to multiple functions; in such cases, global
variables will often streamline your code.

@item
Data structures that are important to the whole program should be
defined globally.  In ``real programs'' such as GNU Emacs, there are
far more global variables than there are local variables visible in
any one function.

@end itemize

Finally, don't use local variables or parameters that have the same
names as global identifiers.  This can make debugging very difficult.




@node Hidden operators and style, Final words on style, Global variables and style, Style
@section Hidden operators and style

@cindex Hidden operators, style guidelines for
@cindex Style guidelines for hidden operators

Hiding operators away inside other statements can certainly make
programs @emph{look} elegant and compact, but it can make programs
harder to understand.  Never forget that besides being a set of
instructions to the computer, programming is a form of communication
to other programmers.  Be kind to the reader of your program.  It
could be you in months or years to come.

Statements such as:

@smallexample
@group
if ((my_int = (int)my_char++) <= --my_int2)
  @{
    @dots{}
  @}
@end group
@end smallexample

@noindent
are not good style, and are no more efficient than the more
longwinded:

@smallexample
@group
my_int = (int) my_char;
my_char++;
my_int2--;

if (my_int <= my_int2)
  @{
    @dots{}
  @}
@end group
@end smallexample



@node Final words on style, Questions 22, Hidden operators and style, Style
@section Final words on style

It is easy to support pre-ANSI-Standard compilers in most programs,
so if you know how to do that and a program you are maintaining has such
support, you should try to keep it working.

Whatever style you use, use it consistently.  A mixture of styles
within a single program tends to look ugly and be hard to read and
maintain.  If you are contributing changes to an existing program, it
is best to follow the style of that program.


@node Questions 22,  , Final words on style, Style
@section Questions 22

@enumerate

@item
Where should the name of a program and the opening bracket of
a function definition begin?

@item
In what human language should comments be written for the 
GNU Project?  Why?

@item
Which is better as the name of a variable: @code{plotArea},
@code{PlotArea}, or @code{plot_area}?  Why?

@item
Why is it important to initialize a variable near where it is
used in a long function?

@item
Give an example of a case where using local variables is impractical.

@end enumerate





@c CHAPTER 23
@node Debugging, Example programs, Style, Top
@chapter Debugging

@cindex Debugging

True artificial intelligence has not yet been achieved.  C compilers
are not intelligent, but unconscious: mechanical in the derogatory
sense of the word.  Therefore, debugging your programs can be a
difficult process.  A single typographical error can cause a compiler
to completely misunderstand your code and generate a misleading error
message.  Sometimes a long string of compiler error messages are
generated because of a single error in your code.  To minimize the
time you spend debugging, it is useful to become familiar with the
most common compiler messages and their probable causes.

The first section in this chapter lists some of these common
compile-time errors and what to do about them.  The next two sections
discuss run-time errors in general, and mathematical errors in
particular.  The final section introduces GDB, the GNU Debugger, and
explains some simple steps you can take to debug your programs with
it.

@menu
* Compile-time errors::         
* ...undeclared (first use in this function)::  
* Run-time errors::             
* Mathematical errors::         
* Introduction to GDB::         
* Questions 23::                
@end menu

@node Compile-time errors, ...undeclared (first use in this function), Debugging, Debugging
@section Compile-time errors

@cindex Compile-time errors
@cindex Errors, compile time

In this section, we will examine a variety of compile-time errors and
what you can do about them.  The aim is not to be a comprehensive
guide to everything that can go wrong with your program and all the
corresponding error messages, but rather to give you a taste of the
kinds of errors you are likely to make, and to build your confidence
by showing that even fairly scary-looking error messages often have a
simple cause.

@menu
* parse error at...::           
* undefined reference to...::   
* unterminated string or character constant::  
@end menu

@node parse error at..., undefined reference to..., Compile-time errors, Compile-time errors
@subsection parse error at@dots{}, parse error before@dots{}

@cindex Parse error

This is a general-purpose syntax error.  It is frequently caused by a
missing semicolon.  For example, the following code:

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main()
@{
  printf ("Hello, world!\n")
  return 0;
@}
@end group
@end smallexample

@noindent
generates the following error:

@smallexample
@group
semicolon.c: In function `main':
semicolon.c:6: parse error before `return'
@end group
@end smallexample

Adding a semicolon (@samp{;}) at the end of the line 
@code{printf ("Hello, world!")} will get rid of this error.

Notice that the error refers to line 6, but the error is actually on
the previous line.  This is quite common.  Since C compilers are
lenient about where you place whitespace, the compiler treats line 5
and line 6 as a single line that reads as follows:

@smallexample
@group
printf ("Hello, world!\n") return 0;
@end group
@end smallexample

Of course this code makes no sense, and that is why the compiler
complains.

Often a missing curly bracket will cause one of these errors.  For
example, the following code:

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main()
@{
  if (1==1)
    @{
      printf ("Hello, world!\n");


  return 0;
@}
@end group
@end smallexample

@noindent
generates the following error:

@smallexample
@group
brackets.c: In function `main':
brackets.c:11: parse error at end of input
@end group
@end smallexample

Because there is no closing curly bracket for the @code{if} statement,
the compiler thinks the curly bracket that terminates the @code{main}
function actually terminates the @code{if} statement.  When it does
not find a curly bracket on line 11 of the program to terminate the
@code{main} function, it complains.  One way to avoid this problem is
to type both members of a matching pair of brackets before you fill
them in.




@node undefined reference to..., unterminated string or character constant, parse error at..., Compile-time errors
@subsection undefined reference to@dots{}

@cindex Undefined reference error

This error is often generated because you have typed the name of
a function or variable incorrectly.  For example, the following code:

@smallexample
@group
#include <stdio.h>

void print_hello()
@{
  printf ("Hello!\n");
@}
@end group

@group

/* To shorten example, not using argp */
int main()
@{
  Print_hello();
  return 0;
@}
@end group
@end smallexample

@noindent
generates the following rather forbidding error:

@smallexample
@group
/tmp/cc9KXhmV.o: In function `main':
/tmp/cc9KXhmV.o(.text+0x1f): undefined reference to `Print_hello'
collect2: ld returned 1 exit status
@end group
@end smallexample

The answer, however, is very simple.  C is case-sensitive.  The
@code{main} function calls the function @code{Print_hello} (with a
capital @samp{P}), but the correct name of the function is
@code{print_hello} (with a lower-case @samp{p}).  The linker
could not find a function with the name @code{Print_hello}.

@node unterminated string or character constant,  , undefined reference to..., Compile-time errors
@subsection unterminated string or character constant

This error is often generated by code like the following:

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main()
@{
  printf("hello!\n);
  printf("Hello again!\n");
  return 0;
@}
@end group
@end smallexample

@noindent
The actual error message received was:

@smallexample
@group
missquotes.c:6: unterminated string or character constant
missquotes.c:5: possible real start of unterminated constant
@end group
@end smallexample

The compiler never found a close quote (@samp{"}) for the string
@samp{Hello!\n}.  It read all the text up from the quote in the line
@code{printf("Hello!\n);} to the @emph{first} quote in the line
@code{printf("Hello again!\n");} as a single string.  Notice that GCC
helpfully suggests that it is line 5 that actually contains the
unterminated string.  GCC is pretty smart as C compilers go.

@node ...undeclared (first use in this function), Run-time errors, Compile-time errors, Debugging
@section @dots{}undeclared (first use in this function)

This is similar 
to the @samp{undefined reference to@dots{}} error, but instead of 
referring to an undefined function, you are referring to an undefined
variable.

Sometimes this is a scope problem.  You might get this error if you
tried to refer to another function's local variable.  For example:

@smallexample
@group
#include <stdio.h>

void set_value()
@{
  int my_int = 5;
@}
@end group

@group

/* To shorten example, not using argp */
int main()
@{
  my_int = 23;
  return 0;
@}
@end group
@end smallexample

@noindent
The variable @code{my_int} is local to the function @code{set_value},
so referring to it from within @code{main} results in the following
error:

@smallexample
@group
undec.c: In function `main':
undec.c:10: `my_int' undeclared (first use in this function)
undec.c:10: (Each undeclared identifier is reported only once
undec.c:10: for each function it appears in.)
@end group
@end smallexample



@menu
* different type arg::          
* too few parameters...::       
@end menu

@node different type arg, too few parameters..., ...undeclared (first use in this function), ...undeclared (first use in this function)
@subsection different type arg

@cindex Different type argument error

You might get this warning if you mismatch a parameter to @code{printf}
and a conversion specifier.  For example, the following code:

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main()
@{
  int my_int = 5;
  printf ("%f", my_int);
  return 0;
@}
@end group
@end smallexample

@noindent
produces the folliwing warning:

@smallexample
@group
wrongtype2.c: In function `main':
wrongtype2.c:6: warning: double format, different type arg (arg 2)
@end group
@end smallexample

The @samp{%f} conversion specifier requires a floating-point argument,
while @code{my_int} is an integer, so GCC complains.

@strong{Note:} GCC is quite lenient about type mismatches and will
usually coerce one type to another dynamically without complaining,
for example when assigning a floating-point number to an integer.
This extends to mismatched parameters and conversion specifiers ---
although you may receive odd results from @code{printf} and so on, the
causes of which may not be obvious.  Therefore, in order to generate
this warning, the @option{-Wall} option of GCC was used.  This option
causes GCC to be especially sensitive to errors, and to complain about
problems it usually ignores.  You will often find the @option{-Wall}
option to be useful in finding tricky problems.  Here is the actual
command line used to compile this program:

@smallexample
@group
gcc -Wall -o wrong wrongtype2.c
@end group
@end smallexample



@node too few parameters...,  , different type arg, ...undeclared (first use in this function)
@subsection too few parameters@dots{}, too many parameters@dots{}

@cindex Too few parameters error

Consider the following program:

@smallexample
@group
#include <stdio.h>

void tweedledee (int a, int b, int c)
@{
@}

void tweedledum (int a, int b)
@{
@}
@end group

@group

/* To shorten example, not using argp */
int main()
@{

  tweedledee (1, 2);
  tweedledum (1, 2, 3);

  return 0;
@}
@end group
@end smallexample

The @code{tweedledee} function takes three parameters, but @code{main}
passes it two, whereas the @code{tweedledum} function takes two
parameters, but @code{main} passes it three.  The result is a pair of
straightforward error messages:

@smallexample
@group
params.c: In function `main':
params.c:14: too few arguments to function `tweedledee'
params.c:15: too many arguments to function `tweedledum'
@end group
@end smallexample

This is one reason for the existence of function prototypes.  Before
the ANSI Standard, compilers did not complain about this kind of
error.  If you were working with a library of functions with which you
were not familiar, and you passed one the wrong number of parameters,
the error was sometimes difficult to track.  Contemporary C compilers
such as GCC that follow the standard make finding parameter mismatch
errors simple.


@node Run-time errors, Mathematical errors, ...undeclared (first use in this function), Debugging
@section Run-time errors

This section examines errors that cannot be caught by the compiler and
are exhibited only when the program is run.

@menu
* Confusion of = and ==::       
* Confusing foo++ and ++foo::   
* Unwarranted assumptions about storage::  
* Array out of bounds::         
* Uncoordinated output::        
* Global variables and recursion::  
@end menu


@node Confusion of = and ==, Confusing foo++ and ++foo, Run-time errors, Run-time errors
@subsection Confusion of @code{=} and @code{==}

@findex = @r{confused with} ==
@findex == @r{confused with} =

Consider the following program:

@smallexample
@group
#include <stdio.h>

/* To shorten example, not using argp */
int main()
@{
  int my_int = 0;

  if (my_int = 1)
    @{
      printf ("Hello!\n");
    @}

  return 0;
@}
@end group
@end smallexample

What will this program do?  If you guessed that it will print
@samp{Hello!}, you are correct.  The assignment operator (@code{=})
was used by mistake instead of the equality operator (@code{==}).
What is being tested in the above @code{if} statement is not whether
@code{my_int} has a value of 1 (which would be written @code{if my_int
== 1}), but instead what the value is of the assignment statement
@code{my_int = 1}.  Since the value of an assignment statement is
always the result of the assignment, and @code{my_int} is here being
assigned a value of 1, the result is 1, which C considers to be
equivalent to @code{TRUE}.  Thus, the program prints out its greeting.

Even the best C programmers make this mistake from time to time, and
tracking down an error like this can be maddening.  Using the
@option{-Wall} option of GCC can help at least a little by giving you
a warning like the following:

@smallexample
@group
equals.c: In function `main':
equals.c:7: warning: suggest parentheses around assignment used as truth value
@end group
@end smallexample



@node Confusing foo++ and ++foo, Unwarranted assumptions about storage, Confusion of = and ==, Run-time errors
@subsection Confusing @code{foo++} and @code{++foo}

@cindex Postfix and prefix @code{++}, confused

In many cases, the forms @code{foo++} and @code{++foo} are identical.
However, if they are hidden inside another statement, there can be a subtle
difference.  For example:

@smallexample
my_array [++my_index] = 0;
@end smallexample

The code @code{++my_index} cause @code{my_index} to be incremented by 1
@emph{before} the assignment takes place, whereas @code{my_index++}
would have cause @code{my_index} to be incremented @emph{after} the assignment
takes place.  Sometimes you'll want one and sometimes the other.
If you find that your program is miscalculating by a difference of 1
(this is called an @dfn{off-by-one bug} and is quite common),
a prefix or postfix @samp{++} could be the cause.  The same holds for 
other prefix and postfix operators, such as @samp{--}.



@node Unwarranted assumptions about storage, Array out of bounds, Confusing foo++ and ++foo, Run-time errors
@subsection Unwarranted assumptions about storage

@cindex Storage, false assumptions about

Do not assume that the size of a structure is the sum of the sizes of
its parts.  The two may differ for various reasons; for example, the
operating system may be aligning variables with specific addresses
within the data structure.  Furthermore, the elements of an array may
not even be next to one another in memory.  

This kind of code is always safe:

@smallexample
@group
int my_array[3];

my_array[0] = 0;
my_array[1] = 0;
my_array[2] = 0;
@end group
@end smallexample

This kind of code is not:

@smallexample
@group
int my_array[3];

*my_array = 0;
*(my_array + (1 * sizeof(int))) = 0;
*(my_array + (2 * sizeof(int))) = 0;
@end group
@end smallexample

While it is true that the variable @code{my_array} used without its
square brackets is a pointer to the first element of the array, you
must not assume that you can simply calculate a pointer to the third
element with code like the following:

@smallexample
@group
my_array + 2 * sizeof(int);
@end group
@end smallexample

Do something like this instead:

@smallexample
@group
&(my_array[2]);
@end group
@end smallexample



@node Array out of bounds, Uncoordinated output, Unwarranted assumptions about storage, Run-time errors
@subsection Array out of bounds

@cindex Arrays, out of bounds
@cindex Array out of bounds errors

When you get or set the value of an element of an array, GCC does not
check whether you are working within the bound of the array.  In the
worst case, this can lead to your program crashing (but probably
nothing worse happening on a GNU system).  @xref{Array bounds},
for more information on this error.  @xref{Introduction to GDB},
for information on how you can check whether you are violating array
bounds, using the GNU Debugger.


@node Uncoordinated output, Global variables and recursion, Array out of bounds, Run-time errors
@subsection Uncoordinated output

@cindex Uncoordinated output
@cindex Output, uncoordinated
@cindex Flushing buffers
@cindex Buffers, flushing
@findex fflush @r{function}

You may occasionally experience strange effects when writing output
to the screen, such as no output at all until the input is complete,
or spontaneous bursts of output at seemingly random intervals.  This sort
of problem usually has to do with the way the output is buffered.
The solution is usually to write a newline character (@samp{\n}) to the 
output when you are ready to display it, or to use a function like
@code{fflush} to flush the buffer.  (@xref{Stream buffering}, for more
information.)



@node Global variables and recursion,  , Uncoordinated output, Run-time errors
@subsection Global variables and recursion

@cindex Global variables and recursion
@cindex Recursion and global variables
@cindex Variables, global, and recursion

Global variables and recursion usually do not mix.  Make sure that the
test for whether to ``bottom out'' your recursive function does not
depend on a global variable.  @xref{Controlled recursion}, for
more information on why this is a bad thing.



@node Mathematical errors, Introduction to GDB, Run-time errors, Debugging
@section Mathematical errors

@cindex Mathematical errors
@cindex Errors, methematical

Mathematical errors are a special kind of run-time error.  They may
not necessarily cause your program to crash, but they are likely to
produce all sorts of strange results if you are doing some complex
calculations in your program.  Consider the following line of code:

@smallexample
@group
root = sqrt (-1.0);
@end group
@end smallexample

Readers with a smattering of mathematics will recognise that this code
cannot give a sensible answer.  The square root of -1 is a complex
number called @math{i}.  The number @math{i} is a so-called imaginary
number, and cannot be represented by a floating-point value, which is
what the @code{sqrt} function returns.

What happens in such a case?  Two things:

@enumerate

@vindex NAN @r{macro}
@vindex INFINITY @r{macro}
@item
The value returned is a special floating-point macro such as
@code{NAN} (which means ``not a number'') or @code{INFINITY}.

@cindex Floating-point exceptions
@cindex Exceptions, floating-point
@item
More importantly from a debugging standpoint, a floating-point
@dfn{exception} occurs.  An exception is an error condition, and when
a floating-point exception is @dfn{raised}, as the jargon goes, an
error flag is set in the operating system, signifying what kind of
exception it was (in other words, what kind of error caused the
exception to be raised).

@end enumerate

There are several kinds of floating-point exception:

@itemize

@findex FE_INVALID @r{floating-point exception}
@item @code{FE_INVALID}: The ``Invalid Operation'' exception.
Raised if the operands are invalid for the given operation, for
example, if you are trying to take the square root of a negative
number, as above.

@findex FE_DIVBYZERO @r{floating-point exception}
@item @code{FE_DIVBYZERO}: The ``Division by Zero'' exception.
Raised when a finite, nonzero number is divided by zero.

@findex FE_OVERFLOW @r{floating-point exception}
@item @code{FE_OVERFLOW}: The ``Overflow'' exception.  Raised
when the result cannot be expressed as a finite value, for example
when a finite, nonzero number is divided by zero.  Whenever this exception
is raised, the @code{FE_INEXACT} exception is also raised.

@findex FE_UNDERFLOW @r{floating-point exception}
@item @code{FE_UNDERFLOW}: The ``Underflow'' exception.  Raised
when an intermediate result is too small to be calculated accurately,
or when an operation's rounded result is too small to be @dfn{normalized}.
Normalisation, roughly speaking, is the process of converting a number to
scientific notation, such as converting 235 to 2.35e2, 
where the @dfn{mantissa}, or number to the left of the @samp{e}, must not be zero.
@xref{Floating point variables}, for more information on scientific notation.)

@findex FE_INEXACT @r{floating-point exception}
@item @code{FE_INEXACT}: The ``Inexact'' exception.
Raised if a rounded result is not exact, for example when calculating
an irrational number such as the square root of 2.

@end itemize

@findex fetestexcept @r{function}
@findex FE_ALL_EXCEPT @r{function}
You can test for these exceptions with the @code{fetestexcept}
function, which takes one parameter, a bitwise OR'd list of the
exception flags from the list above for which you are testing, and
returns a nonzero value containing a bitwise OR'd list of the flags
you passed it for the exceptions that actually occurred.  You can also
clear selected flags with the @code{feclearexcept} function, which
accepts a bitwise-OR'd list of exception flags to clear, and returns
zero if it was successful.  (You can pass either of these function the
macro @code{FE_ALL_EXCEPT}, which contains all of the floating-point
exception flags OR'd together.)

In case this explanation is unclear, let's look at a practical example.


@node Introduction to GDB, Questions 23, Mathematical errors, Debugging
@section Introduction to GDB

@cindex GDB, introduction to

Blah blah blah.


@node Questions 23,  , Introduction to GDB, Debugging
@section Questions 23

Spot the errors in the following:

Blah blah blah.





@c CHAPTER 24
@node Example programs, A note from the original author, Debugging, Top
@chapter Example programs

@cindex Example program, substantial
@cindex Disk input
@cindex Disk output
@cindex Input, disk
@cindex Output, disk
@cindex GNU long options
@cindex Long options, GNU
@cindex Linked lists
@cindex Lists, linked

The aim of this section is to provide a substantial example of C
programming, using input from and output to disk, GNU-style long
options, and the linked list data structure (including insertion,
deletion, and sorting of nodes).

@c RWHE
@c Example needs many more comments!

@smallexample
#include <stdio.h>
#include <string.h>
#include <argp.h>

#define NAME_LEN 100
#define ADDR_LEN 500

const char *argp_program_version =
"bigex 1.0";

const char *argp_program_bug_address =
"<bug-gnu-utilsgnu.org>";


/* This structure is used by main to communicate with parse_opt. */
struct arguments
@{
  char *args[1];            /* No arguments to this function */
  int verbose;              /* The -v flag */
  char *infile;             /* Argument for -i */
  char *outfile;            /* Argument for -o */
@};


struct personal_data
@{
  char name[NAME_LEN];
  char address[ADDR_LEN];
  struct personal_data *next;
@};


/*
  OPTIONS.  Field 1 in ARGP.
  Order of fields: @{NAME, KEY, ARG, FLAGS, DOC@}.
*/
static struct argp_option options[] =
  @{
    @{"verbose", 'v', 0, 0, "Produce verbose output"@},

    @{"input",   'i', "INFILE",  0,
     "Read addresses from INFILE"@},

    @{"output",  'o', "OUTFILE", 0,
     "Output to OUTFILE instead of to standard output"@},

    @{0@}
  @};


/*
  PARSER. Field 2 in ARGP.
  Order of parameters: KEY, ARG, STATE.
*/
static error_t
parse_opt (int key, char *arg, struct argp_state *state)
@{
  struct arguments *arguments = state->input;

  switch (key)
    @{
    case 'v':
      arguments->verbose = 1;
      break;
    case 'i':
      arguments->infile = arg;
      break;
    case 'o':
      arguments->outfile = arg;
      break;
    case ARGP_KEY_ARG:
      if (state->arg_num >= 1)
	@{
	  argp_usage(state);
	@}
      arguments->args[state->arg_num] = arg;
      break;
    case ARGP_KEY_END:
      if (state->arg_num < 1)
	@{
	  argp_usage (state);
	@}
      break;
    default:
      return ARGP_ERR_UNKNOWN;
    @}
  return 0;
@}


/*
  ARGS_DOC. Field 3 in ARGP.
  A description of the non-option command-line arguments
  that we accept.
*/
static char args_doc[] = "ARG";


/*
  DOC.  Field 4 in ARGP.
  Program documentation.
*/
static char doc[] =
"bigex -- Add ARG new names to an address book file.\vThe largest code example in the GNU C Tutorial.";


/*
  The ARGP structure itself.
*/
static struct argp argp = @{options, parse_opt, args_doc, doc@};


struct personal_data *
new_empty_node()
@{
  struct personal_data *new_node;

  new_node =  (struct personal_data*) 
    malloc (sizeof (struct personal_data));

  strcpy (new_node->name, "");
  strcpy (new_node->address, "");
  new_node->next = NULL;

  return new_node;
@}


struct personal_data *
create_node()
@{
  int bytes_read;
  int nbytes;

  struct personal_data *current_node;
  char *name;
  char *address;

  current_node = new_empty_node();

  puts ("Name?");
  nbytes = NAME_LEN;
  name = (char *) malloc (nbytes + 1);
  bytes_read = getline (&name, &nbytes, stdin);
  if (bytes_read == -1)
    @{
      puts ("ERROR!");
    @}
  else
    @{
      strncpy (current_node->name, name, NAME_LEN);
      free (name);
    @}

  puts ("Address?");
  nbytes = ADDR_LEN;
  address = (char *) malloc (nbytes + 1);
  bytes_read = getline (&address, &nbytes, stdin);
  if (bytes_read == -1)
    @{
      puts ("ERROR!");
    @}
  else
    @{
      strncpy (current_node->address, address, ADDR_LEN);
      free (address);
    @}

  printf("\n");
  return current_node;
@}



struct personal_data *
find_end_node (struct personal_data *current_node)
@{
  if (current_node->next == NULL)
    @{
      return current_node;
    @}
  else
    @{
      return find_end_node (current_node->next);
    @}
@}


int 
list_length (struct personal_data *root)
@{
  struct personal_data *current_node;
  int count = 0;

  current_node = root;

  while (current_node->next != NULL)
    @{
      current_node = current_node->next;
      count++;
    @}
  return count;
@}


struct personal_data *
find_node (struct personal_data *root, 
	   int node_wanted)
@{
  struct personal_data *current_node;
  int index = 0;
  
  current_node = root;
      
  while ((index < node_wanted) && (current_node->next != NULL))
    @{
      current_node = current_node->next;
      index++;
    @}
  return current_node;
@}   



delete_node (struct personal_data *root,
	     int location)
@{
  struct personal_data *previous_node;
  struct personal_data *current_node;

  previous_node = find_node (root, location - 1);
  current_node = find_node (root, location);
  previous_node->next = current_node->next;
@}



insert_node (struct personal_data *root,
	     struct personal_data *new_node,
	     int location)
@{
  struct personal_data *temp_ptr;
  struct personal_data *previous_node;
  
  previous_node = find_node (root, location - 1);
  temp_ptr = previous_node->next;

  previous_node->next = new_node;
  new_node->next = temp_ptr;
@}


swap_nodes (struct personal_data *root, int a, int b)
@{
  int temp;
  struct personal_data *node_a;
  struct personal_data *node_b;
  struct personal_data *temp_node;
  
  if (a > b)
    @{
      temp = a;
      a = b;
      b = temp;
    @}

  node_b = find_node (root, b);
  delete_node (root, b);

  node_a = find_node (root, a);
  delete_node (root, a);

  insert_node (root, node_b, a);
  insert_node (root, node_a, b);
@}


sort_list (struct personal_data *root)
@{
  int i, j, list_len, diff;

  list_len = list_length (root);
  for (i=2; i<=list_len; i++)
    @{
      j = i;
      while (strcmp ( (find_node(root, j))->name, 
		      (find_node(root, j-1))->name) < 0)
	@{
	  swap_nodes (root, j, j-1);
	  j--;
	@}
    @}
@}


print_node (struct personal_data *current_node,
	    FILE *save_stream)
@{
  fprintf (save_stream, "%s%s",
	   current_node->name,
	   current_node->address);
@}


print_list (struct personal_data *current_node, 
	    FILE *save_stream)
@{
  print_node (current_node, save_stream);

  if (current_node->next != NULL)
    @{
      print_list (current_node->next, save_stream);
    @}
@}




struct personal_data *
read_node (FILE *instream)
@{
  int bytes_read;
  int nbytes;

  struct personal_data *current_node;
  char *name;
  char *address;
  char *blankline;
  int read_err = 0;

  current_node = new_empty_node();

  nbytes = NAME_LEN;
  name = (char *) malloc (nbytes + 1);
  bytes_read = getline (&name, &nbytes, instream);
  if (bytes_read == -1)
    @{
      read_err = 1;
    @}
  else
    @{
      puts (name);
      strncpy (current_node->name, name, NAME_LEN);
      free (name);
    @}

  nbytes = ADDR_LEN;
  address = (char *) malloc (nbytes + 1);
  bytes_read = getline (&address, &nbytes, instream);
  if (bytes_read == -1)
    @{
      read_err = 1;
    @}
  else
    @{
      puts (address);
      strncpy (current_node->address, address, ADDR_LEN);
      free (address);
    @}

  if (read_err)
    @{
      return NULL;
    @}
  else
    @{
      return current_node;
    @}
@}


struct personal_data *
read_file (char *infile)
@{
  FILE *input_stream = NULL;
  struct personal_data *root;
  struct personal_data *end_node;
  struct personal_data *current_node;
  
  root = new_empty_node();
  end_node = root;

  input_stream = fopen (infile, "r");
  if (input_stream)
    @{
      while (current_node = read_node (input_stream))
	@{
	  end_node->next = current_node;
	  end_node = current_node;
	  end_node->next = NULL;
	@}
    @}
  return root;
@}



/*
  The main function.
  Notice how now the only function call needed to process
  all command-line options and arguments nicely
  is argp_parse.
*/
int 
main (int argc, char **argv)
@{
  struct arguments arguments;
  struct personal_data *root;
  struct personal_data *end_node;
  struct personal_data *current_node;
  int i, newnum;
  FILE *save_stream;

  
  /* Set argument defaults */
  arguments.infile = NULL;
  arguments.outfile = NULL;
  arguments.verbose = 0;

  /* Where the magic happens */
  argp_parse (&argp, argc, argv, 0, 0, &arguments);

  if (arguments.infile)
    @{
      root = read_file (arguments.infile);
      end_node = find_end_node (root);
    @}
  else
    @{
      root = new_empty_node();
      end_node = root;
    @}

  /* Where do we send output? */
  if (arguments.outfile)
    save_stream = fopen (arguments.outfile, "w");
  else
    save_stream = stdout;

  newnum = atoi (arguments.args[0]);

  for (i = 1; i <= newnum; i++)
    @{
      current_node = create_node();
      end_node->next = current_node;
      end_node = current_node;
      end_node->next = NULL;
    @}

  sort_list (root);
  print_list (root->next, save_stream);

  /* Close stream; skip error-checking for brevity of example */
  fclose (save_stream);

  /* If in verbose mode, print song stanza */
  if (arguments.verbose)
    @{@};

  return 0;
@}
@end smallexample

@c ============================ Appendices, etc. ====================

@node A note from the original author, Reserved words in C, Example programs, Top
@appendix A note from the original author

This book began life in 1987 as one of the early books on C
programming.  I wrote it during a summer vacation from University, in
England in 1987.  It was published by Dabs Press, a small publishing
house which specialized in books for microcomputers, particularly
Acorn's classic BBC micro. With the arrival of the Amiga, I was able
to obtain a C compiler. I had had my eye on C for some time, and I
felt at the time, that it was the best language I had seen to date for
system programming.  The publisher and I decided that C would become
the `BASIC' of the 16-bit microcomputer world, which it did.  C took
off, and the book sold very well for a number of years. As the
contract expired, the book was lost in my files, until I met Richard
Stallman and he asked me if I would give the tutorial to GNU. I agreed
to recover the original files from diskettes and partly re-work them,
to remove the emphasis from micro-computers and over to GNU. The
result of that work was the first version of the tutorial. Having
handed over the merchandise, I agreed that it would be a good thing
for others to update and improve the tutorial. My only requirement was
that I would be allowed to explain a few changes for which I would not
want to be blamed. I cannot insist that such changes will not be made,
but I can at least distance myself from them.  They are fairly picky
and even silly things, but for one reason or another, they mean a lot
to me.  The first has to do with grammar. The grammar which is written
and printed in books today is often incorrect. Many colloquialisms and
vernacular perversions of grammar are printed and believed to be
correct. I am fairly sure that no such errors are mine! The other
thing has to do with the style and formatting of C code. The placement
of curly braces is something about which I agree with only a handful
of people on the planet. Kernighan and Ritchie's original placement of
curly braces is so horrendous that I would go so far as to call it
"wrong", logically and aesthetically.  The GNU indentation, which
positions braces of the same level in straight vertical alignment, is
much better, but in my opinion it gets its indentation wrong. I would
indent 3 positions before the first brace, and keep the text within
braces aligned with the braces themselves, rather than indenting
within the braces, as GNU does. That, in my personal opinion, makes it
easier to identify text and braces belonging together, and leads to
optimal clarity. I also insist that curly braces be used around single
statements, in loops and tests, even when not strictly required by the
language.  Finally, having grown up in England and lived in Norway,
which have contradictory punctuation rules, I am utterly confused
about punctuation and have probably made many errors. With that little
spiel said, I now pass the torch to future authors and wish everyone
luck. I am happy to see an old summer job not go to waste.

Mark Burgess, Oslo March 2001



@node Reserved words in C, Precedence of operators, A note from the original author, Top
@appendix Reserved words in C

@cindex Reserved words in C
@cindex C, reserved words in

Blah blah blah.

Here is a list of all the reserved words in C.  The set of reserved
words above is used to build up the basic instructions of C; you can not
use them in programs your write

Please note that this list is somewhat misleading.  Many more words are
out of bounds.  This is because most of the facilities which C offers
are in libraries that are included in programs.  Once a library has been
included in a program, its functions are defined and you cannot use
their names yourself.

C requires all of these reserved words to be in lower
case.  (This does mean that, typed in upper case, the reserved words
could be used as variable names, but this is not recommended.)

(A "d" by the word implies that it is used as part of a
declaration.)

@smallexample
auto @r{d}                   if
     break                        int @r{d}
     case                         long @r{d}
     char @r{d}                   register @r{d}
     continue                     return
     default                      short @r{d}
     do                           sizeof
     double @r{d}                 static @r{d}
     else                         struct
     entry                        switch
     extern @r{d}                 typedef @r{d}
     float @r{d}                  union @r{d}
     for                          unsigned @r{d}
     goto                         while

     @emph{also in modern implementations:}

     enum @r{d}
     void @r{d}

     const @r{d}
     signed @r{d}
     volatile @r{d}
@end smallexample





@node Precedence of operators, Special characters, Reserved words in C, Top
@appendix Precedence of operators

@cindex Operators, precedence of
@cindex Precedence of operators

The highest priority operators are listed first.

@smallexample
@var{Operator}         @var{Operation}                     @var{Evaluated}

    ()              parentheses                   left to right
    []              square brackets               left to right

    ++              increment                     right to left
    --              decrement                     right to left
  (type)            cast operator                 right to left
    *               the contents of               right to left
    &               the address of                right to left
    -               unary minus                   right to left
    ~               one's complement              right to left
    !               logical NOT                   right to left

    *               multiply                      left to right
    /               divide                        left to right
    %               remainder (MOD)               left to right

    +               add                           left to right
    -               subtract                      left to right

    >>              shift right                   left to right
    <<              shift left                    left to right

    >               is greater than               left to right
    >=              greater than or equal to      left to right
    <=              less than or equal to         left to right
    <               less than                     left to right

    ==              is equal to                   left to right
    !=              is not equal to               left to right

    &               bitwise AND                   left to right
    ^               bitwise exclusive OR          left to right
    |               bitwsie includive OR          left to right
    &&              logical AND                   left to right
    ||              logical OR                    left to right

    =               assign                        right to left
    +=              add assign                    right to left
    -=              subtract assign               right to left
    *=              multiply assign               right to left
    /=              divide assign                 right to left
    %=              remainder assign              right to left
    >>=             right shift assign            right to left
    <<=             left shift assign             right to left
    &=              AND assign                    right to left
    ^=              exclusive OR assign           right to left
    |=              inclusive OR assign           right to left
@end smallexample




@node Special characters, Character conversion table, Precedence of operators, Top
@appendix Special characters

@cindex Special characters
@cindex Characters, special

Control characters are invisible on the screen.  They have special
purposes usually to do with cursor movement and are written into an
ordinary string or character by typing a backslash character \
followed by some other character.  These characters are listed below.

A character can be any ASCII character, printable or not printable
from values -128 to 127.  (But only 0 to 127 are used.) Control
characters i.e. non printable characters are put into programs by
using a backslash @code{\} and a special character or number.  The characters
and their meanings are:

@table @samp
@item     \b
        backspace BS
@item     \f
        form feed FF (also clear screen)
@item     \n
        new line  NL (like pressing return)
@item     \r
        carriage return CR (cursor to start of line)
@item     \t
        horizontal tab HT
@item     \v
        vertical tab (not all versions)
@item     \x
        ???
@item     \"
        double quotes (not all versions)
@item     \'
        single quote character '
@item     \\
        backslash character    \
@item     \@var{ddd}
      character @var{ddd} where ddd is an ASCII code
               given in octal or base 8.  (See Appendix C)

@end table

Here is a code example that prints special characters:

@c RWHE
@c ANSIfy!

@smallexample
/***************************************************/
/*                                                 */
/* Special Characters                              */
/*                                                 */
/***************************************************/

#include <stdio.h>

main ()

@{
printf ("Beep! \7 \n");
printf ("ch = \'a\' \n");
printf (" <- Start of this line!! \r");
@}
@end smallexample
@noindent
The output of this program is:

@smallexample
Beep!  @r{(and the BELL sound)}
ch = 'a'
 <- Start of this line!!
@end smallexample

@noindent
and the text cursor is left where the arrow points.



@node Character conversion table, A word about goto, Special characters, Top
@appendix Character conversion table

@cindex Character conversion table
@cindex Conversion table, character

This table lists the decimal, octal, and hexadecimal numbers for
characters 0 -- 127.

@smallexample
@group
Decimal  Octal  Hexadecimal  Character

  0       0          0         CTRL-@@
  1       1          1         CTRL-A
  2       2          2         CTRL-B
  3       3          3         CTRL-C
  4       4          4         CTRL-D
  5       5          5         CTRL-E
@end group
@group
  6       6          6         CTRL-F
  7       7          7         CTRL-G
  8      10          8         CTRL-H
  9      11          9         CTRL-I
 10      12          A         CTRL-J
 11      13          B         CTRL-K
 12      14          C         CTRL-L
 13      15          D         CTRL-M
 14      16          E         CTRL-N
 15      17          F         CTRL-O
 16      20         10         CTRL-P
 17      21         11         CTRL-Q
 18      22         12         CTRL-R
 19      23         13         CTRL-S
 20      24         14         CTRL-T
 21      25         15         CTRL-U
 22      26         16         CTRL-V
 23      27         17         CTRL-W
 24      30         18         CTRL-X
 25      31         19         CTRL-Y
 26      32         1A         CTRL-Z
 27      33         1B         CTRL-[
 28      34         1C         CTRL-\
 29      35         1D         CTRL-]
 30      36         1E         CTRL-^
 31      37         1F         CTRL-_
 32      40         20
 33      41         21         !
 34      42         22         "
 35      43         23         #
 36      44         24         $
 37      45         25         %
 38      46         26         &
 39      47         27         '
 40      50         28         (
 41      51         29         )
 42      52         2A         *
 43      53         2B         +
 44      54         2C         ,
 45      55         2D         -
 46      56         2E         .
 47      57         2F         /
 48      60         30         0
 49      61         31         1
 50      62         32         2
 51      63         33         3
 52      64         34         4
 53      65         35         5
 54      66         36         6
 55      67         37         7
 56      70         38         8
 57      71         39         9
 58      72         3A         :
 59      73         3B         ;
 60      74         3C         <
 61      75         3D         =
 62      76         3E         >
 63      77         3F         ?
 64     100         40         @@
 65     101         41         A
 66     102         42         B
 67     103         43         C
 68     104         44         D
 69     105         45         E
 70     106         46         F
 71     107         47         G
 72     110         48         H
 73     111         49         I
 74     112         4A         J
 75     113         4B         K
 76     114         4C         L
 77     115         4D         M
 78     116         4E         N
 79     117         4F         O
 80     120         50         P
 81     121         51         Q
 82     122         52         R
 83     123         53         S
 84     124         54         T
 85     125         55         U
 86     126         56         V
 87     127         57         W
 88     130         58         X
 89     131         59         Y
 90     132         5A         Z
 91     133         5B         [
 92     134         5C         \
 93     135         5D         ]
 94     136         5E         ^
 95     137         5F         _
 96     140         60         `
 97     141         61         a
 98     142         62         b
 99     143         63         c
100     144         64         d
101     145         65         e
102     146         66         f
103     147         67         g
104     150         68         h
105     151         69         i
106     152         6A         j
107     153         6B         k
108     154         6C         l
109     155         6D         m
110     156         6E         n
111     157         6F         o
112     160         70         p
113     161         71         q
114     162         72         r
115     163         73         s
116     164         74         t
117     165         75         u
118     166         76         v
119     167         77         w
120     170         78         x
121     171         79         y
122     172         7A         z
123     173         7B         @{
124     174         7C         |
125     175         7D         @}
126     176         7E         ~
127     177         7F         DEL
@end group
@end smallexample



@node A word about goto, Answers to questions, Character conversion table, Top
@appendix A word about @code{goto}

@findex goto @r{command}

This word is redundant in C and encourages poor programming style.  For
this reason it has been ignored in this book.  For completeness, and for
those who insist on using it (may their programs recover gracefully) the
form of the goto statement is as follows:

@smallexample
goto label;
@end smallexample
@noindent
@code{label} is an identifier which occurs somewhere else in the given
function and is defined as a label by using the colon:
@smallexample
label : printf ("Ugh!  You used a goto!");
@end smallexample




@node Answers to questions, Bibliography, A word about goto, Top
@appendix Answers to questions

Blah blah blah.


@c ============================= Unnumbered sections ==========================

@node Bibliography, Glossary, Answers to questions, Top
@unnumbered Bibliography

Blah blah blah.



@node Glossary, Code index, Bibliography, Top
@unnumbered Glossary

Blah blah blah.


@node Code index, Concept index, Glossary, Top
@unnumbered Code index

@printindex fn



@node Concept index, Bits and pieces, Code index, Top
@unnumbered Concept index

@printindex cp



@node Bits and pieces,  , Concept index, Top
@unnumbered Bits and pieces

This section is for random chunks of text that are too good to drop from
the book, but were out-of-place where they were.


@menu
* Allocating memory for strings::  
* Characters::                  
* Assigning variables to one another::  
* Function pointers::           
@end menu

@node Allocating memory for strings, Characters, Bits and pieces, Bits and pieces
@section Allocating memory for strings

Neither of the methods above is any good if a program is going to
be fetching a lot of strings from a user.  It just isn't practical to
define lots of static strings and expect the user to type into the
right size boxes!  The next step in string handling is therefore to
allocate memory for strings personally: in other words to be able to
say how much storage is needed for a string while a program is
running.  C has special memory allocation functions which can do this,
not only for strings but for any kind of object.
Suppose then that a program is going to get ten strings from the
user.  Here is one way in which it could be done:
@enumerate
@item
 Define one large, static string (or array) for getting
     one string at a time.  Call this a string buffer, or
     waiting place.

@item
 Define an array of ten pointers to characters, so that
     the strings can be recalled easily.

@item
 Find out how long the string in the string buffer is.

@item
 Allocate memory for the string.

@item
 Copy the string from the buffer to the new storage and
     place a pointer to it in the array of pointers for
     reference.

@item
   Release the memory when it is finished with.

@end enumerate


@node Characters, Assigning variables to one another, Allocating memory for strings, Bits and pieces
@section Characters

In C, single characters are written enclosed by single quotes.  This is
in contrast to strings of characters, which use double quotes
(@samp{"@dots{}"}).

@smallexample
int ch;
ch = 'a';
@end smallexample

@noindent
would give @code{ch} the value of the character @samp{a}.  The same effect can also
be achieved by writing:

@smallexample
char ch = 'a';
@end smallexample
@noindent
It is also possible to have the type:

@smallexample
unsigned char
@end smallexample
@noindent
This admits ASCII values from 0 to 255, rather than -128 to 127.



@menu
* Assigning variables to one another::  
* Function pointers::           
@end menu



@node  Assigning variables to one another, Function pointers, Characters, Bits and pieces
@section Assigning variables to one another

Not only can you assign numbers to variables, you can assign other
variables to variables:

@smallexample
var1 = 23;
var2 = var1;
@end smallexample

@noindent
The variable or value on either side of the @samp{=} symbol must
usually be of the same type.  However, integers and characters will
interconvert because characters are stored by their ASCII codes (which
are integers!)  Thus the following will work:

@smallexample
int i;
char ch = 'A';

i = ch;

printf ("The ASCII code of %c is %d",ch,i);
@end smallexample
@noindent
The result of this would be:

@smallexample
The ASCII code of A is 65
@end smallexample



@node Function pointers,  , Assigning variables to one another, Bits and pieces
@section Function pointers

You can create pointers to functions as well as to variables.  Function
pointers can be tricky, however, and caution is advised in using them.

Function pointers allow you to pass functions as a parameters to
another function.  This enables you to give the latter function a choice
of functions to call.  That is, you can plug in a new function in
place of an old one simply by passing a different parameter.  This
technique is sometimes called @dfn{indirection} or @dfn{vectoring}.

To pass a pointer for one function to a second function, simply use the
name of the first function, as long as there is no variable with the
same name.  Do not include the first function's parentheses or parameters
when you pass its name.

For example, the following code passes a pointer for the function named
@code{fred_function} to the function @code{barbara_function}:

@smallexample
void fred();
barbara (fred);
@end smallexample

@noindent
Notice that @code{fred} is declared with a regular function prototype
before @code{barbara} calls it.  You must also declare @code{barbara}, of
course:

@smallexample
void barbara (void (*function_ptr)() );
@end smallexample

@noindent
Notice the parentheses around @code{function_ptr} and the parentheses
after it.  As far as @code{barbara} is concerned, any function passed to
it is named @code{(*function_ptr)()}, and this is how @code{fred} is
called in the example below:

@smallexample
#include <stdio.h>

void fred();
void barbara ( void (*function_ptr)() );
int main();

int main()
@{
  barbara (fred);
  return 0;
@}

void fred()
@{
  printf("fred here!\n");
@}

void barbara ( void (*function_ptr)() )
@{
  /* Call fred */
  (*function_ptr)();
@}
@end smallexample

@noindent
The output from this example is simply @samp{fred here!}.

Again, notice how @code{barbara} called @code{fred}.
Given a pointer to a function, the syntax for calling the function is as
follows:

@smallexample
@var{variable} = (*@var{function_pointer})(@var{parameter_list});
@end smallexample

For example, in the program below, the function @code{do_math} calls the
functions @code{add} and @code{subtract} with the following line:

@smallexample
result = (*math_fn_ptr) (num1, num2);
@end smallexample

Here is the example program:

@smallexample
#include <stdio.h>

int add (int, int);
int subtract (int, int);
int do_math (int (*math_fn_ptr) (int, int), int, int);
int main();

int main()
@{
  int result;

  result = do_math (add, 10, 5);
  printf ("Addition = %d.\n", result);

  result = do_math (subtract, 40, 5);
  printf ("Subtraction = %d.\n\n", result);

  return 0;
@}

int add (int num1, int num2)
@{
  return (num1 + num2);
@}


int subtract (int num1, int num2)
@{
  return (num1 - num2);
@}


int do_math (int (*math_fn_ptr) (int, int), int num1, int num2)
@{
  int result;

  printf ("\ndo_math here.\n");

  /* Call one of the math functions passed to us:
     either add or subtract. */

  result = (*math_fn_ptr) (num1, num2);
  return result;
@}
@end smallexample

@noindent
The output from this program reads:

@smallexample
do_math here.
Addition = 15.

do_math here.
Subtraction = 35.
@end smallexample

You can also initialize a function pointer by setting it to the name of
a function, then treating the function pointer as an ordinary function,
as in the next example:

@smallexample
#include <stdio.h>

int main();
void print_it();
void (*fn_ptr)();

int main()
@{
  void (*fn_ptr)() = print_it;

  (*fn_ptr)();

  return 0;
@}

void print_it()
@{
  printf("We are here!  We are here!\n\n");
@}
@end smallexample

Remember to initialize any function pointers you use this way!  If
you do not, your program will probably crash, because the uninitialized
function pointer will contain garbage.



@contents




@bye
